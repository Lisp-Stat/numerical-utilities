\input texinfo

@c num-utils.texi --- Reference manual

@c Copyright (C) 2017--2021 Steven Nunez

@c This file is part of Numerical Utilities.



@c Commentary:

@c Generated automatically by Declt version 2.4 patchlevel 1 "Will Decker"
@c on Fri Apr 02 11:25:42 2021 GMT+8.


@c ====================================================================
@c Header
@c ====================================================================
@c %**start of header
@setfilename num-utils.info
@settitle The Numerical Utilities Reference Manual
@afourpaper
@documentencoding UTF-8
@c %**end of header



@c ====================================================================
@c Format Specific Tweaks
@c ====================================================================
@tex
%% Declt uses several Unicode characters to "reveal" blanks. This
%% works fine in HTML or Info output, but TeX will have problems with
%% these. The code below translates those characters to something that
%% TeX can handle.

%% U+23B5 (Bottom Square Bracket), used to reveal white spaces, is
%% translated to its Computer Modern teletype version.
\DeclareUnicodeCharacter{23B5}{{\tt\char'040}}

%% U+21B5 (Downwards Arrow With Corner Leftwards), used to reveal
%% carriage returns, is translated to \hookleftarrow in math mode.
\DeclareUnicodeCharacter{21B5}{\ensuremath\hookleftarrow}

%% U+21E5 (Rightwards Arrow To Bar), used to reveal tabs, is
%% translated to something that looks similar, based on a rightarrow
%% and a vertical bar from the math extension font.
\DeclareUnicodeCharacter{21E5}{%
  \ensuremath{\rightarrow\kern-.5em\mathchar\"130C}}


%% Declt uses several Unicode characters to replace "fragile" ones in
%% anchor names and references. These characters are chosen to resemble
%% the original ones, without interfering with Info syntax. In TeX
%% however, we can switch them back to the original versions, because
%% cross-references are done differently. In theory, I think we could do
%% something similar for HTML output (again, only the Info syntax poses
%% problems), but I don't know how to do something similar to what's
%% below.

%% U+2024 (One Dot Leader) replaces periods.
\DeclareUnicodeCharacter{2024}{.}

%% U+2236 (Ratio) replaces colons.
\DeclareUnicodeCharacter{2236}{:}

%% U+2768 (Medium Left Parenthesis Ornament) replaces left parenthesis.
\DeclareUnicodeCharacter{2768}{(}

%% U+2769 (Medium Right Parenthesis Ornament) replaces right parenthesis.
\DeclareUnicodeCharacter{2769}{)}

%% U+214B (Turned Ampersand) replaces ampersands.
\DeclareUnicodeCharacter{214B}{&}

%% U+2216 (Set Minus) replaces backslashes.
\DeclareUnicodeCharacter{2216}{\char"5C}

%% The following ones are already defined in texinfo.tex so we have nothing
%% more to do:
%% U+201A (Single Low-9 Quotation Mark) replaces commas.
%% U+2205 (Empty Set) replaces empty symbol names.

@end tex



@c ====================================================================
@c Settings
@c ====================================================================
@setchapternewpage odd
@documentdescription
The Numerical Utilities Reference Manual, version 1.1.
@end documentdescription



@c ====================================================================
@c New Commands
@c ====================================================================

@c ---------------
@c Indexing macros
@c ---------------

@c Packages
@macro packageindex{name}
@tpindex \name\
@tpindex @r{Package, }\name\
@end macro

@c Systems
@macro systemindex{name}
@tpindex \name\
@tpindex @r{System, }\name\
@end macro

@c Modules
@macro moduleindex{name}
@cindex @t{\name\}
@cindex Module, @t{\name\}
@end macro

@c Other files
@macro otherfileindex{name}
@cindex @t{\name\}
@cindex Other File, @t{\name\}
@cindex File, other, @t{\name\}
@end macro

@c Lisp files
@macro lispfileindex{name}
@cindex @t{\name\}
@cindex Lisp File, @t{\name\}
@cindex File, Lisp, @t{\name\}
@end macro

@c C files
@macro cfileindex{name}
@cindex @t{\name\}
@cindex C File, @t{\name\}
@cindex File, C, @t{\name\}
@end macro

@c Java files
@macro javafileindex{name}
@cindex @t{\name\}
@cindex Java File, @t{\name\}
@cindex File, Java, @t{\name\}
@end macro

@c Static files
@macro staticfileindex{name}
@cindex @t{\name\}
@cindex Static File, @t{\name\}
@cindex File, static, @t{\name\}
@end macro

@c Doc files
@macro docfileindex{name}
@cindex @t{\name\}
@cindex Doc File, @t{\name\}
@cindex File, doc, @t{\name\}
@end macro

@c HTML files
@macro htmlfileindex{name}
@cindex @t{\name\}
@cindex HTML File, @t{\name\}
@cindex File, html, @t{\name\}
@end macro

@c The following macros are meant to be used within @defxxx environments.
@c Texinfo performs half the indexing job and we do the other half.

@c Constants
@macro constantsubindex{name}
@vindex @r{Constant, }\name\
@end macro

@c Special variables
@macro specialsubindex{name}
@vindex @r{Special Variable, }\name\
@end macro

@c Symbol macros
@macro symbolmacrosubindex{name}
@vindex @r{Symbol Macro, }\name\
@end macro

@c Slots
@macro slotsubindex{name}
@vindex @r{Slot, }\name\
@end macro

@c Macros
@macro macrosubindex{name}
@findex @r{Macro, }\name\
@end macro

@c Compiler Macros
@macro compilermacrosubindex{name}
@findex @r{Compiler Macro, }\name\
@end macro

@c Functions
@macro functionsubindex{name}
@findex @r{Function, }\name\
@end macro

@c Methods
@macro methodsubindex{name}
@findex @r{Method, }\name\
@end macro

@c Generic Functions
@macro genericsubindex{name}
@findex @r{Generic Function, }\name\
@end macro

@c Setf Expanders
@macro setfexpandersubindex{name}
@findex @r{Setf Expander, }\name\
@end macro

@c Method Combinations
@macro shortcombinationsubindex{name}
@tpindex @r{Short Method Combination, }\name\
@tpindex @r{Method Combination, Short, }\name\
@end macro

@macro longcombinationsubindex{name}
@tpindex @r{Long Method Combination, }\name\
@tpindex @r{Method Combination, Long, }\name\
@end macro

@c Conditions
@macro conditionsubindex{name}
@tpindex @r{Condition, }\name\
@end macro

@c Structures
@macro structuresubindex{name}
@tpindex @r{Structure, }\name\
@end macro

@c Types
@macro typesubindex{name}
@tpindex @r{Type, }\name\
@end macro

@c Classes
@macro classsubindex{name}
@tpindex @r{Class, }\name\
@end macro



@c ====================================================================
@c Info Category and Directory
@c ====================================================================
@dircategory Common Lisp
@direntry
* Numerical Utilities Reference: (num-utils). The Numerical Utilities Reference Manual.
@end direntry



@c ====================================================================
@c Title Page
@c ====================================================================
@titlepage
@title The Numerical Utilities Reference Manual
@subtitle Numerical utilities for Common Lisp, version 1.1

@author Steven Nunez <@email{steve@atchar{}symbolics.tech}>

@end titlepage



@c ====================================================================
@c Table of Contents
@c ====================================================================
@contents



@c ====================================================================
@c Top
@c ====================================================================
@ifnottex
@node Top, Systems, (dir), (dir)
@top The Numerical Utilities Reference Manual
This is the Numerical Utilities Reference Manual, version 1.1.

@menu
* Systems:: The systems documentation
* Files:: The files documentation
* Packages:: The packages documentation
* Definitions:: The symbols documentation
* Indexes:: Concepts, functions, variables and data types
@end menu
@end ifnottex



@c ====================================================================
@c Systems
@c ====================================================================
@node Systems, Files, Top, Top
@chapter Systems
The main system appears first, followed by any subsystem dependency.

@menu
* The num-utils system::
@end menu


@c --------------------
@c The num-utils system
@c --------------------
@node The num-utils system, , Systems, Systems
@section @t{num-utils}
@anchor{go to the num-utils system}@c
@systemindex{num-utils}@c
@table @strong
@item Author
Steven Nunez <@email{steve@atchar{}symbolics.tech}>
@item License
MS-PL
@item Description
Numerical utilities for Common Lisp
@item Version
1.1
@item Dependencies
@itemize @bullet
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{array-operations}
@item
@t{select}
@item
@t{let-plus}
@end itemize
@item Source
@ref{go to the num-utils․asd file, , @t{num-utils.asd}} (file)
@item Directory
@url{file://s:/src/num-utils/, ignore, @t{s:/src/num-utils/}}
@item Components
@itemize @bullet
@item
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@item
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@item
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@item
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@item
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item
@ref{go to the num-utils/print-matrix․lisp file, , @t{print-matrix.lisp}} (file)
@item
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@item
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@item
@ref{go to the num-utils/polynomial․lisp file, , @t{polynomial.lisp}} (file)
@item
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@item
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@item
@ref{go to the num-utils/common-package․lisp file, , @t{common-package.lisp}} (file)
@end itemize
@end table



@c ====================================================================
@c Files
@c ====================================================================
@node Files, Packages, Systems, Top
@chapter Files
Files are sorted by type and then listed depth-first from the systems
components trees.

@menu
* Lisp files::
@end menu


@c ----------
@c Lisp files
@c ----------
@node Lisp files, , Files, Files
@section Lisp
@menu
* The num-utils.asd file: The num-utils․asd file.
* The num-utils/packages.lisp file: The num-utils/packages․lisp file.
* The num-utils/utilities.lisp file: The num-utils/utilities․lisp file.
* The num-utils/num=.lisp file: The num-utils/num=․lisp file.
* The num-utils/arithmetic.lisp file: The num-utils/arithmetic․lisp file.
* The num-utils/elementwise.lisp file: The num-utils/elementwise․lisp file.
* The num-utils/extended-real.lisp file: The num-utils/extended-real․lisp file.
* The num-utils/interval.lisp file: The num-utils/interval․lisp file.
* The num-utils/print-matrix.lisp file: The num-utils/print-matrix․lisp file.
* The num-utils/matrix.lisp file: The num-utils/matrix․lisp file.
* The num-utils/matrix-shorthand.lisp file: The num-utils/matrix-shorthand․lisp file.
* The num-utils/statistics.lisp file: The num-utils/statistics․lisp file.
* The num-utils/chebyshev.lisp file: The num-utils/chebyshev․lisp file.
* The num-utils/polynomial.lisp file: The num-utils/polynomial․lisp file.
* The num-utils/rootfinding.lisp file: The num-utils/rootfinding․lisp file.
* The num-utils/quadrature.lisp file: The num-utils/quadrature․lisp file.
* The num-utils/test-utilities.lisp file: The num-utils/test-utilities․lisp file.
* The num-utils/common-package.lisp file: The num-utils/common-package․lisp file.
@end menu

@node The num-utils․asd file, The num-utils/packages․lisp file, Lisp files, Lisp files
@subsection @t{num-utils.asd}
@anchor{go to the num-utils․asd file}@c
@lispfileindex{num-utils.asd}@c
@table @strong
@item Location
@url{file://s:/src/num-utils/num-utils.asd, ignore, @t{/src/num-utils/num-utils.asd}}
@item Systems
@ref{go to the num-utils system, , @t{num-utils}} (system)
@end table

@node The num-utils/packages․lisp file, The num-utils/utilities․lisp file, The num-utils․asd file, Lisp files
@subsection @t{num-utils/packages.lisp}
@anchor{go to the num-utils/packages․lisp file}@c
@lispfileindex{num-utils/packages.lisp}@c
@table @strong
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/packages.lisp, ignore, @t{packages.lisp}}
@item Packages
@itemize @bullet
@item
@ref{go to the NUM-UTILS․POLYNOMIAL package, , @t{num-utils.polynomial}}
@item
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX package, , @t{num-utils.print-matrix}}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@end itemize
@end table

@node The num-utils/utilities․lisp file, The num-utils/num=․lisp file, The num-utils/packages․lisp file, Lisp files
@subsection @t{num-utils/utilities.lisp}
@anchor{go to the num-utils/utilities․lisp file}@c
@lispfileindex{num-utils/utilities.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/utilities.lisp, ignore, @t{utilities.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-ALIST generic function, , @t{as-alist}} (generic function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-DOUBLE-FLOAT function, , @t{as-double-float}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-PLIST generic function, , @t{as-plist}} (generic function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-PLIST COMMON-LISP∶∶T method, , @t{as-plist}} (method)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-SIMPLE-FIXNUM-VECTOR function, , @t{as-simple-fixnum-vector}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶BIC function, , @t{bic}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶BINARY-SEARCH function, , @t{binary-search}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶CHECK-TYPES macro, , @t{check-types}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶CURRY* macro, , @t{curry*}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶DEFINE-WITH-MULTIPLE-BINDINGS macro, , @t{define-with-multiple-bindings}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶EXPANDING macro, , @t{expanding}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶FIXNUM? function, , @t{fixnum?}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶GENERATE-SEQUENCE function, , @t{generate-sequence}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶GETHASH* macro, , @t{gethash*}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶MAKE-VECTOR compiler macro, , @t{make-vector}} (compiler macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶MAKE-VECTOR function, , @t{make-vector}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SEQUENCEP function, , @t{sequencep}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-DOUBLE-FLOAT-VECTOR type, , @t{simple-double-float-vector}} (type)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-FIXNUM-VECTOR type, , @t{simple-fixnum-vector}} (type)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-SINGLE-FLOAT-VECTOR type, , @t{simple-single-float-vector}} (type)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SPLICE-AWHEN macro, , @t{splice-awhen}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SPLICE-WHEN macro, , @t{splice-when}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶UNLESSF macro, , @t{unlessf}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶WITH-DOUBLE-FLOATS macro, , @t{with-double-floats}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶WITHIN? function, , @t{within?}} (function)
@end itemize
@end table

@node The num-utils/num=․lisp file, The num-utils/arithmetic․lisp file, The num-utils/utilities․lisp file, Lisp files
@subsection @t{num-utils/num=.lisp}
@anchor{go to the num-utils/num=․lisp file}@c
@lispfileindex{num-utils/num=.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/num=.lisp, ignore, @t{num=.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․NUM=∶∶*NUM=-TOLERANCE* special variable, , @t{*num=-tolerance*}} (special variable)
@item
@ref{go to the NUM-UTILS․NUM=∶∶DEFINE-NUM=-WITH-ACCESSORS macro, , @t{define-num=-with-accessors}} (macro)
@item
@ref{go to the NUM-UTILS․NUM=∶∶DEFINE-STRUCTURE-NUM= macro, , @t{define-structure-num=}} (macro)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM-DELTA function, , @t{num-delta}} (function)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= generic function, , @t{num=}} (generic function)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶CONS COMMON-LISP∶∶CONS method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶NULL COMMON-LISP∶∶NULL method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM=-FUNCTION function, , @t{num=-function}} (function)
@end itemize
@end table

@node The num-utils/arithmetic․lisp file, The num-utils/elementwise․lisp file, The num-utils/num=․lisp file, Lisp files
@subsection @t{num-utils/arithmetic.lisp}
@anchor{go to the num-utils/arithmetic․lisp file}@c
@lispfileindex{num-utils/arithmetic.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/arithmetic.lisp, ignore, @t{arithmetic.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶1C function, , @t{1c}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶ABS-DIFF function, , @t{abs-diff}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶ABSOLUTE-SQUARE function, , @t{absolute-square}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶AS-INTEGER function, , @t{as-integer}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶CEILING* function, , @t{ceiling*}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶CUMULATIVE-PRODUCT function, , @t{cumulative-product}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶CUMULATIVE-SUM function, , @t{cumulative-sum}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶DIVIDES? function, , @t{divides?}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶FLOOR* function, , @t{floor*}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶IVEC function, , @t{ivec}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM function, , @t{l2norm}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM-SQUARE generic function, , @t{l2norm-square}} (generic function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM-SQUARE COMMON-LISP∶∶SEQUENCE method, , @t{l2norm-square}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶LOG10 function, , @t{log10}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶LOG2 function, , @t{log2}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶MULTF macro, , @t{multf}} (macro)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶NORMALIZE-PROBABILITIES function, , @t{normalize-probabilities}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶NUMSEQ function, , @t{numseq}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT generic function, , @t{product}} (generic function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT COMMON-LISP∶∶SEQUENCE method, , @t{product}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT COMMON-LISP∶∶ARRAY method, , @t{product}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶ROUND* function, , @t{round*}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SAME-SIGN-P function, , @t{same-sign-p}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SEQUENCE-MAXIMUM function, , @t{sequence-maximum}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SEQUENCE-MINIMUM function, , @t{sequence-minimum}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SQUARE function, , @t{square}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SUM generic function, , @t{sum}} (generic function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SUM COMMON-LISP∶∶SEQUENCE method, , @t{sum}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SUM COMMON-LISP∶∶ARRAY method, , @t{sum}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶TRUNCATE* function, , @t{truncate*}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶DEFINE-ROUNDING-WITH-OFFSET macro, , @t{define-rounding-with-offset}} (macro)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SIMILAR-ELEMENT-TYPE function, , @t{similar-element-type}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SIMILAR-SEQUENCE-TYPE function, , @t{similar-sequence-type}} (function)
@end itemize
@end table

@node The num-utils/elementwise․lisp file, The num-utils/extended-real․lisp file, The num-utils/arithmetic․lisp file, Lisp files
@subsection @t{num-utils/elementwise.lisp}
@anchor{go to the num-utils/elementwise․lisp file}@c
@lispfileindex{num-utils/elementwise.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/elementwise.lisp, ignore, @t{elementwise.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E* function, , @t{e*}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E+ function, , @t{e+}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E- function, , @t{e-}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E/ function, , @t{e/}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- generic function, , @t{e1-}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- COMMON-LISP∶∶NUMBER method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- COMMON-LISP∶∶ARRAY method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ generic function, , @t{e1/}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ COMMON-LISP∶∶NUMBER method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ COMMON-LISP∶∶ARRAY method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG generic function, , @t{e1log}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG COMMON-LISP∶∶NUMBER method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG COMMON-LISP∶∶ARRAY method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* generic function, , @t{e2*}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ generic function, , @t{e2+}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- generic function, , @t{e2-}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ generic function, , @t{e2/}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG generic function, , @t{e2log}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING generic function, , @t{eceiling}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING COMMON-LISP∶∶NUMBER method, , @t{eceiling}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING COMMON-LISP∶∶ARRAY method, , @t{eceiling}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE generic function, , @t{econjugate}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE COMMON-LISP∶∶NUMBER method, , @t{econjugate}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE COMMON-LISP∶∶ARRAY method, , @t{econjugate}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP generic function, , @t{eexp}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP COMMON-LISP∶∶NUMBER method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP COMMON-LISP∶∶ARRAY method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT generic function, , @t{eexpt}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR generic function, , @t{efloor}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR COMMON-LISP∶∶NUMBER method, , @t{efloor}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR COMMON-LISP∶∶ARRAY method, , @t{efloor}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ELEMENTWISE-FLOAT-CONTAGION function, , @t{elementwise-float-contagion}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ELOG function, , @t{elog}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EMAX function, , @t{emax}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EMIN function, , @t{emin}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE generic function, , @t{ereduce}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶ARRAY method, , @t{ereduce}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶SEQUENCE method, , @t{ereduce}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{ereduce}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT generic function, , @t{esqrt}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT COMMON-LISP∶∶NUMBER method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT COMMON-LISP∶∶ARRAY method, , @t{esqrt}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E⅋ macro, , @t{define-e@ampchar{}}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E1 macro, , @t{define-e1}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E2 macro, , @t{define-e2}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-ELEMENTWISE-REDUCTION macro, , @t{define-elementwise-reduction}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE generic function, , @t{esquare}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE COMMON-LISP∶∶NUMBER method, , @t{esquare}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE COMMON-LISP∶∶ARRAY method, , @t{esquare}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶MAPPING-ARRAY macro, , @t{mapping-array}} (macro)
@end itemize
@end table

@node The num-utils/extended-real․lisp file, The num-utils/interval․lisp file, The num-utils/elementwise․lisp file, Lisp files
@subsection @t{num-utils/extended-real.lisp}
@anchor{go to the num-utils/extended-real․lisp file}@c
@lispfileindex{num-utils/extended-real.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/extended-real.lisp, ignore, @t{extended-real.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶< function, , @t{<}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶<= function, , @t{<=}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶= function, , @t{=}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶> function, , @t{>}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶>= function, , @t{>=}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶EXTENDED-REAL type, , @t{extended-real}} (type)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶INFINITE? function, , @t{infinite?}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶LAMBDA-TEMPLATE macro, , @t{lambda-template}} (macro)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶WITH-TEMPLATE macro, , @t{with-template}} (macro)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶DEFINE-COMPARISON macro, , @t{define-comparison}} (macro)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶EXTEND-PAIRWISE-COMPARISON function, , @t{extend-pairwise-comparison}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶INFINITE type, , @t{infinite}} (type)
@end itemize
@end table

@node The num-utils/interval․lisp file, The num-utils/print-matrix․lisp file, The num-utils/extended-real․lisp file, Lisp files
@subsection @t{num-utils/interval.lisp}
@anchor{go to the num-utils/interval․lisp file}@c
@lispfileindex{num-utils/interval.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/interval.lisp, ignore, @t{interval.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶⅋INTERVAL macro, , @t{@ampchar{}interval}} (macro)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL generic function, , @t{extend-interval}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶NULL COMMON-LISP∶∶NULL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶NULL COMMON-LISP∶∶REAL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL NUM-UTILS․INTERVAL∶∶INTERVAL COMMON-LISP∶∶REAL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶INTERVAL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶LIST method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶ARRAY method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTENDF-INTERVAL macro, , @t{extendf-interval}} (macro)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL class, , @t{finite-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶GRID-IN function, , @t{grid-in}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶IN-INTERVAL? function, , @t{in-interval?}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL function, , @t{interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL class, , @t{interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-HULL function, , @t{interval-hull}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-LENGTH function, , @t{interval-length}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-MIDPOINT function, , @t{interval-midpoint}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT generic function, , @t{left}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method, , @t{left}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method, , @t{left}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶MINUSINF-INTERVAL class, , @t{minusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶REAL-LINE NUM-UTILS․INTERVAL∶∶REAL-LINE method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? generic function, , @t{open-left?}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method, , @t{open-left?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method, , @t{open-left?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? generic function, , @t{open-right?}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method, , @t{open-right?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method, , @t{open-right?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL class, , @t{plusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PLUSMINUS-INTERVAL function, , @t{plusminus-interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶REAL-LINE class, , @t{real-line}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE function, , @t{relative}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE structure, , @t{relative}} (structure)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT generic function, , @t{right}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method, , @t{right}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method, , @t{right}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SHIFT-INTERVAL generic function, , @t{shift-interval}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SHIFT-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶REAL method, , @t{shift-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SHRINK-INTERVAL function, , @t{shrink-interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER function, , @t{spacer}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER structure, , @t{spacer}} (structure)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPLIT-INTERVAL function, , @t{split-interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SUBINTERVALS-IN function, , @t{subintervals-in}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶COPY-RELATIVE function, , @t{copy-relative}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶COPY-SPACER function, , @t{copy-spacer}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT class, , @t{interval/finite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT class, , @t{interval/finite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT class, , @t{interval/infinite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT class, , @t{interval/infinite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT generic function, , @t{print-left-endpoint}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT COMMON-LISP∶∶T method, , @t{print-left-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT COMMON-LISP∶∶T method, , @t{print-left-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT generic function, , @t{print-right-endpoint}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT COMMON-LISP∶∶T method, , @t{print-right-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT COMMON-LISP∶∶T method, , @t{print-right-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE-FRACTION function, , @t{relative-fraction}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE-P function, , @t{relative-p}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER-P function, , @t{spacer-p}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER-WEIGHT function, , @t{spacer-weight}} (function)
@end itemize
@end table

@node The num-utils/print-matrix․lisp file, The num-utils/matrix․lisp file, The num-utils/interval․lisp file, Lisp files
@subsection @t{num-utils/print-matrix.lisp}
@anchor{go to the num-utils/print-matrix․lisp file}@c
@lispfileindex{num-utils/print-matrix.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/print-matrix.lisp, ignore, @t{print-matrix.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶*PRINT-MATRIX-PRECISION* special variable, , @t{*print-matrix-precision*}} (special variable)
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-LENGTH-TRUNCATE function, , @t{print-length-truncate}} (function)
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-MATRIX function, , @t{print-matrix}} (function)
@end itemize
@item Internal Definitions
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-MATRIX-FORMATTER function, , @t{print-matrix-formatter}} (function)
@end table

@node The num-utils/matrix․lisp file, The num-utils/matrix-shorthand․lisp file, The num-utils/print-matrix․lisp file, Lisp files
@subsection @t{num-utils/matrix.lisp}
@anchor{go to the num-utils/matrix․lisp file}@c
@lispfileindex{num-utils/matrix.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/print-matrix․lisp file, , @t{print-matrix.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/matrix.lisp, ignore, @t{matrix.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX function, , @t{diagonal-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX structure, , @t{diagonal-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX-ELEMENTS function, , @t{diagonal-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-MATRIX-ELEMENTS❩ function, , @t{(setf diagonal-matrix-elements)}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR generic function, , @t{diagonal-vector}} (generic function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR COMMON-LISP∶∶ARRAY method, , @t{diagonal-vector}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR COMMON-LISP∶∶T method, , @t{diagonal-vector}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-VECTOR❩ generic function, , @t{(setf diagonal-vector)}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX function, , @t{hermitian-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX structure, , @t{hermitian-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX function, , @t{lower-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX structure, , @t{lower-triangular-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE generic function, , @t{transpose}} (generic function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE COMMON-LISP∶∶ARRAY method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRIANGULAR-MATRIX type, , @t{triangular-matrix}} (type)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX function, , @t{upper-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX structure, , @t{upper-triangular-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX structure, , @t{wrapped-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX-ELEMENTS function, , @t{wrapped-matrix-elements}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶⅋DIAGONAL-MATRIX macro, , @t{@ampchar{}diagonal-matrix}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶⅋DIAGONAL-MATRIX-R/O macro, , @t{@ampchar{}diagonal-matrix-r/o}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶ABOVE-DIAGONAL? function, , @t{above-diagonal?}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶BELOW-DIAGONAL? function, , @t{below-diagonal?}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-DIAGONAL-MATRIX function, , @t{copy-diagonal-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-HERMITIAN-MATRIX function, , @t{copy-hermitian-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-LOWER-TRIANGULAR-MATRIX function, , @t{copy-lower-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-UPPER-TRIANGULAR-MATRIX function, , @t{copy-upper-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-WRAPPED-MATRIX function, , @t{copy-wrapped-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-AS-ARRAY macro, , @t{define-elementwise-as-array}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-SAME-CLASS macro, , @t{define-elementwise-same-class}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-UNIVARIATE macro, , @t{define-elementwise-univariate}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-WITH-CONSTANT macro, , @t{define-elementwise-with-constant}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-WRAPPED-MATRIX macro, , @t{define-wrapped-matrix}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX-P function, , @t{diagonal-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶ENSURE-VALID-ELEMENTS function, , @t{ensure-valid-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX-ELEMENTS function, , @t{hermitian-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX-P function, , @t{hermitian-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX-ELEMENTS function, , @t{lower-triangular-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX-P function, , @t{lower-triangular-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-DIAGONAL-MATRIX function, , @t{make-diagonal-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-HERMITIAN-MATRIX function, , @t{make-hermitian-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-LOWER-TRIANGULAR-MATRIX function, , @t{make-lower-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-UPPER-TRIANGULAR-MATRIX function, , @t{make-upper-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-WRAPPED-MATRIX function, , @t{make-wrapped-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX-ELEMENTS function, , @t{upper-triangular-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX-P function, , @t{upper-triangular-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶VALID-SPARSE-TYPE? function, , @t{valid-sparse-type?}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX-P function, , @t{wrapped-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶ZERO-LIKE function, , @t{zero-like}} (function)
@end itemize
@end table

@node The num-utils/matrix-shorthand․lisp file, The num-utils/statistics․lisp file, The num-utils/matrix․lisp file, Lisp files
@subsection @t{num-utils/matrix-shorthand.lisp}
@anchor{go to the num-utils/matrix-shorthand․lisp file}@c
@lispfileindex{num-utils/matrix-shorthand.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/matrix-shorthand.lisp, ignore, @t{matrix-shorthand.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶DIAGONAL-MX function, , @t{diagonal-mx}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶HERMITIAN-MX macro, , @t{hermitian-mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶LOWER-TRIANGULAR-MX macro, , @t{lower-triangular-mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶MX macro, , @t{mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶UPPER-TRIANGULAR-MX macro, , @t{upper-triangular-mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶VEC function, , @t{vec}} (function)
@end itemize
@item Internal Definitions
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶PAD-LEFT-EXPANSION function, , @t{pad-left-expansion}} (function)
@end table

@node The num-utils/statistics․lisp file, The num-utils/chebyshev․lisp file, The num-utils/matrix-shorthand․lisp file, Lisp files
@subsection @t{num-utils/statistics.lisp}
@anchor{go to the num-utils/statistics․lisp file}@c
@lispfileindex{num-utils/statistics.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/statistics.lisp, ignore, @t{statistics.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶*CENTRAL-SAMPLE-MOMENTS-DEFAULT-DEGREE* special variable, , @t{*central-sample-moments-default-degree*}} (special variable)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD generic function, , @t{add}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER COMMON-LISP∶∶T method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶REAL method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD COMMON-LISP∶∶T COMMON-LISP∶∶NULL method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-ALIST NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method, , @t{as-alist}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 generic function, , @t{central-m2}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 COMMON-LISP∶∶T method, , @t{central-m2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 generic function, , @t{central-m3}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 COMMON-LISP∶∶T method, , @t{central-m3}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m3}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 generic function, , @t{central-m4}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 COMMON-LISP∶∶T method, , @t{central-m4}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m4}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS generic function, , @t{central-sample-moments}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶NULL method, , @t{central-sample-moments}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-sample-moments}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶SEQUENCE method, , @t{central-sample-moments}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS structure, , @t{central-sample-moments}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-DEGREE function, , @t{central-sample-moments-degree}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CROSS-TABULATE function, , @t{cross-tabulate}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶EMPIRICAL-QUANTILE function, , @t{empirical-quantile}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶EMPIRICAL-QUANTILE-PROBABILITIES function, , @t{empirical-quantile-probabilities}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶EMPTY-ACCUMULATOR condition, , @t{empty-accumulator}} (condition)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS generic function, , @t{ensure-sorted-reals}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS NUM-UTILS․STATISTICS∶∶SORTED-REALS method, , @t{ensure-sorted-reals}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS COMMON-LISP∶∶ARRAY method, , @t{ensure-sorted-reals}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS COMMON-LISP∶∶LIST method, , @t{ensure-sorted-reals}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-VECTOR function, , @t{ensure-sorted-vector}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶INFORMATION-NOT-COLLECTED-IN-ACCUMULATOR condition, , @t{information-not-collected-in-accumulator}} (condition)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS generic function, , @t{kurtosis}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS COMMON-LISP∶∶T method, , @t{kurtosis}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{kurtosis}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-SPARSE-COUNTER function, , @t{make-sparse-counter}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEAN generic function, , @t{mean}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEAN COMMON-LISP∶∶T method, , @t{mean}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEAN NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{mean}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEDIAN generic function, , @t{median}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEDIAN COMMON-LISP∶∶SEQUENCE method, , @t{median}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEDIAN COMMON-LISP∶∶T method, , @t{median}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶NOT-ENOUGH-ELEMENTS-IN-ACCUMULATOR condition, , @t{not-enough-elements-in-accumulator}} (condition)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶POOL function, , @t{pool}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILE generic function, , @t{quantile}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILE COMMON-LISP∶∶SEQUENCE COMMON-LISP∶∶T method, , @t{quantile}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILE COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{quantile}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILES generic function, , @t{quantiles}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILES COMMON-LISP∶∶SEQUENCE COMMON-LISP∶∶T method, , @t{quantiles}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILES NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method, , @t{quantiles}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SD generic function, , @t{sd}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SD COMMON-LISP∶∶T method, , @t{sd}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS generic function, , @t{skewness}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS COMMON-LISP∶∶T method, , @t{skewness}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{skewness}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS structure, , @t{sorted-reals}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-ELEMENTS function, , @t{sorted-reals-elements}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER structure, , @t{sparse-counter}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-COUNT function, , @t{sparse-counter-count}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-TABLE function, , @t{sparse-counter-table}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TABULATE function, , @t{tabulate}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY generic function, , @t{tally}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method, , @t{tally}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶TALLY-MIXIN method, , @t{tally}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶VARIANCE generic function, , @t{variance}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶VARIANCE COMMON-LISP∶∶T method, , @t{variance}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶VARIANCE NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{variance}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-QUANTILES function, , @t{weighted-quantiles}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶⅋SORTED-REALS macro, , @t{@ampchar{}sorted-reals}} (macro)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶⅋SORTED-REALS-R/O macro, , @t{@ampchar{}sorted-reals-r/o}} (macro)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-M function, , @t{central-sample-moments-m}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-M❩ function, , @t{(setf central-sample-moments-m)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-P function, , @t{central-sample-moments-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S2 function, , @t{central-sample-moments-s2}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S2❩ function, , @t{(setf central-sample-moments-s2)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S3 function, , @t{central-sample-moments-s3}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S3❩ function, , @t{(setf central-sample-moments-s3)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S4 function, , @t{central-sample-moments-s4}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S4❩ function, , @t{(setf central-sample-moments-s4)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-W function, , @t{central-sample-moments-w}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-W❩ function, , @t{(setf central-sample-moments-w)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-CENTRAL-SAMPLE-MOMENTS function, , @t{copy-central-sample-moments}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-SORTED-REALS function, , @t{copy-sorted-reals}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-SPARSE-COUNTER function, , @t{copy-sparse-counter}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-TALLY-MIXIN function, , @t{copy-tally-mixin}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶DEFINE-CENTRAL-SAMPLE-MOMENT macro, , @t{define-central-sample-moment}} (macro)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-CENTRAL-SAMPLE-MOMENTS function, , @t{make-central-sample-moments}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-SORTED-REALS function, , @t{make-sorted-reals}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-SPARSE-COUNTER% function, , @t{make-sparse-counter%}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-TALLY-MIXIN function, , @t{make-tally-mixin}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶POOL2 generic function, , @t{pool2}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶POOL2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{pool2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORT-REALS function, , @t{sort-reals}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-ORDERED-ELEMENTS function, , @t{sorted-reals-ordered-elements}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-ORDERED-ELEMENTS❩ function, , @t{(setf sorted-reals-ordered-elements)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-P function, , @t{sorted-reals-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-UNORDERED-ELEMENTS function, , @t{sorted-reals-unordered-elements}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-UNORDERED-ELEMENTS❩ function, , @t{(setf sorted-reals-unordered-elements)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-P function, , @t{sparse-counter-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN structure, , @t{tally-mixin}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN-P function, , @t{tally-mixin-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN-W function, , @t{tally-mixin-w}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF TALLY-MIXIN-W❩ function, , @t{(setf tally-mixin-w)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-EMPIRICAL-QUANTILE function, , @t{weighted-empirical-quantile}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-QUANTILE-P-TABLE function, , @t{weighted-quantile-p-table}} (function)
@end itemize
@end table

@node The num-utils/chebyshev․lisp file, The num-utils/polynomial․lisp file, The num-utils/statistics․lisp file, Lisp files
@subsection @t{num-utils/chebyshev.lisp}
@anchor{go to the num-utils/chebyshev․lisp file}@c
@lispfileindex{num-utils/chebyshev.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/chebyshev.lisp, ignore, @t{chebyshev.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE function, , @t{chebyshev-approximate}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-REGRESSION function, , @t{chebyshev-regression}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-ROOT function, , @t{chebyshev-root}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-ROOTS function, , @t{chebyshev-roots}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶EVALUATE-CHEBYSHEV function, , @t{evaluate-chebyshev}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶AB-TO-CD-INTERCEPT-SLOPE function, , @t{ab-to-cd-intercept-slope}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶AB-TO-CINF function, , @t{ab-to-cinf}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION generic function, , @t{chebyshev-approximate-implementation}} (generic function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{chebyshev-approximate-implementation}} (method)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{chebyshev-approximate-implementation}} (method)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-RECURSION function, , @t{chebyshev-recursion}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CINF-TO-AB function, , @t{cinf-to-ab}} (function)
@end itemize
@end table

@node The num-utils/polynomial․lisp file, The num-utils/rootfinding․lisp file, The num-utils/chebyshev․lisp file, Lisp files
@subsection @t{num-utils/polynomial.lisp}
@anchor{go to the num-utils/polynomial․lisp file}@c
@lispfileindex{num-utils/polynomial.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/polynomial.lisp, ignore, @t{polynomial.lisp}}
@item Exported Definitions
@ref{go to the NUM-UTILS․POLYNOMIAL∶∶EVALUATE-POLYNOMIAL function, , @t{evaluate-polynomial}} (function)
@end table

@node The num-utils/rootfinding․lisp file, The num-utils/quadrature․lisp file, The num-utils/polynomial․lisp file, Lisp files
@subsection @t{num-utils/rootfinding.lisp}
@anchor{go to the num-utils/rootfinding․lisp file}@c
@lispfileindex{num-utils/rootfinding.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/polynomial․lisp file, , @t{polynomial.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/rootfinding.lisp, ignore, @t{rootfinding.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶*ROOTFINDING-DELTA-RELATIVE* special variable, , @t{*rootfinding-delta-relative*}} (special variable)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶*ROOTFINDING-EPSILON* special variable, , @t{*rootfinding-epsilon*}} (special variable)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶ROOT-BISECTION function, , @t{root-bisection}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶NARROW-BRACKET? function, , @t{narrow-bracket?}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶NEAR-ROOT? function, , @t{near-root?}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶OPPOSITE-SIGN? function, , @t{opposite-sign?}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶ROOTFINDING-DELTA function, , @t{rootfinding-delta}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶UNIVARIATE-ROOTFINDER-LOOP% macro, , @t{univariate-rootfinder-loop%}} (macro)
@end itemize
@end table

@node The num-utils/quadrature․lisp file, The num-utils/test-utilities․lisp file, The num-utils/rootfinding․lisp file, Lisp files
@subsection @t{num-utils/quadrature.lisp}
@anchor{go to the num-utils/quadrature․lisp file}@c
@lispfileindex{num-utils/quadrature.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/quadrature.lisp, ignore, @t{quadrature.lisp}}
@item Exported Definitions
@ref{go to the NUM-UTILS․QUADRATURE∶∶ROMBERG-QUADRATURE function, , @t{romberg-quadrature}} (function)
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-ITERATIVE-QUADRATURE function, , @t{copy-iterative-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-MIDPOINT-QUADRATURE function, , @t{copy-midpoint-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-RICHARDSON-EXTRAPOLATION function, , @t{copy-richardson-extrapolation}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-TRAPEZOIDAL-QUADRATURE function, , @t{copy-trapezoidal-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE structure, , @t{iterative-quadrature}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-A function, , @t{iterative-quadrature-a}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-A❩ function, , @t{(setf iterative-quadrature-a)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-B function, , @t{iterative-quadrature-b}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-B❩ function, , @t{(setf iterative-quadrature-b)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-F function, , @t{iterative-quadrature-f}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-F❩ function, , @t{(setf iterative-quadrature-f)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-H function, , @t{iterative-quadrature-h}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-H❩ function, , @t{(setf iterative-quadrature-h)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-N function, , @t{iterative-quadrature-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-N❩ function, , @t{(setf iterative-quadrature-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-P function, , @t{iterative-quadrature-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-SUM function, , @t{iterative-quadrature-sum}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-SUM❩ function, , @t{(setf iterative-quadrature-sum)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MAKE-ITERATIVE-QUADRATURE function, , @t{make-iterative-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE function, , @t{midpoint-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE structure, , @t{midpoint-quadrature}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE% function, , @t{midpoint-quadrature%}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-A function, , @t{midpoint-quadrature-a}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-A❩ function, , @t{(setf midpoint-quadrature-a)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-B function, , @t{midpoint-quadrature-b}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-B❩ function, , @t{(setf midpoint-quadrature-b)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-F function, , @t{midpoint-quadrature-f}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-F❩ function, , @t{(setf midpoint-quadrature-f)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-H function, , @t{midpoint-quadrature-h}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-H❩ function, , @t{(setf midpoint-quadrature-h)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-N function, , @t{midpoint-quadrature-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-N❩ function, , @t{(setf midpoint-quadrature-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-P function, , @t{midpoint-quadrature-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-SUM function, , @t{midpoint-quadrature-sum}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-SUM❩ function, , @t{(setf midpoint-quadrature-sum)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE generic function, , @t{refine-quadrature}} (generic function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method, , @t{refine-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method, , @t{refine-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT generic function, , @t{richardson-coefficient}} (generic function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method, , @t{richardson-coefficient}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method, , @t{richardson-coefficient}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION function, , @t{richardson-extrapolation}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION structure, , @t{richardson-extrapolation}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-COEFFICIENT function, , @t{richardson-extrapolation-coefficient}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-COEFFICIENT❩ function, , @t{(setf richardson-extrapolation-coefficient)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-DIAGONAL function, , @t{richardson-extrapolation-diagonal}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-DIAGONAL❩ function, , @t{(setf richardson-extrapolation-diagonal)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-N function, , @t{richardson-extrapolation-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-N❩ function, , @t{(setf richardson-extrapolation-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-P function, , @t{richardson-extrapolation-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-ITERATION function, , @t{richardson-iteration}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ROMBERG-QUADRATURE% function, , @t{romberg-quadrature%}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE generic function, , @t{transformed-quadrature}} (generic function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶NULL method, , @t{transformed-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶NULL method, , @t{transformed-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE function, , @t{trapezoidal-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE structure, , @t{trapezoidal-quadrature}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE% function, , @t{trapezoidal-quadrature%}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-A function, , @t{trapezoidal-quadrature-a}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-A❩ function, , @t{(setf trapezoidal-quadrature-a)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-B function, , @t{trapezoidal-quadrature-b}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-B❩ function, , @t{(setf trapezoidal-quadrature-b)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-F function, , @t{trapezoidal-quadrature-f}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-F❩ function, , @t{(setf trapezoidal-quadrature-f)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-H function, , @t{trapezoidal-quadrature-h}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-H❩ function, , @t{(setf trapezoidal-quadrature-h)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-N function, , @t{trapezoidal-quadrature-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-N❩ function, , @t{(setf trapezoidal-quadrature-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-P function, , @t{trapezoidal-quadrature-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-SUM function, , @t{trapezoidal-quadrature-sum}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-SUM❩ function, , @t{(setf trapezoidal-quadrature-sum)}} (function)
@end itemize
@end table

@node The num-utils/test-utilities․lisp file, The num-utils/common-package․lisp file, The num-utils/quadrature․lisp file, Lisp files
@subsection @t{num-utils/test-utilities.lisp}
@anchor{go to the num-utils/test-utilities․lisp file}@c
@lispfileindex{num-utils/test-utilities.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/test-utilities.lisp, ignore, @t{test-utilities.lisp}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶COMPARE-FNS function, , @t{compare-fns}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶COMPARE-VECTORS function, , @t{compare-vectors}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MAX-ERROR function, , @t{max-error}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MAX-ERROR❩ function, , @t{(setf max-error)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MEAN-ERROR function, , @t{mean-error}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MEAN-ERROR❩ function, , @t{(setf mean-error)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MIN-ERROR function, , @t{min-error}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MIN-ERROR❩ function, , @t{(setf min-error)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶RMS function, , @t{rms}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF RMS❩ function, , @t{(setf rms)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-COUNT function, , @t{test-count}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF TEST-COUNT❩ function, , @t{(setf test-count)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-FN function, , @t{test-fn}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-RESULTS structure, , @t{test-results}} (structure)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE0 function, , @t{variance0}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE0❩ function, , @t{(setf variance0)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE1 function, , @t{variance1}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE1❩ function, , @t{(setf variance1)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶WORST-CASE function, , @t{worst-case}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF WORST-CASE❩ function, , @t{(setf worst-case)}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶COPY-TEST-RESULTS function, , @t{copy-test-results}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MAKE-TEST-RESULTS function, , @t{make-test-results}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-RESULTS-P function, , @t{test-results-p}} (function)
@end itemize
@end table

@node The num-utils/common-package․lisp file, , The num-utils/test-utilities․lisp file, Lisp files
@subsection @t{num-utils/common-package.lisp}
@anchor{go to the num-utils/common-package․lisp file}@c
@lispfileindex{num-utils/common-package.lisp}@c
@table @strong
@item Dependency
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@item Parent
@ref{go to the num-utils system, , @t{num-utils}} (system)
@item Location
@url{file://s:/src/num-utils/src/common-package.lisp, ignore, @t{common-package.lisp}}
@item Packages
@ref{go to the NUM-UTILS package, , @t{num-utils}}
@end table



@c ====================================================================
@c Packages
@c ====================================================================
@node Packages, Definitions, Files, Top
@chapter Packages
Packages are listed by definition order.

@menu
* The num-utils.polynomial package: The num-utils․polynomial package.
* The num-utils.interval package: The num-utils․interval package.
* The num-utils.print-matrix package: The num-utils․print-matrix package.
* The num-utils.utilities package: The num-utils․utilities package.
* The num-utils.arithmetic package: The num-utils․arithmetic package.
* The num-utils.matrix-shorthand package: The num-utils․matrix-shorthand package.
* The num-utils.num= package: The num-utils․num= package.
* The num-utils.test-utilities package: The num-utils․test-utilities package.
* The num-utils.extended-real package: The num-utils․extended-real package.
* The num-utils.quadrature package: The num-utils․quadrature package.
* The num-utils.statistics package: The num-utils․statistics package.
* The num-utils.rootfinding package: The num-utils․rootfinding package.
* The num-utils.elementwise package: The num-utils․elementwise package.
* The num-utils.chebyshev package: The num-utils․chebyshev package.
* The num-utils.matrix package: The num-utils․matrix package.
* The num-utils package::
@end menu


@c --------------------------------
@c The num-utils.polynomial package
@c --------------------------------
@node The num-utils․polynomial package, The num-utils․interval package, Packages, Packages
@section @t{num-utils.polynomial}
@anchor{go to the NUM-UTILS․POLYNOMIAL package}@c
@packageindex{num-utils.polynomial}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Nickname
@t{poly}
@item Use List
@itemize @bullet
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Exported Definitions
@ref{go to the NUM-UTILS․POLYNOMIAL∶∶EVALUATE-POLYNOMIAL function, , @t{evaluate-polynomial}} (function)
@end table


@c ------------------------------
@c The num-utils.interval package
@c ------------------------------
@node The num-utils․interval package, The num-utils․print-matrix package, The num-utils․polynomial package, Packages
@section @t{num-utils.interval}
@anchor{go to the NUM-UTILS․INTERVAL package}@c
@packageindex{num-utils.interval}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Used By List
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶⅋INTERVAL macro, , @t{@ampchar{}interval}} (macro)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL generic function, , @t{extend-interval}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶NULL COMMON-LISP∶∶NULL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶NULL COMMON-LISP∶∶REAL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL NUM-UTILS․INTERVAL∶∶INTERVAL COMMON-LISP∶∶REAL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶INTERVAL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶LIST method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶ARRAY method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTENDF-INTERVAL macro, , @t{extendf-interval}} (macro)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL class, , @t{finite-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶GRID-IN function, , @t{grid-in}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶IN-INTERVAL? function, , @t{in-interval?}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL function, , @t{interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL class, , @t{interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-HULL function, , @t{interval-hull}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-LENGTH function, , @t{interval-length}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-MIDPOINT function, , @t{interval-midpoint}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT generic function, , @t{left}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method, , @t{left}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method, , @t{left}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶MINUSINF-INTERVAL class, , @t{minusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? generic function, , @t{open-left?}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method, , @t{open-left?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method, , @t{open-left?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? generic function, , @t{open-right?}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method, , @t{open-right?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method, , @t{open-right?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL class, , @t{plusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PLUSMINUS-INTERVAL function, , @t{plusminus-interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶REAL-LINE class, , @t{real-line}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE function, , @t{relative}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE structure, , @t{relative}} (structure)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT generic function, , @t{right}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method, , @t{right}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method, , @t{right}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SHIFT-INTERVAL generic function, , @t{shift-interval}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SHIFT-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶REAL method, , @t{shift-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SHRINK-INTERVAL function, , @t{shrink-interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER function, , @t{spacer}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER structure, , @t{spacer}} (structure)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPLIT-INTERVAL function, , @t{split-interval}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SUBINTERVALS-IN function, , @t{subintervals-in}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶COPY-RELATIVE function, , @t{copy-relative}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶COPY-SPACER function, , @t{copy-spacer}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT class, , @t{interval/finite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT class, , @t{interval/finite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT class, , @t{interval/infinite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT class, , @t{interval/infinite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT generic function, , @t{print-left-endpoint}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT COMMON-LISP∶∶T method, , @t{print-left-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT COMMON-LISP∶∶T method, , @t{print-left-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT generic function, , @t{print-right-endpoint}} (generic function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT COMMON-LISP∶∶T method, , @t{print-right-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT COMMON-LISP∶∶T method, , @t{print-right-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE-FRACTION function, , @t{relative-fraction}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE-P function, , @t{relative-p}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER-P function, , @t{spacer-p}} (function)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER-WEIGHT function, , @t{spacer-weight}} (function)
@end itemize
@end table


@c ----------------------------------
@c The num-utils.print-matrix package
@c ----------------------------------
@node The num-utils․print-matrix package, The num-utils․utilities package, The num-utils․interval package, Packages
@section @t{num-utils.print-matrix}
@anchor{go to the NUM-UTILS․PRINT-MATRIX package}@c
@packageindex{num-utils.print-matrix}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Used By List
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶*PRINT-MATRIX-PRECISION* special variable, , @t{*print-matrix-precision*}} (special variable)
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-LENGTH-TRUNCATE function, , @t{print-length-truncate}} (function)
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-MATRIX function, , @t{print-matrix}} (function)
@end itemize
@item Internal Definitions
@ref{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-MATRIX-FORMATTER function, , @t{print-matrix-formatter}} (function)
@end table


@c -------------------------------
@c The num-utils.utilities package
@c -------------------------------
@node The num-utils․utilities package, The num-utils․arithmetic package, The num-utils․print-matrix package, Packages
@section @t{num-utils.utilities}
@anchor{go to the NUM-UTILS․UTILITIES package}@c
@packageindex{num-utils.utilities}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Used By List
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item
@ref{go to the NUM-UTILS․POLYNOMIAL package, , @t{num-utils.polynomial}}
@item
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-ALIST generic function, , @t{as-alist}} (generic function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-ALIST NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method, , @t{as-alist}} (method)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-DOUBLE-FLOAT function, , @t{as-double-float}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-PLIST generic function, , @t{as-plist}} (generic function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-PLIST COMMON-LISP∶∶T method, , @t{as-plist}} (method)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-SIMPLE-FIXNUM-VECTOR function, , @t{as-simple-fixnum-vector}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶BIC function, , @t{bic}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶BINARY-SEARCH function, , @t{binary-search}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶CHECK-TYPES macro, , @t{check-types}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶CURRY* macro, , @t{curry*}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶DEFINE-WITH-MULTIPLE-BINDINGS macro, , @t{define-with-multiple-bindings}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶EXPANDING macro, , @t{expanding}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶FIXNUM? function, , @t{fixnum?}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶GENERATE-SEQUENCE function, , @t{generate-sequence}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶GETHASH* macro, , @t{gethash*}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶MAKE-VECTOR compiler macro, , @t{make-vector}} (compiler macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶MAKE-VECTOR function, , @t{make-vector}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SEQUENCEP function, , @t{sequencep}} (function)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-DOUBLE-FLOAT-VECTOR type, , @t{simple-double-float-vector}} (type)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-FIXNUM-VECTOR type, , @t{simple-fixnum-vector}} (type)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-SINGLE-FLOAT-VECTOR type, , @t{simple-single-float-vector}} (type)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SPLICE-AWHEN macro, , @t{splice-awhen}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶SPLICE-WHEN macro, , @t{splice-when}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶UNLESSF macro, , @t{unlessf}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶WITH-DOUBLE-FLOATS macro, , @t{with-double-floats}} (macro)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶WITHIN? function, , @t{within?}} (function)
@end itemize
@end table


@c --------------------------------
@c The num-utils.arithmetic package
@c --------------------------------
@node The num-utils․arithmetic package, The num-utils․matrix-shorthand package, The num-utils․utilities package, Packages
@section @t{num-utils.arithmetic}
@anchor{go to the NUM-UTILS․ARITHMETIC package}@c
@packageindex{num-utils.arithmetic}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@t{anaphora}
@item
@t{alexandria-2}
@item
@t{common-lisp}
@end itemize
@item Used By List
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶1C function, , @t{1c}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶ABS-DIFF function, , @t{abs-diff}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶ABSOLUTE-SQUARE function, , @t{absolute-square}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶AS-INTEGER function, , @t{as-integer}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶CEILING* function, , @t{ceiling*}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶CUMULATIVE-PRODUCT function, , @t{cumulative-product}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶CUMULATIVE-SUM function, , @t{cumulative-sum}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶DIVIDES? function, , @t{divides?}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶FLOOR* function, , @t{floor*}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶IVEC function, , @t{ivec}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM function, , @t{l2norm}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM-SQUARE generic function, , @t{l2norm-square}} (generic function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM-SQUARE COMMON-LISP∶∶SEQUENCE method, , @t{l2norm-square}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶LOG10 function, , @t{log10}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶LOG2 function, , @t{log2}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶MULTF macro, , @t{multf}} (macro)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶NORMALIZE-PROBABILITIES function, , @t{normalize-probabilities}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶NUMSEQ function, , @t{numseq}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT generic function, , @t{product}} (generic function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT COMMON-LISP∶∶SEQUENCE method, , @t{product}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT COMMON-LISP∶∶ARRAY method, , @t{product}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶ROUND* function, , @t{round*}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SAME-SIGN-P function, , @t{same-sign-p}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SEQUENCE-MAXIMUM function, , @t{sequence-maximum}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SEQUENCE-MINIMUM function, , @t{sequence-minimum}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SQUARE function, , @t{square}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SUM generic function, , @t{sum}} (generic function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SUM COMMON-LISP∶∶SEQUENCE method, , @t{sum}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SUM COMMON-LISP∶∶ARRAY method, , @t{sum}} (method)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶TRUNCATE* function, , @t{truncate*}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶DEFINE-ROUNDING-WITH-OFFSET macro, , @t{define-rounding-with-offset}} (macro)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SIMILAR-ELEMENT-TYPE function, , @t{similar-element-type}} (function)
@item
@ref{go to the NUM-UTILS․ARITHMETIC∶∶SIMILAR-SEQUENCE-TYPE function, , @t{similar-sequence-type}} (function)
@end itemize
@end table


@c --------------------------------------
@c The num-utils.matrix-shorthand package
@c --------------------------------------
@node The num-utils․matrix-shorthand package, The num-utils․num= package, The num-utils․arithmetic package, Packages
@section @t{num-utils.matrix-shorthand}
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND package}@c
@packageindex{num-utils.matrix-shorthand}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Nickname
@t{nu.mx}
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶DIAGONAL-MX function, , @t{diagonal-mx}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶HERMITIAN-MX macro, , @t{hermitian-mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶LOWER-TRIANGULAR-MX macro, , @t{lower-triangular-mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶MX macro, , @t{mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶UPPER-TRIANGULAR-MX macro, , @t{upper-triangular-mx}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶VEC function, , @t{vec}} (function)
@end itemize
@item Internal Definitions
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶PAD-LEFT-EXPANSION function, , @t{pad-left-expansion}} (function)
@end table


@c --------------------------
@c The num-utils.num= package
@c --------------------------
@node The num-utils․num= package, The num-utils․test-utilities package, The num-utils․matrix-shorthand package, Packages
@section @t{num-utils.num=}
@anchor{go to the NUM-UTILS․NUM= package}@c
@packageindex{num-utils.num=}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Used By List
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․NUM=∶∶*NUM=-TOLERANCE* special variable, , @t{*num=-tolerance*}} (special variable)
@item
@ref{go to the NUM-UTILS․NUM=∶∶DEFINE-NUM=-WITH-ACCESSORS macro, , @t{define-num=-with-accessors}} (macro)
@item
@ref{go to the NUM-UTILS․NUM=∶∶DEFINE-STRUCTURE-NUM= macro, , @t{define-structure-num=}} (macro)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM-DELTA function, , @t{num-delta}} (function)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= generic function, , @t{num=}} (generic function)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶REAL-LINE NUM-UTILS․INTERVAL∶∶REAL-LINE method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶CONS COMMON-LISP∶∶CONS method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶NULL COMMON-LISP∶∶NULL method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM=-FUNCTION function, , @t{num=-function}} (function)
@end itemize
@end table


@c ------------------------------------
@c The num-utils.test-utilities package
@c ------------------------------------
@node The num-utils․test-utilities package, The num-utils․extended-real package, The num-utils․num= package, Packages
@section @t{num-utils.test-utilities}
@anchor{go to the NUM-UTILS․TEST-UTILITIES package}@c
@packageindex{num-utils.test-utilities}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@t{common-lisp}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶COMPARE-FNS function, , @t{compare-fns}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶COMPARE-VECTORS function, , @t{compare-vectors}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MAX-ERROR function, , @t{max-error}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MAX-ERROR❩ function, , @t{(setf max-error)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MEAN-ERROR function, , @t{mean-error}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MEAN-ERROR❩ function, , @t{(setf mean-error)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MIN-ERROR function, , @t{min-error}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MIN-ERROR❩ function, , @t{(setf min-error)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶RMS function, , @t{rms}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF RMS❩ function, , @t{(setf rms)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-COUNT function, , @t{test-count}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF TEST-COUNT❩ function, , @t{(setf test-count)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-FN function, , @t{test-fn}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-RESULTS structure, , @t{test-results}} (structure)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE0 function, , @t{variance0}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE0❩ function, , @t{(setf variance0)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE1 function, , @t{variance1}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE1❩ function, , @t{(setf variance1)}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶WORST-CASE function, , @t{worst-case}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF WORST-CASE❩ function, , @t{(setf worst-case)}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶COPY-TEST-RESULTS function, , @t{copy-test-results}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MAKE-TEST-RESULTS function, , @t{make-test-results}} (function)
@item
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-RESULTS-P function, , @t{test-results-p}} (function)
@end itemize
@end table


@c -----------------------------------
@c The num-utils.extended-real package
@c -----------------------------------
@node The num-utils․extended-real package, The num-utils․quadrature package, The num-utils․test-utilities package, Packages
@section @t{num-utils.extended-real}
@anchor{go to the NUM-UTILS․EXTENDED-REAL package}@c
@packageindex{num-utils.extended-real}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Nickname
@t{xreal}
@item Use List
@itemize @bullet
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶< function, , @t{<}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶<= function, , @t{<=}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶= function, , @t{=}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶> function, , @t{>}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶>= function, , @t{>=}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶EXTENDED-REAL type, , @t{extended-real}} (type)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶INFINITE? function, , @t{infinite?}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶LAMBDA-TEMPLATE macro, , @t{lambda-template}} (macro)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶WITH-TEMPLATE macro, , @t{with-template}} (macro)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶DEFINE-COMPARISON macro, , @t{define-comparison}} (macro)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶EXTEND-PAIRWISE-COMPARISON function, , @t{extend-pairwise-comparison}} (function)
@item
@ref{go to the NUM-UTILS․EXTENDED-REAL∶∶INFINITE type, , @t{infinite}} (type)
@end itemize
@end table


@c --------------------------------
@c The num-utils.quadrature package
@c --------------------------------
@node The num-utils․quadrature package, The num-utils․statistics package, The num-utils․extended-real package, Packages
@section @t{num-utils.quadrature}
@anchor{go to the NUM-UTILS․QUADRATURE package}@c
@packageindex{num-utils.quadrature}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Exported Definitions
@ref{go to the NUM-UTILS․QUADRATURE∶∶ROMBERG-QUADRATURE function, , @t{romberg-quadrature}} (function)
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-ITERATIVE-QUADRATURE function, , @t{copy-iterative-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-MIDPOINT-QUADRATURE function, , @t{copy-midpoint-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-RICHARDSON-EXTRAPOLATION function, , @t{copy-richardson-extrapolation}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶COPY-TRAPEZOIDAL-QUADRATURE function, , @t{copy-trapezoidal-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE structure, , @t{iterative-quadrature}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-A function, , @t{iterative-quadrature-a}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-A❩ function, , @t{(setf iterative-quadrature-a)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-B function, , @t{iterative-quadrature-b}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-B❩ function, , @t{(setf iterative-quadrature-b)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-F function, , @t{iterative-quadrature-f}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-F❩ function, , @t{(setf iterative-quadrature-f)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-H function, , @t{iterative-quadrature-h}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-H❩ function, , @t{(setf iterative-quadrature-h)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-N function, , @t{iterative-quadrature-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-N❩ function, , @t{(setf iterative-quadrature-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-P function, , @t{iterative-quadrature-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-SUM function, , @t{iterative-quadrature-sum}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-SUM❩ function, , @t{(setf iterative-quadrature-sum)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MAKE-ITERATIVE-QUADRATURE function, , @t{make-iterative-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE function, , @t{midpoint-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE structure, , @t{midpoint-quadrature}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE% function, , @t{midpoint-quadrature%}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-A function, , @t{midpoint-quadrature-a}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-A❩ function, , @t{(setf midpoint-quadrature-a)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-B function, , @t{midpoint-quadrature-b}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-B❩ function, , @t{(setf midpoint-quadrature-b)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-F function, , @t{midpoint-quadrature-f}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-F❩ function, , @t{(setf midpoint-quadrature-f)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-H function, , @t{midpoint-quadrature-h}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-H❩ function, , @t{(setf midpoint-quadrature-h)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-N function, , @t{midpoint-quadrature-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-N❩ function, , @t{(setf midpoint-quadrature-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-P function, , @t{midpoint-quadrature-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-SUM function, , @t{midpoint-quadrature-sum}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-SUM❩ function, , @t{(setf midpoint-quadrature-sum)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE generic function, , @t{refine-quadrature}} (generic function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method, , @t{refine-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method, , @t{refine-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT generic function, , @t{richardson-coefficient}} (generic function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method, , @t{richardson-coefficient}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method, , @t{richardson-coefficient}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION function, , @t{richardson-extrapolation}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION structure, , @t{richardson-extrapolation}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-COEFFICIENT function, , @t{richardson-extrapolation-coefficient}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-COEFFICIENT❩ function, , @t{(setf richardson-extrapolation-coefficient)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-DIAGONAL function, , @t{richardson-extrapolation-diagonal}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-DIAGONAL❩ function, , @t{(setf richardson-extrapolation-diagonal)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-N function, , @t{richardson-extrapolation-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-N❩ function, , @t{(setf richardson-extrapolation-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-P function, , @t{richardson-extrapolation-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-ITERATION function, , @t{richardson-iteration}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶ROMBERG-QUADRATURE% function, , @t{romberg-quadrature%}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE generic function, , @t{transformed-quadrature}} (generic function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶NULL method, , @t{transformed-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶NULL method, , @t{transformed-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE function, , @t{trapezoidal-quadrature}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE structure, , @t{trapezoidal-quadrature}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE% function, , @t{trapezoidal-quadrature%}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-A function, , @t{trapezoidal-quadrature-a}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-A❩ function, , @t{(setf trapezoidal-quadrature-a)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-B function, , @t{trapezoidal-quadrature-b}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-B❩ function, , @t{(setf trapezoidal-quadrature-b)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-F function, , @t{trapezoidal-quadrature-f}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-F❩ function, , @t{(setf trapezoidal-quadrature-f)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-H function, , @t{trapezoidal-quadrature-h}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-H❩ function, , @t{(setf trapezoidal-quadrature-h)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-N function, , @t{trapezoidal-quadrature-n}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-N❩ function, , @t{(setf trapezoidal-quadrature-n)}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-P function, , @t{trapezoidal-quadrature-p}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-SUM function, , @t{trapezoidal-quadrature-sum}} (function)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-SUM❩ function, , @t{(setf trapezoidal-quadrature-sum)}} (function)
@end itemize
@end table


@c --------------------------------
@c The num-utils.statistics package
@c --------------------------------
@node The num-utils․statistics package, The num-utils․rootfinding package, The num-utils․quadrature package, Packages
@section @t{num-utils.statistics}
@anchor{go to the NUM-UTILS․STATISTICS package}@c
@packageindex{num-utils.statistics}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Nickname
@t{nu.stats}
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item
@t{alexandria}
@item
@t{anaphora}
@item
@t{common-lisp}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶*CENTRAL-SAMPLE-MOMENTS-DEFAULT-DEGREE* special variable, , @t{*central-sample-moments-default-degree*}} (special variable)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD generic function, , @t{add}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER COMMON-LISP∶∶T method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶REAL method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD COMMON-LISP∶∶T COMMON-LISP∶∶NULL method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 generic function, , @t{central-m2}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 COMMON-LISP∶∶T method, , @t{central-m2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 generic function, , @t{central-m3}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 COMMON-LISP∶∶T method, , @t{central-m3}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m3}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 generic function, , @t{central-m4}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 COMMON-LISP∶∶T method, , @t{central-m4}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m4}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS generic function, , @t{central-sample-moments}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶NULL method, , @t{central-sample-moments}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-sample-moments}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶SEQUENCE method, , @t{central-sample-moments}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS structure, , @t{central-sample-moments}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-DEGREE function, , @t{central-sample-moments-degree}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CROSS-TABULATE function, , @t{cross-tabulate}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶EMPIRICAL-QUANTILE function, , @t{empirical-quantile}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶EMPIRICAL-QUANTILE-PROBABILITIES function, , @t{empirical-quantile-probabilities}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶EMPTY-ACCUMULATOR condition, , @t{empty-accumulator}} (condition)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS generic function, , @t{ensure-sorted-reals}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS NUM-UTILS․STATISTICS∶∶SORTED-REALS method, , @t{ensure-sorted-reals}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS COMMON-LISP∶∶ARRAY method, , @t{ensure-sorted-reals}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS COMMON-LISP∶∶LIST method, , @t{ensure-sorted-reals}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-VECTOR function, , @t{ensure-sorted-vector}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶INFORMATION-NOT-COLLECTED-IN-ACCUMULATOR condition, , @t{information-not-collected-in-accumulator}} (condition)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS generic function, , @t{kurtosis}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS COMMON-LISP∶∶T method, , @t{kurtosis}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{kurtosis}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-SPARSE-COUNTER function, , @t{make-sparse-counter}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEAN generic function, , @t{mean}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEAN COMMON-LISP∶∶T method, , @t{mean}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEAN NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{mean}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEDIAN generic function, , @t{median}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEDIAN COMMON-LISP∶∶SEQUENCE method, , @t{median}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEDIAN COMMON-LISP∶∶T method, , @t{median}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶NOT-ENOUGH-ELEMENTS-IN-ACCUMULATOR condition, , @t{not-enough-elements-in-accumulator}} (condition)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶POOL function, , @t{pool}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILE generic function, , @t{quantile}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILE COMMON-LISP∶∶SEQUENCE COMMON-LISP∶∶T method, , @t{quantile}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILE COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{quantile}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILES generic function, , @t{quantiles}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILES COMMON-LISP∶∶SEQUENCE COMMON-LISP∶∶T method, , @t{quantiles}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILES NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method, , @t{quantiles}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SD generic function, , @t{sd}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SD COMMON-LISP∶∶T method, , @t{sd}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS generic function, , @t{skewness}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS COMMON-LISP∶∶T method, , @t{skewness}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{skewness}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS structure, , @t{sorted-reals}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-ELEMENTS function, , @t{sorted-reals-elements}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER structure, , @t{sparse-counter}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-COUNT function, , @t{sparse-counter-count}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-TABLE function, , @t{sparse-counter-table}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TABULATE function, , @t{tabulate}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY generic function, , @t{tally}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method, , @t{tally}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶TALLY-MIXIN method, , @t{tally}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶VARIANCE generic function, , @t{variance}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶VARIANCE COMMON-LISP∶∶T method, , @t{variance}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶VARIANCE NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{variance}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-QUANTILES function, , @t{weighted-quantiles}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶⅋SORTED-REALS macro, , @t{@ampchar{}sorted-reals}} (macro)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶⅋SORTED-REALS-R/O macro, , @t{@ampchar{}sorted-reals-r/o}} (macro)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-M function, , @t{central-sample-moments-m}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-M❩ function, , @t{(setf central-sample-moments-m)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-P function, , @t{central-sample-moments-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S2 function, , @t{central-sample-moments-s2}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S2❩ function, , @t{(setf central-sample-moments-s2)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S3 function, , @t{central-sample-moments-s3}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S3❩ function, , @t{(setf central-sample-moments-s3)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S4 function, , @t{central-sample-moments-s4}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S4❩ function, , @t{(setf central-sample-moments-s4)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-W function, , @t{central-sample-moments-w}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-W❩ function, , @t{(setf central-sample-moments-w)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-CENTRAL-SAMPLE-MOMENTS function, , @t{copy-central-sample-moments}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-SORTED-REALS function, , @t{copy-sorted-reals}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-SPARSE-COUNTER function, , @t{copy-sparse-counter}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶COPY-TALLY-MIXIN function, , @t{copy-tally-mixin}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶DEFINE-CENTRAL-SAMPLE-MOMENT macro, , @t{define-central-sample-moment}} (macro)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-CENTRAL-SAMPLE-MOMENTS function, , @t{make-central-sample-moments}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-SORTED-REALS function, , @t{make-sorted-reals}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-SPARSE-COUNTER% function, , @t{make-sparse-counter%}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MAKE-TALLY-MIXIN function, , @t{make-tally-mixin}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶POOL2 generic function, , @t{pool2}} (generic function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶POOL2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{pool2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORT-REALS function, , @t{sort-reals}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-ORDERED-ELEMENTS function, , @t{sorted-reals-ordered-elements}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-ORDERED-ELEMENTS❩ function, , @t{(setf sorted-reals-ordered-elements)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-P function, , @t{sorted-reals-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-UNORDERED-ELEMENTS function, , @t{sorted-reals-unordered-elements}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-UNORDERED-ELEMENTS❩ function, , @t{(setf sorted-reals-unordered-elements)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-P function, , @t{sparse-counter-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN structure, , @t{tally-mixin}} (structure)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN-P function, , @t{tally-mixin-p}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN-W function, , @t{tally-mixin-w}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF TALLY-MIXIN-W❩ function, , @t{(setf tally-mixin-w)}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-EMPIRICAL-QUANTILE function, , @t{weighted-empirical-quantile}} (function)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-QUANTILE-P-TABLE function, , @t{weighted-quantile-p-table}} (function)
@end itemize
@end table


@c ---------------------------------
@c The num-utils.rootfinding package
@c ---------------------------------
@node The num-utils․rootfinding package, The num-utils․elementwise package, The num-utils․statistics package, Packages
@section @t{num-utils.rootfinding}
@anchor{go to the NUM-UTILS․ROOTFINDING package}@c
@packageindex{num-utils.rootfinding}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶*ROOTFINDING-DELTA-RELATIVE* special variable, , @t{*rootfinding-delta-relative*}} (special variable)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶*ROOTFINDING-EPSILON* special variable, , @t{*rootfinding-epsilon*}} (special variable)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶ROOT-BISECTION function, , @t{root-bisection}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶NARROW-BRACKET? function, , @t{narrow-bracket?}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶NEAR-ROOT? function, , @t{near-root?}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶OPPOSITE-SIGN? function, , @t{opposite-sign?}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶ROOTFINDING-DELTA function, , @t{rootfinding-delta}} (function)
@item
@ref{go to the NUM-UTILS․ROOTFINDING∶∶UNIVARIATE-ROOTFINDER-LOOP% macro, , @t{univariate-rootfinder-loop%}} (macro)
@end itemize
@end table


@c ---------------------------------
@c The num-utils.elementwise package
@c ---------------------------------
@node The num-utils․elementwise package, The num-utils․chebyshev package, The num-utils․rootfinding package, Packages
@section @t{num-utils.elementwise}
@anchor{go to the NUM-UTILS․ELEMENTWISE package}@c
@packageindex{num-utils.elementwise}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Nickname
@t{elmt}
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Used By List
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E* function, , @t{e*}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E+ function, , @t{e+}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E- function, , @t{e-}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E/ function, , @t{e/}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- generic function, , @t{e1-}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- COMMON-LISP∶∶NUMBER method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- COMMON-LISP∶∶ARRAY method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ generic function, , @t{e1/}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ COMMON-LISP∶∶NUMBER method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ COMMON-LISP∶∶ARRAY method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG generic function, , @t{e1log}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG COMMON-LISP∶∶NUMBER method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG COMMON-LISP∶∶ARRAY method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* generic function, , @t{e2*}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ generic function, , @t{e2+}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- generic function, , @t{e2-}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ generic function, , @t{e2/}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG generic function, , @t{e2log}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{e2log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING generic function, , @t{eceiling}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING COMMON-LISP∶∶NUMBER method, , @t{eceiling}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING COMMON-LISP∶∶ARRAY method, , @t{eceiling}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE generic function, , @t{econjugate}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE COMMON-LISP∶∶NUMBER method, , @t{econjugate}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE COMMON-LISP∶∶ARRAY method, , @t{econjugate}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP generic function, , @t{eexp}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP COMMON-LISP∶∶NUMBER method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP COMMON-LISP∶∶ARRAY method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT generic function, , @t{eexpt}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method, , @t{eexpt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR generic function, , @t{efloor}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR COMMON-LISP∶∶NUMBER method, , @t{efloor}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR COMMON-LISP∶∶ARRAY method, , @t{efloor}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ELEMENTWISE-FLOAT-CONTAGION function, , @t{elementwise-float-contagion}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ELOG function, , @t{elog}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EMAX function, , @t{emax}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EMIN function, , @t{emin}} (function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE generic function, , @t{ereduce}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶ARRAY method, , @t{ereduce}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶SEQUENCE method, , @t{ereduce}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{ereduce}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT generic function, , @t{esqrt}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT COMMON-LISP∶∶NUMBER method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT COMMON-LISP∶∶ARRAY method, , @t{esqrt}} (method)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E⅋ macro, , @t{define-e@ampchar{}}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E1 macro, , @t{define-e1}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E2 macro, , @t{define-e2}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-ELEMENTWISE-REDUCTION macro, , @t{define-elementwise-reduction}} (macro)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE generic function, , @t{esquare}} (generic function)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE COMMON-LISP∶∶NUMBER method, , @t{esquare}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE COMMON-LISP∶∶ARRAY method, , @t{esquare}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶MAPPING-ARRAY macro, , @t{mapping-array}} (macro)
@end itemize
@end table


@c -------------------------------
@c The num-utils.chebyshev package
@c -------------------------------
@node The num-utils․chebyshev package, The num-utils․matrix package, The num-utils․elementwise package, Packages
@section @t{num-utils.chebyshev}
@anchor{go to the NUM-UTILS․CHEBYSHEV package}@c
@packageindex{num-utils.chebyshev}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE function, , @t{chebyshev-approximate}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-REGRESSION function, , @t{chebyshev-regression}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-ROOT function, , @t{chebyshev-root}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-ROOTS function, , @t{chebyshev-roots}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶EVALUATE-CHEBYSHEV function, , @t{evaluate-chebyshev}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶AB-TO-CD-INTERCEPT-SLOPE function, , @t{ab-to-cd-intercept-slope}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶AB-TO-CINF function, , @t{ab-to-cinf}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION generic function, , @t{chebyshev-approximate-implementation}} (generic function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{chebyshev-approximate-implementation}} (method)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{chebyshev-approximate-implementation}} (method)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-RECURSION function, , @t{chebyshev-recursion}} (function)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CINF-TO-AB function, , @t{cinf-to-ab}} (function)
@end itemize
@end table


@c ----------------------------
@c The num-utils.matrix package
@c ----------------------------
@node The num-utils․matrix package, The num-utils package, The num-utils․chebyshev package, Packages
@section @t{num-utils.matrix}
@anchor{go to the NUM-UTILS․MATRIX package}@c
@packageindex{num-utils.matrix}@c
@table @strong
@item Source
@ref{go to the num-utils/packages․lisp file, , @t{packages.lisp}} (file)
@item Use List
@itemize @bullet
@item
@t{let-plus}
@item
@t{select}
@item
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item
@ref{go to the NUM-UTILS․PRINT-MATRIX package, , @t{num-utils.print-matrix}}
@item
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item
@t{anaphora}
@item
@t{alexandria}
@item
@t{common-lisp}
@end itemize
@item Used By List
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Exported Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX function, , @t{diagonal-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX structure, , @t{diagonal-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX-ELEMENTS function, , @t{diagonal-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-MATRIX-ELEMENTS❩ function, , @t{(setf diagonal-matrix-elements)}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR generic function, , @t{diagonal-vector}} (generic function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR COMMON-LISP∶∶ARRAY method, , @t{diagonal-vector}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR COMMON-LISP∶∶T method, , @t{diagonal-vector}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-VECTOR❩ generic function, , @t{(setf diagonal-vector)}} (generic function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX function, , @t{hermitian-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX structure, , @t{hermitian-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX function, , @t{lower-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX structure, , @t{lower-triangular-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE generic function, , @t{transpose}} (generic function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE COMMON-LISP∶∶ARRAY method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRIANGULAR-MATRIX type, , @t{triangular-matrix}} (type)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX function, , @t{upper-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX structure, , @t{upper-triangular-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX structure, , @t{wrapped-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX-ELEMENTS function, , @t{wrapped-matrix-elements}} (function)
@end itemize
@item Internal Definitions
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶⅋DIAGONAL-MATRIX macro, , @t{@ampchar{}diagonal-matrix}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶⅋DIAGONAL-MATRIX-R/O macro, , @t{@ampchar{}diagonal-matrix-r/o}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶ABOVE-DIAGONAL? function, , @t{above-diagonal?}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶BELOW-DIAGONAL? function, , @t{below-diagonal?}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-DIAGONAL-MATRIX function, , @t{copy-diagonal-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-HERMITIAN-MATRIX function, , @t{copy-hermitian-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-LOWER-TRIANGULAR-MATRIX function, , @t{copy-lower-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-UPPER-TRIANGULAR-MATRIX function, , @t{copy-upper-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶COPY-WRAPPED-MATRIX function, , @t{copy-wrapped-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-AS-ARRAY macro, , @t{define-elementwise-as-array}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-SAME-CLASS macro, , @t{define-elementwise-same-class}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-UNIVARIATE macro, , @t{define-elementwise-univariate}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-WITH-CONSTANT macro, , @t{define-elementwise-with-constant}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DEFINE-WRAPPED-MATRIX macro, , @t{define-wrapped-matrix}} (macro)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX-P function, , @t{diagonal-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶ENSURE-VALID-ELEMENTS function, , @t{ensure-valid-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX-ELEMENTS function, , @t{hermitian-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX-P function, , @t{hermitian-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX-ELEMENTS function, , @t{lower-triangular-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX-P function, , @t{lower-triangular-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-DIAGONAL-MATRIX function, , @t{make-diagonal-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-HERMITIAN-MATRIX function, , @t{make-hermitian-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-LOWER-TRIANGULAR-MATRIX function, , @t{make-lower-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-UPPER-TRIANGULAR-MATRIX function, , @t{make-upper-triangular-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶MAKE-WRAPPED-MATRIX function, , @t{make-wrapped-matrix}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX-ELEMENTS function, , @t{upper-triangular-matrix-elements}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX-P function, , @t{upper-triangular-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶VALID-SPARSE-TYPE? function, , @t{valid-sparse-type?}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX-P function, , @t{wrapped-matrix-p}} (function)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶ZERO-LIKE function, , @t{zero-like}} (function)
@end itemize
@end table


@c ---------------------
@c The num-utils package
@c ---------------------
@node The num-utils package, , The num-utils․matrix package, Packages
@section @t{num-utils}
@anchor{go to the NUM-UTILS package}@c
@packageindex{num-utils}@c
@table @strong
@item Source
@ref{go to the num-utils/common-package․lisp file, , @t{common-package.lisp}} (file)
@item Nickname
@t{nu}
@item Use List
@t{common-lisp}
@end table



@c ====================================================================
@c Definitions
@c ====================================================================
@node Definitions, Indexes, Packages, Top
@chapter Definitions
Definitions are sorted by export status, category, package, and then by
lexicographic order.

@menu
* Exported definitions::
* Internal definitions::
@end menu


@c --------------------
@c Exported definitions
@c --------------------
@node Exported definitions, Internal definitions, Definitions, Definitions
@section Exported definitions
@menu
* Exported special variables::
* Exported macros::
* Exported compiler macros::
* Exported functions::
* Exported generic functions::
* Exported conditions::
* Exported structures::
* Exported classes::
* Exported types::
@end menu

@node Exported special variables, Exported macros, Exported definitions, Exported definitions
@subsection Special variables
@defvr {Special Variable} *central-sample-moments-default-degree*
@anchor{go to the NUM-UTILS․STATISTICS∶∶*CENTRAL-SAMPLE-MOMENTS-DEFAULT-DEGREE* special variable}@c
@specialsubindex{*central-sample-moments-default-degree*}@c
Default degree for (weighted) central sample moments.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *num=-tolerance*
@anchor{go to the NUM-UTILS․NUM=∶∶*NUM=-TOLERANCE* special variable}@c
@specialsubindex{*num=-tolerance*}@c
Default tolerance for NUM=.
@table @strong
@item Package
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item Source
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *print-matrix-precision*
@anchor{go to the NUM-UTILS․PRINT-MATRIX∶∶*PRINT-MATRIX-PRECISION* special variable}@c
@specialsubindex{*print-matrix-precision*}@c
Number of digits after the decimal point when printing numeric matrices.
@table @strong
@item Package
@ref{go to the NUM-UTILS․PRINT-MATRIX package, , @t{num-utils.print-matrix}}
@item Source
@ref{go to the num-utils/print-matrix․lisp file, , @t{print-matrix.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *rootfinding-delta-relative*
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶*ROOTFINDING-DELTA-RELATIVE* special variable}@c
@specialsubindex{*rootfinding-delta-relative*}@c
Default relative interval width for rootfinding.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *rootfinding-epsilon*
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶*ROOTFINDING-EPSILON* special variable}@c
@specialsubindex{*rootfinding-epsilon*}@c
Default maximum for the absolute value of the function@comma{} used for rootfinding.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end defvr

@node Exported macros, Exported compiler macros, Exported special variables, Exported definitions
@subsection Macros
@deffn {Macro} {@ampchar{}interval} LEFT RIGHT
@anchor{go to the NUM-UTILS․INTERVAL∶∶⅋INTERVAL macro}@c
@macrosubindex{@ampchar{}interval}@c
LET+ expansion for interval endpoints.  If given a list of two values@comma{}
the second value is an indicator for whether the endpoint is open.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {check-types} (&rest ARGUMENTS) TYPE
@anchor{go to the NUM-UTILS․UTILITIES∶∶CHECK-TYPES macro}@c
@macrosubindex{check-types}@c
CHECK-TYPE for multiple places of the same type.  Each argument is either a place@comma{} or a list of a place and a type-string.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {curry*} FUNCTION &rest ARGUMENTS
@anchor{go to the NUM-UTILS․UTILITIES∶∶CURRY* macro}@c
@macrosubindex{curry*}@c
Currying in all variables that are not *.  Note that this is a macro@comma{} so * should not be quoted@comma{} and FUNCTION will be used as is@comma{} ie it can be a LAMBDA form.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-num=-with-accessors} CLASS ACCESSORS
@anchor{go to the NUM-UTILS․NUM=∶∶DEFINE-NUM=-WITH-ACCESSORS macro}@c
@macrosubindex{define-num=-with-accessors}@c
Define a method for NUM=@comma{} specialized to the given class@comma{} comparing values obtained with accessors.
@table @strong
@item Package
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item Source
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-structure-num=} STRUCTURE &rest SLOTS
@anchor{go to the NUM-UTILS․NUM=∶∶DEFINE-STRUCTURE-NUM= macro}@c
@macrosubindex{define-structure-num=}@c
Define a NUM= method for the given structure@comma{} comparing the given slots.
@table @strong
@item Package
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item Source
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-with-multiple-bindings} MACRO &key PLURAL DOCSTRING
@anchor{go to the NUM-UTILS․UTILITIES∶∶DEFINE-WITH-MULTIPLE-BINDINGS macro}@c
@macrosubindex{define-with-multiple-bindings}@c
Define a version of MACRO with multiple arguments@comma{} given as a list.  Application of MACRO will be nested.  The new name is the plural of the old one (generated using format by default).
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {expanding} &body BODY
@anchor{go to the NUM-UTILS․UTILITIES∶∶EXPANDING macro}@c
@macrosubindex{expanding}@c
Expand BODY. Useful for generating code programmatically.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {extendf-interval} PLACE OBJECT
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTENDF-INTERVAL macro}@c
@macrosubindex{extendf-interval}@c
Apply EXTEND-INTERVAL on PLACE using OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {gethash*} KEY HASH-TABLE &optional DATUM &rest ARGUMENTS
@anchor{go to the NUM-UTILS․UTILITIES∶∶GETHASH* macro}@c
@macrosubindex{gethash*}@c
Like GETHASH@comma{} but checking that KEY is present and raising the given error if not.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {hermitian-mx} ELEMENT-TYPE &body ROWS
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶HERMITIAN-MX macro}@c
@macrosubindex{hermitian-mx}@c
Macro for creating a lower triangular matrix.  ROWS should be a list of lists@comma{} elements are evaluated.  Masked elements (above the diagonal) are ignored at the expansion@comma{} rows which don't have enough elements are padded with zeros.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Source
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {lambda-template} (PREFIX &rest VARIABLES) &body BODY
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶LAMBDA-TEMPLATE macro}@c
@macrosubindex{lambda-template}@c
LAMBDA with WITH-TEMPLATE in its BODY.
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {lower-triangular-mx} ELEMENT-TYPE &body ROWS
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶LOWER-TRIANGULAR-MX macro}@c
@macrosubindex{lower-triangular-mx}@c
Macro for creating a lower triangular matrix.  ROWS should be a list of lists@comma{} elements are evaluated.  Masked elements (above the diagonal) are ignored at the expansion@comma{} rows which don't have enough elements are padded with zeros.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Source
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {multf} PLACE COEFFICIENT
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶MULTF macro}@c
@macrosubindex{multf}@c
Multiply place by COEFFICIENT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {mx} ELEMENT-TYPE &body ROWS
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶MX macro}@c
@macrosubindex{mx}@c
Macro for creating a (dense) matrix (ie a rank 2 array).  ROWS should be a list of lists (or atoms@comma{} which are treated as lists)@comma{} elements are evaluated.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Source
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {splice-awhen} TEST &body FORMS
@anchor{go to the NUM-UTILS․UTILITIES∶∶SPLICE-AWHEN macro}@c
@macrosubindex{splice-awhen}@c
Similar to splice-when@comma{} but binds IT to test.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {splice-when} TEST &body FORMS
@anchor{go to the NUM-UTILS․UTILITIES∶∶SPLICE-WHEN macro}@c
@macrosubindex{splice-when}@c
Similar to when@comma{} but wraps the result in list.

Example: `(@comma{}foo @comma{}@atchar{}(splice-when add-bar? bar))
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {unlessf} PLACE VALUE-FORM
@anchor{go to the NUM-UTILS․UTILITIES∶∶UNLESSF macro}@c
@macrosubindex{unlessf}@c
When PLACE is NIL@comma{} evaluate VALUE-FORM and save it there.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {upper-triangular-mx} ELEMENT-TYPE &body ROWS
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶UPPER-TRIANGULAR-MX macro}@c
@macrosubindex{upper-triangular-mx}@c
Macro for creating an upper triangular matrix.  ROWS should be a list of lists@comma{} elements are evaluated.  Masked elements (below the diagonal) are ignored at the expansion.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Source
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-double-floats} BINDINGS &body BODY
@anchor{go to the NUM-UTILS․UTILITIES∶∶WITH-DOUBLE-FLOATS macro}@c
@macrosubindex{with-double-floats}@c
For each binding = (variable value)@comma{} coerce VALUE to DOUBLE-FLOAT and bind it to VARIABLE for BODY.  When VALUE is omitted@comma{} VARIABLE is used instead.  When BINDING is an atom@comma{} it is used for both the value and the variable.

Example:@*
  (with-double-floats (a@*
                       (b)@*
                       (c 1))@*
    ...)
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-template} (PREFIX &rest VARIABLES) &body BODY
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶WITH-TEMPLATE macro}@c
@macrosubindex{with-template}@c
Define the function (PREFIX @ampchar{}rest VARIABLES) which can be used to match variables using :PLUSINF@comma{} :MINUSINF@comma{} REAL@comma{} or T.
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn

@node Exported compiler macros, Exported functions, Exported macros, Exported definitions
@subsection Compiler macros
@deffn {Compiler Macro} {make-vector} ELEMENT-TYPE &rest INITIAL-CONTENTS
@anchor{go to the NUM-UTILS․UTILITIES∶∶MAKE-VECTOR compiler macro}@c
@compilermacrosubindex{make-vector}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn

@node Exported functions, Exported generic functions, Exported compiler macros, Exported definitions
@subsection Functions
@deffn {Function} {1c} NUMBER
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶1C function}@c
@functionsubindex{1c}@c
Return 1-number.  The mnemonic is "1 complement"@comma{} 1- is already a CL
library function.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {<} NUMBER &rest MORE-NUMBERS
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶< function}@c
@functionsubindex{<}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Function} {<=} NUMBER &rest MORE-NUMBERS
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶<= function}@c
@functionsubindex{<=}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Function} {=} NUMBER &rest MORE-NUMBERS
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶= function}@c
@functionsubindex{=}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Function} {>} NUMBER &rest MORE-NUMBERS
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶> function}@c
@functionsubindex{>}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Function} {>=} NUMBER &rest MORE-NUMBERS
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶>= function}@c
@functionsubindex{>=}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Function} {abs-diff} A B
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶ABS-DIFF function}@c
@functionsubindex{abs-diff}@c
Absolute difference of A and B.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {absolute-square} NUMBER
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶ABSOLUTE-SQUARE function}@c
@functionsubindex{absolute-square}@c
Number multiplied by its complex conjugate.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {as-double-float} V
@anchor{go to the NUM-UTILS․UTILITIES∶∶AS-DOUBLE-FLOAT function}@c
@functionsubindex{as-double-float}@c
Convert argument to DOUBLE-FLOAT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {as-integer} NUMBER
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶AS-INTEGER function}@c
@functionsubindex{as-integer}@c
If NUMBER represents an integer (as an integer@comma{} complex@comma{} or float@comma{} etc)@comma{} return it as an integer@comma{} otherwise signal an error.  Floats are converted with RATIONALIZE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {as-simple-fixnum-vector} SEQUENCE &optional COPY?
@anchor{go to the NUM-UTILS․UTILITIES∶∶AS-SIMPLE-FIXNUM-VECTOR function}@c
@functionsubindex{as-simple-fixnum-vector}@c
Convert SEQUENCE to a SIMPLE-FIXNUM-VECTOR.  When COPY?@comma{} make sure that the they don't share structure.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {bic} A B
@anchor{go to the NUM-UTILS․UTILITIES∶∶BIC function}@c
@functionsubindex{bic}@c
Biconditional.  Returns A <=> B.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {binary-search} SORTED-REALS VALUE
@anchor{go to the NUM-UTILS․UTILITIES∶∶BINARY-SEARCH function}@c
@functionsubindex{binary-search}@c
Return INDEX such that@*

  (WITHIN? (AREF SORTED-REALS INDEX) VALUE (AREF SORTED-REALS (1+ INDEX)).@*

SORTED-REALS is assumed to be reals sorted in ascending order (not checked@comma{} if this does not hold the result may be nonsensical@comma{} though the algorithm will terminate).

If value is below (or above) the first (last) break@comma{} NIL (T) is returned.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ceiling*} NUMBER &optional DIVISOR OFFSET
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶CEILING* function}@c
@functionsubindex{ceiling*}@c
Find the lowest A=I*DIVISOR+OFFSET >= NUMBER@comma{} return (values A (- A NUMBER).
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {central-sample-moments-degree} CENTRAL-SAMPLE-MOMENTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-DEGREE function}@c
@functionsubindex{central-sample-moments-degree}@c
Return the degree of CENTRAL-SAMPLE-MOMENTS.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {chebyshev-approximate} F INTERVAL N-POLYNOMIALS &key N-POINTS
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE function}@c
@functionsubindex{chebyshev-approximate}@c
Return a closure approximating F on the given INTERVAL (may be infinite on
either end) using the given number of Chebyshev polynomials.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {chebyshev-regression} F N-POLYNOMIALS &optional N-POINTS
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-REGRESSION function}@c
@functionsubindex{chebyshev-regression}@c
Chebyshev polynomial regression using the given number of polynomials and
points (zeroes of the corresponding Chebyshev polynomial).
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {chebyshev-root} M I
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-ROOT function}@c
@functionsubindex{chebyshev-root}@c
Return the iTH root of the Mth Chebyshev polynomial as double-float.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {chebyshev-roots} M
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-ROOTS function}@c
@functionsubindex{chebyshev-roots}@c
Return the roots of the Mth Chebyshev polynomial as a vector of
double-floats.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compare-fns} FN-1 FN-2 &rest FN-PARAMS
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶COMPARE-FNS function}@c
@functionsubindex{compare-fns}@c
Compare the values returned by two functions
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compare-vectors} REFERENCE-VALUES COMPUTED-VALUES
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶COMPARE-VECTORS function}@c
@functionsubindex{compare-vectors}@c
Compare two vectors containing the results of previous computations
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cross-tabulate} SEQUENCE1 SEQUENCE2 &key TEST
@anchor{go to the NUM-UTILS․STATISTICS∶∶CROSS-TABULATE function}@c
@functionsubindex{cross-tabulate}@c
Cross-tabulate two sequences (using a SPARSE-COUNTER with the given TEST).  TEST is used to compare conses.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cumulative-product} SEQUENCE &key RESULT-TYPE
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶CUMULATIVE-PRODUCT function}@c
@functionsubindex{cumulative-product}@c
Cumulative product of sequence.  Return a sequence of the same kind and length; last element is the total product.  The latter is also returned as the second value.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cumulative-sum} SEQUENCE &key RESULT-TYPE
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶CUMULATIVE-SUM function}@c
@functionsubindex{cumulative-sum}@c
Cumulative sum of sequence.  Return a sequence of the same kind and length; last element is the total.  The latter is returned as the second value.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {diagonal-matrix} ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX function}@c
@functionsubindex{diagonal-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {diagonal-matrix-elements} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX-ELEMENTS function}@c
@functionsubindex{diagonal-matrix-elements}@c
@deffnx {Function} {(setf diagonal-matrix-elements)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-MATRIX-ELEMENTS❩ function}@c
@functionsubindex{(setf diagonal-matrix-elements)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {diagonal-mx} ELEMENT-TYPE &rest ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶DIAGONAL-MX function}@c
@functionsubindex{diagonal-mx}@c
Return a DIAGONAL-MATRIX with elements coerced to ELEMENT-TYPE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Source
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@end table
@end deffn
@deffn {Function} {divides?} NUMBER DIVISOR
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶DIVIDES? function}@c
@functionsubindex{divides?}@c
Test if DIVISOR divides NUMBER without remainder@comma{} and if so@comma{} return the
  quotient.  Works generally@comma{} but makes most sense for rationals.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {e*} ARGUMENT &rest MORE-ARGUMENTS
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E* function}@c
@functionsubindex{e*}@c
Elementwise *.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {e+} ARGUMENT &rest MORE-ARGUMENTS
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E+ function}@c
@functionsubindex{e+}@c
Elementwise +.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {e-} ARGUMENT &rest MORE-ARGUMENTS
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E- function}@c
@functionsubindex{e-}@c
Elementwise -.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {e/} ARGUMENT &rest MORE-ARGUMENTS
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E/ function}@c
@functionsubindex{e/}@c
Elementwise /.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elementwise-float-contagion} &rest OBJECTS
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ELEMENTWISE-FLOAT-CONTAGION function}@c
@functionsubindex{elementwise-float-contagion}@c
Return the resulting float type when objects (or their elements) are combined using arithmetic operations.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elog} A &optional BASE
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ELOG function}@c
@functionsubindex{elog}@c
Elementwise logarithm.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {emax} OBJECT
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EMAX function}@c
@functionsubindex{emax}@c
Elementwise MAX.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {emin} OBJECT
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EMIN function}@c
@functionsubindex{emin}@c
Elementwise MIN.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empirical-quantile} SORTED-VECTOR Q
@anchor{go to the NUM-UTILS․STATISTICS∶∶EMPIRICAL-QUANTILE function}@c
@functionsubindex{empirical-quantile}@c
Return the empirical quantile of a vector of real numbers@comma{} sorted in ascending order (not checked).  Uses a 0.5 correction.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empirical-quantile-probabilities} N
@anchor{go to the NUM-UTILS․STATISTICS∶∶EMPIRICAL-QUANTILE-PROBABILITIES function}@c
@functionsubindex{empirical-quantile-probabilities}@c
Probabilities that correspond to the empirical quantiles of a vector of length N.  That is to say@comma{}

 (== (quantiles sample (empirical-quantile-probabilities (length sample)))@*
     sample)@*

for any vector SAMPLE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-sorted-vector} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-VECTOR function}@c
@functionsubindex{ensure-sorted-vector}@c
Return the elements of OBJECT as a vector (or reals) sorted in ascending order.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {evaluate-chebyshev} COEFFICIENTS X
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶EVALUATE-CHEBYSHEV function}@c
@functionsubindex{evaluate-chebyshev}@c
Return the sum of Chebyshev polynomials@comma{} weighted by COEFFICIENTS@comma{} at X.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {evaluate-polynomial} COEFFICIENTS X
@anchor{go to the NUM-UTILS․POLYNOMIAL∶∶EVALUATE-POLYNOMIAL function}@c
@functionsubindex{evaluate-polynomial}@c
Return the sum of polynomials@comma{} weighted by COEFFICIENTS@comma{} at X.
COFFICIENTS are ordered from the highest degree down to the constant term.
X must be of the same type as COEFFICIENTS.
@table @strong
@item Package
@ref{go to the NUM-UTILS․POLYNOMIAL package, , @t{num-utils.polynomial}}
@item Source
@ref{go to the num-utils/polynomial․lisp file, , @t{polynomial.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fixnum?} OBJECT
@anchor{go to the NUM-UTILS․UTILITIES∶∶FIXNUM? function}@c
@functionsubindex{fixnum?}@c
Check of type of OBJECT is fixnum.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {floor*} NUMBER &optional DIVISOR OFFSET
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶FLOOR* function}@c
@functionsubindex{floor*}@c
Find the highest A=I*DIVISOR+OFFSET <= NUMBER@comma{} return (values A (- A NUMBER).
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {generate-sequence} RESULT-TYPE SIZE FUNCTION
@anchor{go to the NUM-UTILS․UTILITIES∶∶GENERATE-SEQUENCE function}@c
@functionsubindex{generate-sequence}@c
Like MAKE-SEQUENCE@comma{} but using a function to fill the result.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {grid-in} INTERVAL SIZE &optional SEQUENCE-TYPE
@anchor{go to the NUM-UTILS․INTERVAL∶∶GRID-IN function}@c
@functionsubindex{grid-in}@c
Return an arithmetic sequence of the given size (length) between the
endpoints of the interval.  The endpoints of the sequence coincide with the
respective endpoint of the interval iff it is closed.  RESULT-TYPE determines
the result type (eg list)@comma{} if not given it is a simple-array (of rank 1)@comma{}
narrowing to the appropriate float type or fixnum if possible.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hermitian-matrix} ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX function}@c
@functionsubindex{hermitian-matrix}@c
Create a lower-triangular-matrix.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {in-interval?} INTERVAL NUMBER
@anchor{go to the NUM-UTILS․INTERVAL∶∶IN-INTERVAL? function}@c
@functionsubindex{in-interval?}@c
Test if NUMBER is in INTERVAL (which can be NIL@comma{} designating the empty
set).
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {infinite?} OBJECT
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶INFINITE? function}@c
@functionsubindex{infinite?}@c
Test if an object represents positive or negative infinity.
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interval} LEFT RIGHT &key OPEN-LEFT? OPEN-RIGHT?
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL function}@c
@functionsubindex{interval}@c
Create an INTERVAL.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interval-hull} OBJECT
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-HULL function}@c
@functionsubindex{interval-hull}@c
Return the smallest connected interval that contains (elements in) OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interval-length} INTERVAL
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-LENGTH function}@c
@functionsubindex{interval-length}@c
Difference between left and right.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interval-midpoint} INTERVAL &optional ALPHA
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL-MIDPOINT function}@c
@functionsubindex{interval-midpoint}@c
Convex combination of left and right@comma{} with alpha (defaults to 0.5)
weight on right.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec} END-OR-START &optional END BY STRICT-DIRECTION?
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶IVEC function}@c
@functionsubindex{ivec}@c
Return a vector of fixnums.@*

   (ivec end) =>  @hashchar{}(0 ... end-1) (or @hashchar{}(0 ... end+1) when end is negative).@*

   (ivec start end) => @hashchar{}(start ... end-1) or to end+1 when end is negative.@*

When BY is given it determines the increment@comma{} adjusted to match the direction unless STRICT-DIRECTION@comma{} in which case an error is signalled. 
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {l2norm} OBJECT
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM function}@c
@functionsubindex{l2norm}@c
$L_2$ norm of OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {log10} NUMBER
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶LOG10 function}@c
@functionsubindex{log10}@c
Abbreviation for decimal logarithm.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {log2} NUMBER
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶LOG2 function}@c
@functionsubindex{log2}@c
Abbreviation for binary logarithm.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lower-triangular-matrix} ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX function}@c
@functionsubindex{lower-triangular-matrix}@c
Create a lower-triangular-matrix.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sparse-counter} &key TEST
@anchor{go to the NUM-UTILS․STATISTICS∶∶MAKE-SPARSE-COUNTER function}@c
@functionsubindex{make-sparse-counter}@c
Create a sparse counter.  Elements are compared with TEST (should be accepted by HASH-TABLE).
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-vector} ELEMENT-TYPE &rest INITIAL-CONTENTS
@anchor{go to the NUM-UTILS․UTILITIES∶∶MAKE-VECTOR function}@c
@functionsubindex{make-vector}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {max-error} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶MAX-ERROR function}@c
@functionsubindex{max-error}@c
@deffnx {Function} {(setf max-error)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MAX-ERROR❩ function}@c
@functionsubindex{(setf max-error)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mean-error} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶MEAN-ERROR function}@c
@functionsubindex{mean-error}@c
@deffnx {Function} {(setf mean-error)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MEAN-ERROR❩ function}@c
@functionsubindex{(setf mean-error)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {min-error} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶MIN-ERROR function}@c
@functionsubindex{min-error}@c
@deffnx {Function} {(setf min-error)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MIN-ERROR❩ function}@c
@functionsubindex{(setf min-error)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {normalize-probabilities} VECTOR &key ELEMENT-TYPE RESULT
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶NORMALIZE-PROBABILITIES function}@c
@functionsubindex{normalize-probabilities}@c
Verify that each element of VECTOR is nonnegative and return a vector multiplied so that they sum to 1.  ELEMENT-TYPE can be used to specify the element-type of the result.  When RESULT is given@comma{} the result is placed there.  When RESULT is NIL@comma{} VECTOR is modified instead.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {num-delta} A B
@anchor{go to the NUM-UTILS․NUM=∶∶NUM-DELTA function}@c
@functionsubindex{num-delta}@c
|a-b|/max(1@comma{}|a|@comma{}|b|).  Useful for comparing numbers.
@table @strong
@item Package
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item Source
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@end table
@end deffn
@deffn {Function} {num=-function} TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM=-FUNCTION function}@c
@functionsubindex{num=-function}@c
Curried version of num=@comma{} with given tolerance.
@table @strong
@item Package
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item Source
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@end table
@end deffn
@deffn {Function} {numseq} FROM TO &key LENGTH BY TYPE
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶NUMSEQ function}@c
@functionsubindex{numseq}@c
Return a sequence between FROM and TO@comma{} progressing by BY@comma{} of the given LENGTH.  Only 3 of these a parameters should be given@comma{} the missing one (NIL) should be inferred automatically.  The sign of BY is adjusted if necessary.  If TYPE is LIST@comma{} the result is a list@comma{} otherwise it determines the element type of the resulting simple array.  If TYPE is nil@comma{} it as autodetected from the arguments (as a FIXNUM@comma{} a RATIONAL@comma{} or some subtype of FLOAT).  Note that the implementation may upgrade the element type.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {plusminus-interval} CENTER HALF-WIDTH &key OPEN-LEFT? OPEN-RIGHT?
@anchor{go to the NUM-UTILS․INTERVAL∶∶PLUSMINUS-INTERVAL function}@c
@functionsubindex{plusminus-interval}@c
A symmetric interval around CENTER.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pool} &rest ACCUMULATORS
@anchor{go to the NUM-UTILS․STATISTICS∶∶POOL function}@c
@functionsubindex{pool}@c
Pool ACCUMULATORS.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {print-length-truncate} DIMENSION
@anchor{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-LENGTH-TRUNCATE function}@c
@functionsubindex{print-length-truncate}@c
Return values (min dimension *print-length*) and whether the constraint is binding.
@table @strong
@item Package
@ref{go to the NUM-UTILS․PRINT-MATRIX package, , @t{num-utils.print-matrix}}
@item Source
@ref{go to the num-utils/print-matrix․lisp file, , @t{print-matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {print-matrix} MATRIX STREAM &key FORMATTER MASKED-FN ALIGNED? PADDING INDENT
@anchor{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-MATRIX function}@c
@functionsubindex{print-matrix}@c
Format and print the elements of MATRIX (a 2d array) to STREAM@comma{} using PADDING between columns.@*

MASKED-FN is called on row and column indices.  If it returns nil@comma{} the corresponding element is formatted using FORMATTER and printed.  Otherwise@comma{} it should return a string@comma{} which is printed as is.  INDENT is printed before each row.

If ALIGNED?@comma{} columns will be right-aligned.  At most *PRINT-LENGTH* rows and columns are printed@comma{} more is indicated with ellipses (...).
@table @strong
@item Package
@ref{go to the NUM-UTILS․PRINT-MATRIX package, , @t{num-utils.print-matrix}}
@item Source
@ref{go to the num-utils/print-matrix․lisp file, , @t{print-matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {relative} FRACTION
@anchor{go to the NUM-UTILS․INTERVAL∶∶RELATIVE function}@c
@functionsubindex{relative}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {rms} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶RMS function}@c
@functionsubindex{rms}@c
@deffnx {Function} {(setf rms)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF RMS❩ function}@c
@functionsubindex{(setf rms)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {romberg-quadrature} F INTERVAL &key EPSILON MIN-ITER MAX-ITER TRANSFORMATION
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ROMBERG-QUADRATURE function}@c
@functionsubindex{romberg-quadrature}@c
Romberg quadrature of F on the interval.  The iteration stops if the relative change is below EPSILON@comma{} but only after MIN-ITER refinements (to avoid spurious premature convergence).  An error occurs when MAX-ITER iterations are reached without convergence.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {root-bisection} F BRACKET &key DELTA EPSILON
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶ROOT-BISECTION function}@c
@functionsubindex{root-bisection}@c
Find the root of f bracketed between a and b using bisection.@*
The algorithm stops when either the root is bracketed in an interval of length
TOLERANCE (relative to the initial |a-b|)@comma{} or root is found such that
abs(f(root)) <= epsilon.@*

Return five values: the root@comma{} the value of the function at the root@comma{} and a
boolean which is true iff abs(f(root)) <= epsilon.  If the third value is
true@comma{} the fourth and fifth values are the endpoints of the bracketing
interval@comma{} otherwise they are undefined.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end deffn
@deffn {Function} {round*} NUMBER &optional DIVISOR OFFSET
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶ROUND* function}@c
@functionsubindex{round*}@c
Find A=I*DIVISOR+OFFSET that minimizes |A-NUMBER|@comma{} return (values A (- A NUMBER).  When NUMBER is exactly in between two possible A's@comma{} the rounding rule of ROUND is used on NUMBER-OFFSET.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {same-sign-p} &rest ARGUMENTS
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SAME-SIGN-P function}@c
@functionsubindex{same-sign-p}@c
Test whether all arguments have the same sign (ie all are positive@comma{} negative@comma{} or zero).
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sequence-maximum} X
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SEQUENCE-MAXIMUM function}@c
@functionsubindex{sequence-maximum}@c
Return the maximum value in the sequence
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sequence-minimum} X
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SEQUENCE-MINIMUM function}@c
@functionsubindex{sequence-minimum}@c
Return the minimum value in the sequence
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sequencep} X
@anchor{go to the NUM-UTILS․UTILITIES∶∶SEQUENCEP function}@c
@functionsubindex{sequencep}@c
Return T if X is type SEQUENCE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {shrink-interval} INTERVAL LEFT &optional RIGHT CHECK-FLIP?
@anchor{go to the NUM-UTILS․INTERVAL∶∶SHRINK-INTERVAL function}@c
@functionsubindex{shrink-interval}@c
Shrink interval by given magnitudes (which may be REAL or RELATIVE).  When
check-flip?@comma{} the result is checked for endpoints being in a different order
than the original.  Negative LEFT and RIGHT extend the interval.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sorted-reals-elements} SORTED-REALS
@anchor{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-ELEMENTS function}@c
@functionsubindex{sorted-reals-elements}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {spacer} &optional WEIGHT
@anchor{go to the NUM-UTILS․INTERVAL∶∶SPACER function}@c
@functionsubindex{spacer}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sparse-counter-count} SPARSE-COUNTER OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-COUNT function}@c
@functionsubindex{sparse-counter-count}@c
Return the count for OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sparse-counter-table} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-TABLE function}@c
@functionsubindex{sparse-counter-table}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {split-interval} INTERVAL DIVISIONS
@anchor{go to the NUM-UTILS․INTERVAL∶∶SPLIT-INTERVAL function}@c
@functionsubindex{split-interval}@c
Return a vector of subintervals (same length as DIVISIONS)@comma{} splitting the
interval using the sequence DIVISIONS@comma{} which can be nonnegative real
numbers (or RELATIVE specifications) and SPACERs which divide the leftover
proportionally.  If there are no spacers and the divisions don't fill up the
interval@comma{} and error is signalled.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {square} NUMBER
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SQUARE function}@c
@functionsubindex{square}@c
Square of number.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {subintervals-in} INTERVAL COUNT &optional MID-OPEN-RIGHT?
@anchor{go to the NUM-UTILS․INTERVAL∶∶SUBINTERVALS-IN function}@c
@functionsubindex{subintervals-in}@c
Return INTERVAL evenly divided into COUNT subintervals as a vector.  When MID-OPEN-RIGHT?@comma{} subintervals in the middle are open on the right and closed on the left@comma{} otherwise the opposite; openness of endpoints on the edge follows INTERVAL.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tabulate} SEQUENCE &key TEST
@anchor{go to the NUM-UTILS․STATISTICS∶∶TABULATE function}@c
@functionsubindex{tabulate}@c
Tabulate a sequence (using a SPARSE-COUNTER with the given TEST).
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {test-count} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-COUNT function}@c
@functionsubindex{test-count}@c
@deffnx {Function} {(setf test-count)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF TEST-COUNT❩ function}@c
@functionsubindex{(setf test-count)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {test-fn} EXPECTED-COLUMN FN &rest FN-PARAM-COLUMNS
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-FN function}@c
@functionsubindex{test-fn}@c
Test the differences between expected values and the given function
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {truncate*} NUMBER &optional DIVISOR OFFSET
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶TRUNCATE* function}@c
@functionsubindex{truncate*}@c
Find A=I*DIVISOR+OFFSET that maximizes |A|<=|NUMBER| with the same sign@comma{} return (values A (- A NUMBER).
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {upper-triangular-matrix} ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX function}@c
@functionsubindex{upper-triangular-matrix}@c
Create a lower-triangular-matrix.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {variance0} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE0 function}@c
@functionsubindex{variance0}@c
@deffnx {Function} {(setf variance0)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE0❩ function}@c
@functionsubindex{(setf variance0)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {variance1} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE1 function}@c
@functionsubindex{variance1}@c
@deffnx {Function} {(setf variance1)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE1❩ function}@c
@functionsubindex{(setf variance1)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec} ELEMENT-TYPE &rest ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶VEC function}@c
@functionsubindex{vec}@c
Return a vector with elements coerced to ELEMENT-TYPE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Source
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@end table
@end deffn
@deffn {Function} {weighted-quantiles} VALUES WEIGHTS QS
@anchor{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-QUANTILES function}@c
@functionsubindex{weighted-quantiles}@c
Calculate quantiles QS of weighted observations.  Uses a 0.5 correction.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {within?} LEFT VALUE RIGHT
@anchor{go to the NUM-UTILS․UTILITIES∶∶WITHIN? function}@c
@functionsubindex{within?}@c
Return non-nil iff value is in [left@comma{}right).
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {worst-case} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶WORST-CASE function}@c
@functionsubindex{worst-case}@c
@deffnx {Function} {(setf worst-case)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF WORST-CASE❩ function}@c
@functionsubindex{(setf worst-case)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrapped-matrix-elements} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX-ELEMENTS function}@c
@functionsubindex{wrapped-matrix-elements}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn

@node Exported generic functions, Exported conditions, Exported functions, Exported definitions
@subsection Generic functions
@deffn {Generic Function} {add} ACCUMULATOR OBJECT &key WEIGHT
@anchor{go to the NUM-UTILS․STATISTICS∶∶ADD generic function}@c
@genericsubindex{add}@c
Add OBJECT to ACCUMULATOR.  Return OBJECT.  NILs are ignored by the accumulator@comma{} unless a specialized method decides otherwise.  Keywords may be used to specify additional information (eg weight).
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {add} (ACCUMULATOR @t{sparse-counter}) OBJECT &key WEIGHT
@anchor{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER COMMON-LISP∶∶T method}@c
@methodsubindex{add}@c
@end deffn
@deffn {Method} {add} (ACCUMULATOR @t{sorted-reals}) OBJECT &key
@anchor{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method}@c
@methodsubindex{add}@c
@end deffn
@deffn {Method} {add} (MOMENTS @t{central-sample-moments}) (Y @t{real}) &key WEIGHT
@anchor{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶REAL method}@c
@methodsubindex{add}@c
@end deffn
@deffn {Method} {add} ACCUMULATOR (OBJECT @t{null}) &key
@anchor{go to the NUM-UTILS․STATISTICS∶∶ADD COMMON-LISP∶∶T COMMON-LISP∶∶NULL method}@c
@methodsubindex{add}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {as-alist} OBJECT
@anchor{go to the NUM-UTILS․UTILITIES∶∶AS-ALIST generic function}@c
@genericsubindex{as-alist}@c
Return OBJECT as an ALIST.  Semantics depends on OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@item Methods
@deffn {Method} {as-alist} (OBJECT @t{sparse-counter})
@anchor{go to the NUM-UTILS․UTILITIES∶∶AS-ALIST NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method}@c
@methodsubindex{as-alist}@c
Return (OBJECT . COUNT) pairs as an alist.
@table @strong
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {as-plist} OBJECT
@anchor{go to the NUM-UTILS․UTILITIES∶∶AS-PLIST generic function}@c
@genericsubindex{as-plist}@c
Return OBJECT as a PLIST.  Semantics depends on OBJECT.  The default method uses AS-ALIST.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@item Methods
@deffn {Method} {as-plist} OBJECT
@anchor{go to the NUM-UTILS․UTILITIES∶∶AS-PLIST COMMON-LISP∶∶T method}@c
@methodsubindex{as-plist}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {central-m2} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 generic function}@c
@genericsubindex{central-m2}@c
Second central moment.  For samples@comma{} normalized by the total weight (and thus not the unbiased estimator@comma{} see VARIANCE).
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {central-m2} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 COMMON-LISP∶∶T method}@c
@methodsubindex{central-m2}@c
@end deffn
@deffn {Method} {central-m2} (OBJECT @t{central-sample-moments}) &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{central-m2}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {central-m3} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 generic function}@c
@genericsubindex{central-m3}@c
Third central moment.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {central-m3} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 COMMON-LISP∶∶T method}@c
@methodsubindex{central-m3}@c
@end deffn
@deffn {Method} {central-m3} (OBJECT @t{central-sample-moments}) &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{central-m3}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {central-m4} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 generic function}@c
@genericsubindex{central-m4}@c
Fourth central moment.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {central-m4} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 COMMON-LISP∶∶T method}@c
@methodsubindex{central-m4}@c
@end deffn
@deffn {Method} {central-m4} (OBJECT @t{central-sample-moments}) &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{central-m4}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {central-sample-moments} OBJECT &key DEGREE WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS generic function}@c
@genericsubindex{central-sample-moments}@c
Return a CENTRAL-SAMPLE-MOMENTS object that allows the@*
calculation of the central sample moments of OBJECT up to the given DEGREE.

When WEIGHTS are given@comma{} they need to be a sequence of matching length.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {central-sample-moments} (OBJECT @t{null}) &key DEGREE WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶NULL method}@c
@methodsubindex{central-sample-moments}@c
@end deffn
@deffn {Method} {central-sample-moments} (MOMENTS @t{central-sample-moments}) &key DEGREE WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{central-sample-moments}@c
@end deffn
@deffn {Method} {central-sample-moments} (SEQUENCE @t{sequence}) &key DEGREE WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶SEQUENCE method}@c
@methodsubindex{central-sample-moments}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {diagonal-vector} MATRIX
@anchor{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR generic function}@c
@genericsubindex{diagonal-vector}@c
Return the diagonal elements of MATRIX as a vector.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Writer
@ref{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-VECTOR❩ generic function, , @t{(setf diagonal-vector)}} (generic function)
@item Methods
@deffn {Method} {diagonal-vector} (MATRIX @t{array})
@anchor{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{diagonal-vector}@c
@end deffn
@deffn {Method} {diagonal-vector} MATRIX
@anchor{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR COMMON-LISP∶∶T method}@c
@methodsubindex{diagonal-vector}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {(setf diagonal-vector)} VECTOR MATRIX
@anchor{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-VECTOR❩ generic function}@c
@genericsubindex{(setf diagonal-vector)}@c
Set the diagonal elements of MATRIX using VECTOR.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Reader
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-VECTOR generic function, , @t{diagonal-vector}} (generic function)
@end table
@end deffn
@deffn {Generic Function} {e1-} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1- generic function}@c
@genericsubindex{e1-}@c
Univariate elementwise -.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e1-} (A @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1-} (A @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1-} (A @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1-} (A @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1-} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1- COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e1-}@c
@end deffn
@deffn {Method} {e1-} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1- COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e1-}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e1/} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ generic function}@c
@genericsubindex{e1/}@c
Univariate elementwise /.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e1/} (A @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1/} (A @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1/} (A @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1/} (A @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1/} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e1/}@c
@end deffn
@deffn {Method} {e1/} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e1/}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e1log} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG generic function}@c
@genericsubindex{e1log}@c
Univariate elementwise LOG.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e1log} (A @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1log} (A @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1log} (A @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1log} (A @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e1log} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e1log}@c
@end deffn
@deffn {Method} {e1log} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e1log}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2*} A B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* generic function}@c
@genericsubindex{e2*}@c
Bivariate elementwise *.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e2*} (A @t{diagonal-matrix}) (B @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{hermitian-matrix}) (B @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{upper-triangular-matrix}) (B @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{lower-triangular-matrix}) (B @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{number}) (B @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{diagonal-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{number}) (B @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{hermitian-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{number}) (B @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{upper-triangular-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{number}) (B @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{lower-triangular-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} A (B @t{wrapped-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{wrapped-matrix}) B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2*} (A @t{number}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2*}@c
@end deffn
@deffn {Method} {e2*} (A @t{vector}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2*}@c
@end deffn
@deffn {Method} {e2*} (A @t{number}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2*}@c
@end deffn
@deffn {Method} {e2*} (A @t{vector}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2*}@c
@end deffn
@deffn {Method} {e2*} (A @t{array}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2*}@c
@end deffn
@deffn {Method} {e2*} (A @t{number}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2*}@c
@end deffn
@deffn {Method} {e2*} (A @t{array}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2*}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2+} A B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ generic function}@c
@genericsubindex{e2+}@c
Bivariate elementwise +.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e2+} (A @t{diagonal-matrix}) (B @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2+} (A @t{hermitian-matrix}) (B @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2+} (A @t{upper-triangular-matrix}) (B @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2+} (A @t{lower-triangular-matrix}) (B @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2+} A (B @t{wrapped-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2+} (A @t{wrapped-matrix}) B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2+} (A @t{number}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2+}@c
@end deffn
@deffn {Method} {e2+} (A @t{vector}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2+}@c
@end deffn
@deffn {Method} {e2+} (A @t{number}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2+}@c
@end deffn
@deffn {Method} {e2+} (A @t{vector}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2+}@c
@end deffn
@deffn {Method} {e2+} (A @t{array}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2+}@c
@end deffn
@deffn {Method} {e2+} (A @t{number}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2+}@c
@end deffn
@deffn {Method} {e2+} (A @t{array}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2+}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2-} A B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- generic function}@c
@genericsubindex{e2-}@c
Bivariate elementwise -.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e2-} (A @t{diagonal-matrix}) (B @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2-} (A @t{hermitian-matrix}) (B @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2-} (A @t{upper-triangular-matrix}) (B @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2-} (A @t{lower-triangular-matrix}) (B @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2-} A (B @t{wrapped-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2-} (A @t{wrapped-matrix}) B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2-} (A @t{number}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2-}@c
@end deffn
@deffn {Method} {e2-} (A @t{vector}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2-}@c
@end deffn
@deffn {Method} {e2-} (A @t{number}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2-}@c
@end deffn
@deffn {Method} {e2-} (A @t{vector}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2-}@c
@end deffn
@deffn {Method} {e2-} (A @t{array}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2-}@c
@end deffn
@deffn {Method} {e2-} (A @t{number}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2-}@c
@end deffn
@deffn {Method} {e2-} (A @t{array}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2-}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2/} A B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ generic function}@c
@genericsubindex{e2/}@c
Bivariate elementwise /.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e2/} (A @t{number}) (B @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{diagonal-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{number}) (B @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{hermitian-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{number}) (B @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{upper-triangular-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{number}) (B @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{lower-triangular-matrix}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {e2/} (A @t{number}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2/}@c
@end deffn
@deffn {Method} {e2/} (A @t{vector}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2/}@c
@end deffn
@deffn {Method} {e2/} (A @t{number}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2/}@c
@end deffn
@deffn {Method} {e2/} (A @t{vector}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2/}@c
@end deffn
@deffn {Method} {e2/} (A @t{array}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2/}@c
@end deffn
@deffn {Method} {e2/} (A @t{number}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2/}@c
@end deffn
@deffn {Method} {e2/} (A @t{array}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2/}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2log} A B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG generic function}@c
@genericsubindex{e2log}@c
Bivariate elementwise LOG.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {e2log} (A @t{number}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2log}@c
@end deffn
@deffn {Method} {e2log} (A @t{vector}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2log}@c
@end deffn
@deffn {Method} {e2log} (A @t{number}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2log}@c
@end deffn
@deffn {Method} {e2log} (A @t{vector}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{e2log}@c
@end deffn
@deffn {Method} {e2log} (A @t{array}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{e2log}@c
@end deffn
@deffn {Method} {e2log} (A @t{number}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2log}@c
@end deffn
@deffn {Method} {e2log} (A @t{array}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶E2LOG COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{e2log}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {eceiling} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING generic function}@c
@genericsubindex{eceiling}@c
Univariate elementwise CEILING.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {eceiling} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{eceiling}@c
@end deffn
@deffn {Method} {eceiling} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ECEILING COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{eceiling}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {econjugate} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE generic function}@c
@genericsubindex{econjugate}@c
Univariate elementwise CONJUGATE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {econjugate} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{econjugate}@c
@end deffn
@deffn {Method} {econjugate} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ECONJUGATE COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{econjugate}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {eexp} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP generic function}@c
@genericsubindex{eexp}@c
Univariate elementwise EXP.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {eexp} (A @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {eexp} (A @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {eexp} (A @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {eexp} (A @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {eexp} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{eexp}@c
@end deffn
@deffn {Method} {eexp} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{eexp}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {eexpt} A B
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT generic function}@c
@genericsubindex{eexpt}@c
Bivariate elementwise EXPT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {eexpt} (A @t{number}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{eexpt}@c
@end deffn
@deffn {Method} {eexpt} (A @t{vector}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶VECTOR COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{eexpt}@c
@end deffn
@deffn {Method} {eexpt} (A @t{number}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{eexpt}@c
@end deffn
@deffn {Method} {eexpt} (A @t{vector}) (B @t{vector})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶VECTOR COMMON-LISP∶∶VECTOR method}@c
@methodsubindex{eexpt}@c
@end deffn
@deffn {Method} {eexpt} (A @t{array}) (B @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶ARRAY COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{eexpt}@c
@end deffn
@deffn {Method} {eexpt} (A @t{number}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶NUMBER COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{eexpt}@c
@end deffn
@deffn {Method} {eexpt} (A @t{array}) (B @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EEXPT COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{eexpt}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {efloor} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR generic function}@c
@genericsubindex{efloor}@c
Univariate elementwise FLOOR.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {efloor} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{efloor}@c
@end deffn
@deffn {Method} {efloor} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EFLOOR COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{efloor}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {ensure-sorted-reals} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS generic function}@c
@genericsubindex{ensure-sorted-reals}@c
Return the contents of OBJECT as a SORTED-REALS.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {ensure-sorted-reals} (SORTED-REALS @t{sorted-reals})
@anchor{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS NUM-UTILS․STATISTICS∶∶SORTED-REALS method}@c
@methodsubindex{ensure-sorted-reals}@c
@end deffn
@deffn {Method} {ensure-sorted-reals} (ARRAY @t{array})
@anchor{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{ensure-sorted-reals}@c
@end deffn
@deffn {Method} {ensure-sorted-reals} (LIST @t{list})
@anchor{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS COMMON-LISP∶∶LIST method}@c
@methodsubindex{ensure-sorted-reals}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {ereduce} FUNCTION OBJECT &key KEY
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE generic function}@c
@genericsubindex{ereduce}@c
Elementwise reduce@comma{} traversing in row-major order.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {ereduce} FUNCTION (ARRAY @t{array}) &key KEY
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{ereduce}@c
@end deffn
@deffn {Method} {ereduce} FUNCTION (SEQUENCE @t{sequence}) &key KEY
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶SEQUENCE method}@c
@methodsubindex{ereduce}@c
@end deffn
@deffn {Method} {ereduce} FUNCTION OBJECT &key KEY
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶EREDUCE COMMON-LISP∶∶T COMMON-LISP∶∶T method}@c
@methodsubindex{ereduce}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {esqrt} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT generic function}@c
@genericsubindex{esqrt}@c
Univariate elementwise SQRT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {esqrt} (A @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {esqrt} (A @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {esqrt} (A @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {esqrt} (A @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {esqrt} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{esqrt}@c
@end deffn
@deffn {Method} {esqrt} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{esqrt}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {extend-interval} INTERVAL OBJECT
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL generic function}@c
@genericsubindex{extend-interval}@c
Return an interval that includes INTERVAL and OBJECT.  NIL
stands for the empty set.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {extend-interval} (INTERVAL @t{null}) (OBJECT @t{null})
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶NULL COMMON-LISP∶∶NULL method}@c
@methodsubindex{extend-interval}@c
@end deffn
@deffn {Method} {extend-interval} (INTERVAL @t{null}) (NUMBER @t{real})
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶NULL COMMON-LISP∶∶REAL method}@c
@methodsubindex{extend-interval}@c
@end deffn
@deffn {Method} {extend-interval} (INTERVAL @t{interval}) (NUMBER @t{real})
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL NUM-UTILS․INTERVAL∶∶INTERVAL COMMON-LISP∶∶REAL method}@c
@methodsubindex{extend-interval}@c
@end deffn
@deffn {Method} {extend-interval} INTERVAL (OBJECT @t{interval})
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶INTERVAL method}@c
@methodsubindex{extend-interval}@c
@end deffn
@deffn {Method} {extend-interval} INTERVAL (LIST @t{list})
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶LIST method}@c
@methodsubindex{extend-interval}@c
@end deffn
@deffn {Method} {extend-interval} INTERVAL (ARRAY @t{array})
@anchor{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{extend-interval}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {kurtosis} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS generic function}@c
@genericsubindex{kurtosis}@c
Kurtosis FIXME talk about bias@comma{} maybe implement unbiased?
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {kurtosis} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS COMMON-LISP∶∶T method}@c
@methodsubindex{kurtosis}@c
@end deffn
@deffn {Method} {kurtosis} (OBJECT @t{central-sample-moments}) &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{kurtosis}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {l2norm-square} OBJECT
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM-SQUARE generic function}@c
@genericsubindex{l2norm-square}@c
Square of the $L_2$ norm of OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@item Methods
@deffn {Method} {l2norm-square} (SEQUENCE @t{sequence})
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶L2NORM-SQUARE COMMON-LISP∶∶SEQUENCE method}@c
@methodsubindex{l2norm-square}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {left} INTERVAL
@anchor{go to the NUM-UTILS․INTERVAL∶∶LEFT generic function}@c
@genericsubindex{left}@c
Left endpoint of interval.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {left} (INTERVAL @t{interval/infinite-left})
@anchor{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method}@c
@methodsubindex{left}@c
@end deffn
@deffn {Method} {left} (INTERVAL/FINITE-LEFT @t{interval/finite-left})
@anchor{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method}@c
@methodsubindex{left}@c
automatically generated reader method
@end deffn
@end table
@end deffn
@deffn {Generic Function} {mean} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶MEAN generic function}@c
@genericsubindex{mean}@c
The mean of elements in OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {mean} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶MEAN COMMON-LISP∶∶T method}@c
@methodsubindex{mean}@c
@end deffn
@deffn {Method} {mean} (OBJECT @t{central-sample-moments}) &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶MEAN NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{mean}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {median} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶MEDIAN generic function}@c
@genericsubindex{median}@c
Median of OBJECT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {median} (OBJECT @t{sequence})
@anchor{go to the NUM-UTILS․STATISTICS∶∶MEDIAN COMMON-LISP∶∶SEQUENCE method}@c
@methodsubindex{median}@c
@end deffn
@deffn {Method} {median} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶MEDIAN COMMON-LISP∶∶T method}@c
@methodsubindex{median}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {num=} A B &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= generic function}@c
@genericsubindex{num=}@c
Compare A and B for approximate equality@comma{} checking corresponding elements when applicable (using TOLERANCE).@*

Two numbers A and B are NUM= iff |a-b|/max(1@comma{}|a|@comma{}|b|) <= tolerance.@*

Unless a method is defined for them@comma{} two objects are compared with EQUALP.@*

Generally@comma{} methods should be defined so that two objects are NUM= if they the same class@comma{} same dimensions@comma{} and all their elements are NUM=.
@table @strong
@item Package
@ref{go to the NUM-UTILS․NUM= package, , @t{num-utils.num=}}
@item Source
@ref{go to the num-utils/num=․lisp file, , @t{num=.lisp}} (file)
@item Methods
@deffn {Method} {num=} (A @t{central-sample-moments}) (B @t{central-sample-moments}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Method} {num=} (A @t{diagonal-matrix}) (B @t{diagonal-matrix}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {num=} (A @t{wrapped-matrix}) (B @t{wrapped-matrix}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Method} {num=} (A @t{finite-interval}) (B @t{finite-interval}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL method}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Method} {num=} (A @t{real-line}) (B @t{real-line}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶REAL-LINE NUM-UTILS․INTERVAL∶∶REAL-LINE method}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Method} {num=} A B &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶T COMMON-LISP∶∶T method}@c
@methodsubindex{num=}@c
@end deffn
@deffn {Method} {num=} (A @t{number}) (B @t{number}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶NUMBER COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{num=}@c
@end deffn
@deffn {Method} {num=} (A @t{array}) (B @t{array}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶ARRAY COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{num=}@c
@end deffn
@deffn {Method} {num=} (A @t{cons}) (B @t{cons}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶CONS COMMON-LISP∶∶CONS method}@c
@methodsubindex{num=}@c
@end deffn
@deffn {Method} {num=} (A @t{null}) (B @t{null}) &optional TOLERANCE
@anchor{go to the NUM-UTILS․NUM=∶∶NUM= COMMON-LISP∶∶NULL COMMON-LISP∶∶NULL method}@c
@methodsubindex{num=}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {open-left?} INTERVAL
@anchor{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? generic function}@c
@genericsubindex{open-left?}@c
True iff the left endpoint of the interval is open.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {open-left?} (INTERVAL @t{interval/infinite-left})
@anchor{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method}@c
@methodsubindex{open-left?}@c
@end deffn
@deffn {Method} {open-left?} (INTERVAL/FINITE-LEFT @t{interval/finite-left})
@anchor{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method}@c
@methodsubindex{open-left?}@c
automatically generated reader method
@end deffn
@end table
@end deffn
@deffn {Generic Function} {open-right?} INTERVAL
@anchor{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? generic function}@c
@genericsubindex{open-right?}@c
True iff the right endpoint of the interval is open.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {open-right?} (INTERVAL @t{interval/infinite-right})
@anchor{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method}@c
@methodsubindex{open-right?}@c
@end deffn
@deffn {Method} {open-right?} (INTERVAL/FINITE-RIGHT @t{interval/finite-right})
@anchor{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method}@c
@methodsubindex{open-right?}@c
automatically generated reader method
@end deffn
@end table
@end deffn
@deffn {Generic Function} {product} OBJECT
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT generic function}@c
@genericsubindex{product}@c
Product of elements in object.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@item Methods
@deffn {Method} {product} (SEQUENCE @t{sequence})
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT COMMON-LISP∶∶SEQUENCE method}@c
@methodsubindex{product}@c
@end deffn
@deffn {Method} {product} (ARRAY @t{array})
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶PRODUCT COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{product}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {quantile} OBJECT Q
@anchor{go to the NUM-UTILS․STATISTICS∶∶QUANTILE generic function}@c
@genericsubindex{quantile}@c
Return an element at quantile Q.  May be an interpolation or an approximation@comma{} depending on OBJECT and Q.  NOTE: Extensions should define methods for QUANTILES@comma{} not QUANTILE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {quantile} (OBJECT @t{sequence}) Q
@anchor{go to the NUM-UTILS․STATISTICS∶∶QUANTILE COMMON-LISP∶∶SEQUENCE COMMON-LISP∶∶T method}@c
@methodsubindex{quantile}@c
@end deffn
@deffn {Method} {quantile} OBJECT Q
@anchor{go to the NUM-UTILS․STATISTICS∶∶QUANTILE COMMON-LISP∶∶T COMMON-LISP∶∶T method}@c
@methodsubindex{quantile}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {quantiles} OBJECT QS
@anchor{go to the NUM-UTILS․STATISTICS∶∶QUANTILES generic function}@c
@genericsubindex{quantiles}@c
Multiple quantiles (see QUANTILE).  NOTE: Extensions should define methods for QUANTILES@comma{} not QUANTILE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {quantiles} (OBJECT @t{sequence}) QS
@anchor{go to the NUM-UTILS․STATISTICS∶∶QUANTILES COMMON-LISP∶∶SEQUENCE COMMON-LISP∶∶T method}@c
@methodsubindex{quantiles}@c
@end deffn
@deffn {Method} {quantiles} (ACCUMULATOR @t{sorted-reals}) Q
@anchor{go to the NUM-UTILS․STATISTICS∶∶QUANTILES NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method}@c
@methodsubindex{quantiles}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {right} INTERVAL
@anchor{go to the NUM-UTILS․INTERVAL∶∶RIGHT generic function}@c
@genericsubindex{right}@c
Right endpoint of interval.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {right} (INTERVAL @t{interval/infinite-right})
@anchor{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method}@c
@methodsubindex{right}@c
@end deffn
@deffn {Method} {right} (INTERVAL/FINITE-RIGHT @t{interval/finite-right})
@anchor{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method}@c
@methodsubindex{right}@c
automatically generated reader method
@end deffn
@end table
@end deffn
@deffn {Generic Function} {sd} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶SD generic function}@c
@genericsubindex{sd}@c
Standard deviation.  For samples@comma{} the square root of the unbiased estimator (see VARIANCE).
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {sd} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶SD COMMON-LISP∶∶T method}@c
@methodsubindex{sd}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {shift-interval} INTERVAL OFFSET
@anchor{go to the NUM-UTILS․INTERVAL∶∶SHIFT-INTERVAL generic function}@c
@genericsubindex{shift-interval}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {shift-interval} (INTERVAL @t{finite-interval}) (OFFSET @t{real})
@anchor{go to the NUM-UTILS․INTERVAL∶∶SHIFT-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶REAL method}@c
@methodsubindex{shift-interval}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {skewness} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS generic function}@c
@genericsubindex{skewness}@c
Skewness FIXME talk about bias@comma{} maybe implement unbiased?
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {skewness} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS COMMON-LISP∶∶T method}@c
@methodsubindex{skewness}@c
@end deffn
@deffn {Method} {skewness} (OBJECT @t{central-sample-moments}) &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{skewness}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {sum} OBJECT &key KEY
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SUM generic function}@c
@genericsubindex{sum}@c
Sum of elements in object.  KEY is applied to each
  element.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@item Methods
@deffn {Method} {sum} (SEQUENCE @t{sequence}) &key KEY
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SUM COMMON-LISP∶∶SEQUENCE method}@c
@methodsubindex{sum}@c
@end deffn
@deffn {Method} {sum} (ARRAY @t{array}) &key KEY
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SUM COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{sum}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {tally} ACCUMULATOR
@anchor{go to the NUM-UTILS․STATISTICS∶∶TALLY generic function}@c
@genericsubindex{tally}@c
The total weight of elements in ACCUMULATOR.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {tally} (ACCUMULATOR @t{sparse-counter})
@anchor{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method}@c
@methodsubindex{tally}@c
@end deffn
@deffn {Method} {tally} (ACCUMULATOR @t{tally-mixin})
@anchor{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶TALLY-MIXIN method}@c
@methodsubindex{tally}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {transpose} ARRAY
@anchor{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE generic function}@c
@genericsubindex{transpose}@c
Transpose.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Methods
@deffn {Method} {transpose} (ARRAY @t{array})
@anchor{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{transpose}@c
@end deffn
@deffn {Method} {transpose} (MATRIX @t{lower-triangular-matrix})
@anchor{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method}@c
@methodsubindex{transpose}@c
@end deffn
@deffn {Method} {transpose} (MATRIX @t{upper-triangular-matrix})
@anchor{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method}@c
@methodsubindex{transpose}@c
@end deffn
@deffn {Method} {transpose} (MATRIX @t{hermitian-matrix})
@anchor{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method}@c
@methodsubindex{transpose}@c
@end deffn
@deffn {Method} {transpose} (DIAGONAL @t{diagonal-matrix})
@anchor{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method}@c
@methodsubindex{transpose}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {variance} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶VARIANCE generic function}@c
@genericsubindex{variance}@c
Variance of OBJECT.  For samples@comma{} normalized by the weight-1 (and thus unbiased if certain assumptions hold@comma{} eg weights that count frequencies).
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {variance} OBJECT &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶VARIANCE COMMON-LISP∶∶T method}@c
@methodsubindex{variance}@c
@end deffn
@deffn {Method} {variance} (OBJECT @t{central-sample-moments}) &key WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶VARIANCE NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{variance}@c
@end deffn
@end table
@end deffn

@node Exported conditions, Exported structures, Exported generic functions, Exported definitions
@subsection Conditions
@deftp {Condition} {empty-accumulator} ()
@anchor{go to the NUM-UTILS․STATISTICS∶∶EMPTY-ACCUMULATOR condition}@c
@conditionsubindex{empty-accumulator}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {information-not-collected-in-accumulator} ()
@anchor{go to the NUM-UTILS․STATISTICS∶∶INFORMATION-NOT-COLLECTED-IN-ACCUMULATOR condition}@c
@conditionsubindex{information-not-collected-in-accumulator}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {not-enough-elements-in-accumulator} ()
@anchor{go to the NUM-UTILS․STATISTICS∶∶NOT-ENOUGH-ELEMENTS-IN-ACCUMULATOR condition}@c
@conditionsubindex{not-enough-elements-in-accumulator}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp

@node Exported structures, Exported classes, Exported conditions, Exported definitions
@subsection Structures
@deftp {Structure} {central-sample-moments} ()
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS structure}@c
@structuresubindex{central-sample-moments}@c
Central sample moments calculated on-line/single-pass.@*

   M   weighted mean@*
   S2  weighted sum of squared deviations from the mean@comma{} not calculated when NIL
   S3  weighted sum of cubed deviations from the mean@comma{} not calculated when NIL
   S4  weighted sum of 4th power deviations from the mean@comma{} not calculated when NIL

Allows on-line@comma{} numerically stable calculation of moments.  See
cite@lbracechar{}bennett2009numerically@rbracechar{} and cite@lbracechar{}pebay2008formulas@rbracechar{} for the description
of the algorithm.  M_2@comma{} ...@comma{} M_4 in the paper are s2@comma{} ...@comma{} s4 in the code.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Direct superclasses
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN structure, , @t{tally-mixin}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶KURTOSIS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{kurtosis}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶SKEWNESS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{skewness}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M4 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m4}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M3 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m3}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-M2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-m2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶VARIANCE NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{variance}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶MEAN NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{mean}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{central-sample-moments}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶POOL2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{pool2}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS COMMON-LISP∶∶REAL method, , @t{add}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method, , @t{num=}} (method)
@end itemize
@item Direct slots
@defvr {Slot} m
@slotsubindex{m}@c
@table @strong
@item Type
@t{real}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-M function, , @t{central-sample-moments-m}} (function)
@item Writers
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-M❩ function, , @t{(setf central-sample-moments-m)}} (function)
@end table
@end defvr
@defvr {Slot} s2
@slotsubindex{s2}@c
@table @strong
@item Type
@t{(or (real 0) null)}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S2 function, , @t{central-sample-moments-s2}} (function)
@item Writers
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S2❩ function, , @t{(setf central-sample-moments-s2)}} (function)
@end table
@end defvr
@defvr {Slot} s3
@slotsubindex{s3}@c
@table @strong
@item Type
@t{(or real null)}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S3 function, , @t{central-sample-moments-s3}} (function)
@item Writers
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S3❩ function, , @t{(setf central-sample-moments-s3)}} (function)
@end table
@end defvr
@defvr {Slot} s4
@slotsubindex{s4}@c
@table @strong
@item Type
@t{(or (real 0) null)}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S4 function, , @t{central-sample-moments-s4}} (function)
@item Writers
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S4❩ function, , @t{(setf central-sample-moments-s4)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {diagonal-matrix} ()
@anchor{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX structure}@c
@structuresubindex{diagonal-matrix}@c
Diagonal matrix.  The elements in the diagonal are stored in a vector.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@t{dims} (method)
@item
@t{element-type} (method)
@item
@t{as-array} (method)
@end itemize
@item Direct slots
@defvr {Slot} elements
@slotsubindex{elements}@c
@table @strong
@item Type
@t{vector}
@item Readers
@ref{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX-ELEMENTS function, , @t{diagonal-matrix-elements}} (function)
@item Writers
@ref{go to the NUM-UTILS․MATRIX∶∶❨SETF DIAGONAL-MATRIX-ELEMENTS❩ function, , @t{(setf diagonal-matrix-elements)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {hermitian-matrix} ()
@anchor{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX structure}@c
@structuresubindex{hermitian-matrix}@c
Hermitian/symmetric matrix@comma{} with elements stored in the _lower_ triangle.@*

Implements _both_ real symmetric and complex Hermitian matrices --- as technically@comma{} real symmetric matrices are also Hermitian.  Complex symmetric matrices are _not_ implemented as a special matrix type@comma{} as they don't have any special properties (eg real eigenvalues@comma{} etc).
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Direct superclasses
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX structure, , @t{wrapped-matrix}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@t{select} (method)
@item
@t{print-object} (method)
@item
@t{as-array} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {lower-triangular-matrix} ()
@anchor{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX structure}@c
@structuresubindex{lower-triangular-matrix}@c
Lower triangular matrix.  ELEMENTS in the upper triangle are treated as zero.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Direct superclasses
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX structure, , @t{wrapped-matrix}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@t{select} (method)
@item
@t{print-object} (method)
@item
@t{as-array} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {relative} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶RELATIVE structure}@c
@structuresubindex{relative}@c
Relative sizes are in terms of width.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} fraction
@slotsubindex{fraction}@c
@table @strong
@item Type
@t{(real 0)}
@item Readers
@ref{go to the NUM-UTILS․INTERVAL∶∶RELATIVE-FRACTION function, , @t{relative-fraction}} (function)
@item Writers
@t{(setf relative-fraction)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {sorted-reals} ()
@anchor{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS structure}@c
@structuresubindex{sorted-reals}@c
Accumulator which sorts elements.  ELEMENTS return the sorted elements.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶QUANTILES NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method, , @t{quantiles}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ENSURE-SORTED-REALS NUM-UTILS․STATISTICS∶∶SORTED-REALS method, , @t{ensure-sorted-reals}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SORTED-REALS COMMON-LISP∶∶T method, , @t{add}} (method)
@end itemize
@item Direct slots
@defvr {Slot} ordered-elements
@slotsubindex{ordered-elements}@c
@table @strong
@item Type
@t{vector}
@item Initform
@t{@hashchar{}()}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-ORDERED-ELEMENTS function, , @t{sorted-reals-ordered-elements}} (function)
@item Writers
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-ORDERED-ELEMENTS❩ function, , @t{(setf sorted-reals-ordered-elements)}} (function)
@end table
@end defvr
@defvr {Slot} unordered-elements
@slotsubindex{unordered-elements}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-UNORDERED-ELEMENTS function, , @t{sorted-reals-unordered-elements}} (function)
@item Writers
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-UNORDERED-ELEMENTS❩ function, , @t{(setf sorted-reals-unordered-elements)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {spacer} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶SPACER structure}@c
@structuresubindex{spacer}@c
Spacers divide the leftover portion of an interval.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} weight
@slotsubindex{weight}@c
@table @strong
@item Type
@t{(real 0)}
@item Initform
@t{1}
@item Readers
@ref{go to the NUM-UTILS․INTERVAL∶∶SPACER-WEIGHT function, , @t{spacer-weight}} (function)
@item Writers
@t{(setf spacer-weight)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {sparse-counter} ()
@anchor{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER structure}@c
@structuresubindex{sparse-counter}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{print-object} (method)
@item
@ref{go to the NUM-UTILS․UTILITIES∶∶AS-ALIST NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method, , @t{as-alist}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER method, , @t{tally}} (method)
@item
@ref{go to the NUM-UTILS․STATISTICS∶∶ADD NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER COMMON-LISP∶∶T method, , @t{add}} (method)
@end itemize
@item Direct slots
@defvr {Slot} table
@slotsubindex{table}@c
@table @strong
@item Type
@t{hash-table}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-TABLE function, , @t{sparse-counter-table}} (function)
@item Writers
@t{(setf sparse-counter-table)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {test-results} ()
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-RESULTS structure}@c
@structuresubindex{test-results}@c
Differences between reference values and computed values
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} worst-case
@slotsubindex{worst-case}@c
@table @strong
@item Type
@t{integer}
@item Initform
@t{0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶WORST-CASE function, , @t{worst-case}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF WORST-CASE❩ function, , @t{(setf worst-case)}} (function)
@end table
@end defvr
@defvr {Slot} min-error
@slotsubindex{min-error}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MIN-ERROR function, , @t{min-error}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MIN-ERROR❩ function, , @t{(setf min-error)}} (function)
@end table
@end defvr
@defvr {Slot} max-error
@slotsubindex{max-error}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MAX-ERROR function, , @t{max-error}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MAX-ERROR❩ function, , @t{(setf max-error)}} (function)
@end table
@end defvr
@defvr {Slot} mean-error
@slotsubindex{mean-error}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶MEAN-ERROR function, , @t{mean-error}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF MEAN-ERROR❩ function, , @t{(setf mean-error)}} (function)
@end table
@end defvr
@defvr {Slot} test-count
@slotsubindex{test-count}@c
@table @strong
@item Type
@t{integer}
@item Initform
@t{0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-COUNT function, , @t{test-count}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF TEST-COUNT❩ function, , @t{(setf test-count)}} (function)
@end table
@end defvr
@defvr {Slot} variance0
@slotsubindex{variance0}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE0 function, , @t{variance0}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE0❩ function, , @t{(setf variance0)}} (function)
@end table
@end defvr
@defvr {Slot} variance1
@slotsubindex{variance1}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶VARIANCE1 function, , @t{variance1}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF VARIANCE1❩ function, , @t{(setf variance1)}} (function)
@end table
@end defvr
@defvr {Slot} rms
@slotsubindex{rms}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶RMS function, , @t{rms}} (function)
@item Writers
@ref{go to the NUM-UTILS․TEST-UTILITIES∶∶❨SETF RMS❩ function, , @t{(setf rms)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {upper-triangular-matrix} ()
@anchor{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX structure}@c
@structuresubindex{upper-triangular-matrix}@c
Upper triangular matrix.  ELEMENTS in the lower triangle are treated as zero.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Direct superclasses
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX structure, , @t{wrapped-matrix}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶TRANSPOSE NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{transpose}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶ESQRT NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{esqrt}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1LOG NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1log}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶EEXP NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{eexp}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E1- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e1-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2/ NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2/}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶NUMBER NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX COMMON-LISP∶∶NUMBER method, , @t{e2*}} (method)
@item
@t{select} (method)
@item
@t{print-object} (method)
@item
@t{as-array} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {wrapped-matrix} ()
@anchor{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX structure}@c
@structuresubindex{wrapped-matrix}@c
A matrix that has some special structure (eg triangular@comma{} symmetric/hermitian).  ELEMENTS is always a matrix.  Not used directly@comma{} not exported.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX structure, , @t{lower-triangular-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX structure, , @t{upper-triangular-matrix}} (structure)
@item
@ref{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX structure, , @t{hermitian-matrix}} (structure)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{num=}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2* NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2*}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2- NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2-}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ COMMON-LISP∶∶T NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX method, , @t{e2+}} (method)
@item
@ref{go to the NUM-UTILS․ELEMENTWISE∶∶E2+ NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX COMMON-LISP∶∶T method, , @t{e2+}} (method)
@item
@t{dims} (method)
@item
@t{element-type} (method)
@end itemize
@item Direct slots
@defvr {Slot} elements
@slotsubindex{elements}@c
@table @strong
@item Type
@t{(array * (* *))}
@item Readers
@ref{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX-ELEMENTS function, , @t{wrapped-matrix-elements}} (function)
@item Writers
@t{(setf wrapped-matrix-elements)} (function)
@end table
@end defvr
@end table
@end deftp

@node Exported classes, Exported types, Exported structures, Exported definitions
@subsection Classes
@deftp {Class} {finite-interval} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL class}@c
@classsubindex{finite-interval}@c
Interval with finite endpoints.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT class, , @t{interval/finite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT class, , @t{interval/finite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL class, , @t{interval}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶NULL method, , @t{transformed-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{chebyshev-approximate-implementation}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶SHIFT-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶REAL method, , @t{shift-interval}} (method)
@item
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL method, , @t{num=}} (method)
@item
@t{initialize-instance} (method)
@end itemize
@end table
@end deftp
@deftp {Class} {interval} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL class}@c
@classsubindex{interval}@c
Abstract superclass for all intervals.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@t{standard-object} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL class, , @t{finite-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL class, , @t{plusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶MINUSINF-INTERVAL class, , @t{minusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶REAL-LINE class, , @t{real-line}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL NUM-UTILS․INTERVAL∶∶INTERVAL COMMON-LISP∶∶REAL method, , @t{extend-interval}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶EXTEND-INTERVAL COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶INTERVAL method, , @t{extend-interval}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Class} {minusinf-interval} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶MINUSINF-INTERVAL class}@c
@classsubindex{minusinf-interval}@c
Interval from -∞ to RIGHT.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT class, , @t{interval/finite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT class, , @t{interval/infinite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL class, , @t{interval}} (class)
@end itemize
@end table
@end deftp
@deftp {Class} {plusinf-interval} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL class}@c
@classsubindex{plusinf-interval}@c
Interval from LEFT to ∞.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT class, , @t{interval/infinite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT class, , @t{interval/finite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL class, , @t{interval}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶NULL method, , @t{transformed-quadrature}} (method)
@item
@ref{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method, , @t{chebyshev-approximate-implementation}} (method)
@end itemize
@end table
@end deftp
@deftp {Class} {real-line} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶REAL-LINE class}@c
@classsubindex{real-line}@c
Representing the real line (-∞@comma{}∞).
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT class, , @t{interval/infinite-right}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT class, , @t{interval/infinite-left}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶INTERVAL class, , @t{interval}} (class)
@end itemize
@item Direct methods
@ref{go to the NUM-UTILS․NUM=∶∶NUM= NUM-UTILS․INTERVAL∶∶REAL-LINE NUM-UTILS․INTERVAL∶∶REAL-LINE method, , @t{num=}} (method)
@end table
@end deftp

@node Exported types, , Exported classes, Exported definitions
@subsection Types
@deftp {Type} {extended-real} &optional BASE
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶EXTENDED-REAL type}@c
@typesubindex{extended-real}@c
Extended real number.
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deftp
@deftp {Type} {simple-double-float-vector} &optional LENGTH
@anchor{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-DOUBLE-FLOAT-VECTOR type}@c
@typesubindex{simple-double-float-vector}@c
Simple vector of double-float elements.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deftp
@deftp {Type} {simple-fixnum-vector} ()
@anchor{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-FIXNUM-VECTOR type}@c
@typesubindex{simple-fixnum-vector}@c
Simple vector or fixnum elements.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deftp
@deftp {Type} {simple-single-float-vector} &optional LENGTH
@anchor{go to the NUM-UTILS․UTILITIES∶∶SIMPLE-SINGLE-FLOAT-VECTOR type}@c
@typesubindex{simple-single-float-vector}@c
Simple vector of single-float elements.
@table @strong
@item Package
@ref{go to the NUM-UTILS․UTILITIES package, , @t{num-utils.utilities}}
@item Source
@ref{go to the num-utils/utilities․lisp file, , @t{utilities.lisp}} (file)
@end table
@end deftp
@deftp {Type} {triangular-matrix} ()
@anchor{go to the NUM-UTILS․MATRIX∶∶TRIANGULAR-MATRIX type}@c
@typesubindex{triangular-matrix}@c
Triangular matrix (either lower or upper).
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deftp


@c --------------------
@c Internal definitions
@c --------------------
@node Internal definitions, , Exported definitions, Definitions
@section Internal definitions
@menu
* Internal macros::
* Internal functions::
* Internal generic functions::
* Internal structures::
* Internal classes::
* Internal types::
@end menu

@node Internal macros, Internal functions, Internal definitions, Internal definitions
@subsection Macros
@deffn {Macro} {@ampchar{}diagonal-matrix} ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX∶∶⅋DIAGONAL-MATRIX macro}@c
@macrosubindex{@ampchar{}diagonal-matrix}@c
LET+ form for slots of the structure DIAGONAL-MATRIX.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {@ampchar{}diagonal-matrix-r/o} ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX∶∶⅋DIAGONAL-MATRIX-R/O macro}@c
@macrosubindex{@ampchar{}diagonal-matrix-r/o}@c
LET+ form for slots of the structure DIAGONAL-MATRIX.  Read-only.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {@ampchar{}sorted-reals} ORDERED-ELEMENTS UNORDERED-ELEMENTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶⅋SORTED-REALS macro}@c
@macrosubindex{@ampchar{}sorted-reals}@c
LET+ form for slots of the structure SORTED-REALS.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {@ampchar{}sorted-reals-r/o} ORDERED-ELEMENTS UNORDERED-ELEMENTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶⅋SORTED-REALS-R/O macro}@c
@macrosubindex{@ampchar{}sorted-reals-r/o}@c
LET+ form for slots of the structure SORTED-REALS.  Read-only.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-central-sample-moment} FUNCTION (VARIABLE DEGREE) &body BODY
@anchor{go to the NUM-UTILS․STATISTICS∶∶DEFINE-CENTRAL-SAMPLE-MOMENT macro}@c
@macrosubindex{define-central-sample-moment}@c
FIXME documentation@comma{} factor out general part
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-comparison} NAME TEST
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶DEFINE-COMPARISON macro}@c
@macrosubindex{define-comparison}@c
Define a comparison@comma{} extendeding a pairwise comparison to an arbitrary number of arguments.
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-e@ampchar{}} OPERATION &key FUNCTION BIVARIATE UNIVARIATE DOCSTRING
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E⅋ macro}@c
@macrosubindex{define-e@ampchar{}}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-e1} OPERATION &key FUNCTION DOCSTRING
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E1 macro}@c
@macrosubindex{define-e1}@c
Define an univariate elementwise operation.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-e2} OPERATION &key FUNCTION DOCSTRING
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-E2 macro}@c
@macrosubindex{define-e2}@c
Define an univariate elementwise operation.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-elementwise-as-array} TYPE &key FUNCTIONS
@anchor{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-AS-ARRAY macro}@c
@macrosubindex{define-elementwise-as-array}@c
Define binary elementwise operations for FUNCTION@comma{} implemented by converting them to arrays.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-elementwise-reduction} NAME FUNCTION &optional DOCSTRING
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶DEFINE-ELEMENTWISE-REDUCTION macro}@c
@macrosubindex{define-elementwise-reduction}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-elementwise-same-class} TYPE &key FUNCTIONS ELEMENTS-ACCESSOR
@anchor{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-SAME-CLASS macro}@c
@macrosubindex{define-elementwise-same-class}@c
Define binary elementwise operations for FUNCTION for two arguments of the same class.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-elementwise-univariate} TYPE &key FUNCTIONS ELEMENTS-ACCESSOR
@anchor{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-UNIVARIATE macro}@c
@macrosubindex{define-elementwise-univariate}@c
Define unary elementwise operations for FUNCTION for all subclasses of wrapped-elements.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-elementwise-with-constant} TYPE &key FUNCTIONS ELEMENTS-ACCESSOR
@anchor{go to the NUM-UTILS․MATRIX∶∶DEFINE-ELEMENTWISE-WITH-CONSTANT macro}@c
@macrosubindex{define-elementwise-with-constant}@c
Define binary elementwise operations for FUNCTION for all subclasses of wrapped-elements.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-rounding-with-offset} NAME FUNCTION DOCSTRING
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶DEFINE-ROUNDING-WITH-OFFSET macro}@c
@macrosubindex{define-rounding-with-offset}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-wrapped-matrix} TYPE ELEMENTS STRUCT-DOCSTRING (MASKED-TEST MASKED-STRING) CHECK-AND-CONVERT-ELEMENTS REGULARIZE-ELEMENTS
@anchor{go to the NUM-UTILS․MATRIX∶∶DEFINE-WRAPPED-MATRIX macro}@c
@macrosubindex{define-wrapped-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {mapping-array} (REF ARRAY &rest OTHER) FORM
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶MAPPING-ARRAY macro}@c
@macrosubindex{mapping-array}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {univariate-rootfinder-loop%} ((F A B FA FB) (F-TESTED TEST-BRACKET DELTA EPSILON)) &body BODY
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶UNIVARIATE-ROOTFINDER-LOOP% macro}@c
@macrosubindex{univariate-rootfinder-loop%}@c
Common parts for univariate rootfinder functions.@*

Sets up the following:@*

- function OPPOSITE-SIGN-P for checking that two numbers are on the opposite side of 0@*

- function EVALUATE-AND-RETURN-IF-WITHIN-EPSILON which checks that |f(x)| <= EPSILON@comma{} if so@comma{} returns from the block with (VALUES X FX T)@comma{} otherwise simply returns the value@*

- function RETURN-IF-WITHIN-TOLERANCE checks if the interval [A@comma{}B] bracketing X is small enough (smaller than TOLERANCE) and if so@comma{} returns (X FX NIL (INTERVAL A B))@*

- variables FA and FB to hold function values at A and B@*

Initially@comma{} it checks for either $f(a)$ or $f(b)$ being a root@comma{} and establishes $a leq b$ by exchanging $a@comma{}f(a)$ and $b@comma{}f(b)$ if necessary.  Also checks that $f(a)$ and $f(b)$ are of opposite sign.  Checks that both tolerance and epsilon are nonnegative.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end deffn

@node Internal functions, Internal generic functions, Internal macros, Internal definitions
@subsection Functions
@deffn {Function} {ab-to-cd-intercept-slope} A B C D
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶AB-TO-CD-INTERCEPT-SLOPE function}@c
@functionsubindex{ab-to-cd-intercept-slope}@c
Return (values INTERCEPT SLOPE) for linear mapping x:-> intercept+slope*x
from [a@comma{}b] to [c@comma{}d].
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ab-to-cinf} Z A B C
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶AB-TO-CINF function}@c
@functionsubindex{ab-to-cinf}@c
Inverse of cinf-to-ab.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {above-diagonal?} ROW COL
@anchor{go to the NUM-UTILS․MATRIX∶∶ABOVE-DIAGONAL? function}@c
@functionsubindex{above-diagonal?}@c
Test if element with indexes row and col is (strictly) above the diagonal.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {below-diagonal?} ROW COL
@anchor{go to the NUM-UTILS․MATRIX∶∶BELOW-DIAGONAL? function}@c
@functionsubindex{below-diagonal?}@c
Test if element with indexes row and col is (strictly) below the diagonal.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {central-sample-moments-m} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-M function}@c
@functionsubindex{central-sample-moments-m}@c
@deffnx {Function} {(setf central-sample-moments-m)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-M❩ function}@c
@functionsubindex{(setf central-sample-moments-m)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {central-sample-moments-p} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-P function}@c
@functionsubindex{central-sample-moments-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {central-sample-moments-s2} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S2 function}@c
@functionsubindex{central-sample-moments-s2}@c
@deffnx {Function} {(setf central-sample-moments-s2)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S2❩ function}@c
@functionsubindex{(setf central-sample-moments-s2)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {central-sample-moments-s3} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S3 function}@c
@functionsubindex{central-sample-moments-s3}@c
@deffnx {Function} {(setf central-sample-moments-s3)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S3❩ function}@c
@functionsubindex{(setf central-sample-moments-s3)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {central-sample-moments-s4} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-S4 function}@c
@functionsubindex{central-sample-moments-s4}@c
@deffnx {Function} {(setf central-sample-moments-s4)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-S4❩ function}@c
@functionsubindex{(setf central-sample-moments-s4)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {central-sample-moments-w} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS-W function}@c
@functionsubindex{central-sample-moments-w}@c
@deffnx {Function} {(setf central-sample-moments-w)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF CENTRAL-SAMPLE-MOMENTS-W❩ function}@c
@functionsubindex{(setf central-sample-moments-w)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {chebyshev-recursion} X VALUE PREVIOUS-VALUE
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-RECURSION function}@c
@functionsubindex{chebyshev-recursion}@c
Chebyshev polynomial recursion formula.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cinf-to-ab} X A B C
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CINF-TO-AB function}@c
@functionsubindex{cinf-to-ab}@c
Map x in [c@comma{}plus-infinity) to z in [a@comma{}b] using x -> (x-c)/(1+x-c)+(b-a)+a.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-central-sample-moments} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶COPY-CENTRAL-SAMPLE-MOMENTS function}@c
@functionsubindex{copy-central-sample-moments}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-diagonal-matrix} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶COPY-DIAGONAL-MATRIX function}@c
@functionsubindex{copy-diagonal-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-hermitian-matrix} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶COPY-HERMITIAN-MATRIX function}@c
@functionsubindex{copy-hermitian-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-iterative-quadrature} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶COPY-ITERATIVE-QUADRATURE function}@c
@functionsubindex{copy-iterative-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lower-triangular-matrix} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶COPY-LOWER-TRIANGULAR-MATRIX function}@c
@functionsubindex{copy-lower-triangular-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-midpoint-quadrature} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶COPY-MIDPOINT-QUADRATURE function}@c
@functionsubindex{copy-midpoint-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-relative} INSTANCE
@anchor{go to the NUM-UTILS․INTERVAL∶∶COPY-RELATIVE function}@c
@functionsubindex{copy-relative}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-richardson-extrapolation} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶COPY-RICHARDSON-EXTRAPOLATION function}@c
@functionsubindex{copy-richardson-extrapolation}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-sorted-reals} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶COPY-SORTED-REALS function}@c
@functionsubindex{copy-sorted-reals}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-spacer} INSTANCE
@anchor{go to the NUM-UTILS․INTERVAL∶∶COPY-SPACER function}@c
@functionsubindex{copy-spacer}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-sparse-counter} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶COPY-SPARSE-COUNTER function}@c
@functionsubindex{copy-sparse-counter}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-tally-mixin} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶COPY-TALLY-MIXIN function}@c
@functionsubindex{copy-tally-mixin}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-test-results} INSTANCE
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶COPY-TEST-RESULTS function}@c
@functionsubindex{copy-test-results}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-trapezoidal-quadrature} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶COPY-TRAPEZOIDAL-QUADRATURE function}@c
@functionsubindex{copy-trapezoidal-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-upper-triangular-matrix} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶COPY-UPPER-TRIANGULAR-MATRIX function}@c
@functionsubindex{copy-upper-triangular-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-wrapped-matrix} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶COPY-WRAPPED-MATRIX function}@c
@functionsubindex{copy-wrapped-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {diagonal-matrix-p} OBJECT
@anchor{go to the NUM-UTILS․MATRIX∶∶DIAGONAL-MATRIX-P function}@c
@functionsubindex{diagonal-matrix-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-valid-elements} ARRAY RANK &rest PREDICATES
@anchor{go to the NUM-UTILS․MATRIX∶∶ENSURE-VALID-ELEMENTS function}@c
@functionsubindex{ensure-valid-elements}@c
Convert OBJECT to an array@comma{} check that it

1. has the required rank@comma{}@*

2. has a valid sparse element type@comma{} and

3. that it satisfies PREDICATES.@*

Return the array.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {extend-pairwise-comparison} TEST FIRST REST
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶EXTEND-PAIRWISE-COMPARISON function}@c
@functionsubindex{extend-pairwise-comparison}@c
Extend TEST (a pairwise comparison) to an arbitrary number of arguments (but at least one@comma{} FIRST).
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hermitian-matrix-elements} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX-ELEMENTS function}@c
@functionsubindex{hermitian-matrix-elements}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hermitian-matrix-p} OBJECT
@anchor{go to the NUM-UTILS․MATRIX∶∶HERMITIAN-MATRIX-P function}@c
@functionsubindex{hermitian-matrix-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {iterative-quadrature-a} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-A function}@c
@functionsubindex{iterative-quadrature-a}@c
@deffnx {Function} {(setf iterative-quadrature-a)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-A❩ function}@c
@functionsubindex{(setf iterative-quadrature-a)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {iterative-quadrature-b} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-B function}@c
@functionsubindex{iterative-quadrature-b}@c
@deffnx {Function} {(setf iterative-quadrature-b)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-B❩ function}@c
@functionsubindex{(setf iterative-quadrature-b)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {iterative-quadrature-f} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-F function}@c
@functionsubindex{iterative-quadrature-f}@c
@deffnx {Function} {(setf iterative-quadrature-f)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-F❩ function}@c
@functionsubindex{(setf iterative-quadrature-f)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {iterative-quadrature-h} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-H function}@c
@functionsubindex{iterative-quadrature-h}@c
@deffnx {Function} {(setf iterative-quadrature-h)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-H❩ function}@c
@functionsubindex{(setf iterative-quadrature-h)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {iterative-quadrature-n} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-N function}@c
@functionsubindex{iterative-quadrature-n}@c
@deffnx {Function} {(setf iterative-quadrature-n)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-N❩ function}@c
@functionsubindex{(setf iterative-quadrature-n)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {iterative-quadrature-p} OBJECT
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-P function}@c
@functionsubindex{iterative-quadrature-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {iterative-quadrature-sum} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-SUM function}@c
@functionsubindex{iterative-quadrature-sum}@c
@deffnx {Function} {(setf iterative-quadrature-sum)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-SUM❩ function}@c
@functionsubindex{(setf iterative-quadrature-sum)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lower-triangular-matrix-elements} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX-ELEMENTS function}@c
@functionsubindex{lower-triangular-matrix-elements}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lower-triangular-matrix-p} OBJECT
@anchor{go to the NUM-UTILS․MATRIX∶∶LOWER-TRIANGULAR-MATRIX-P function}@c
@functionsubindex{lower-triangular-matrix-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-central-sample-moments} &key (W W) (M M) (S2 S2) (S3 S3) (S4 S4)
@anchor{go to the NUM-UTILS․STATISTICS∶∶MAKE-CENTRAL-SAMPLE-MOMENTS function}@c
@functionsubindex{make-central-sample-moments}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-diagonal-matrix} &key (ELEMENTS ELEMENTS)
@anchor{go to the NUM-UTILS․MATRIX∶∶MAKE-DIAGONAL-MATRIX function}@c
@functionsubindex{make-diagonal-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-hermitian-matrix} &key (ELEMENTS ELEMENTS)
@anchor{go to the NUM-UTILS․MATRIX∶∶MAKE-HERMITIAN-MATRIX function}@c
@functionsubindex{make-hermitian-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-iterative-quadrature} &key (F F) (A A) (B B) (H H) (N N) (SUM SUM)
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MAKE-ITERATIVE-QUADRATURE function}@c
@functionsubindex{make-iterative-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-lower-triangular-matrix} &key (ELEMENTS ELEMENTS)
@anchor{go to the NUM-UTILS․MATRIX∶∶MAKE-LOWER-TRIANGULAR-MATRIX function}@c
@functionsubindex{make-lower-triangular-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sorted-reals} &key (ORDERED-ELEMENTS ORDERED-ELEMENTS) (UNORDERED-ELEMENTS UNORDERED-ELEMENTS)
@anchor{go to the NUM-UTILS․STATISTICS∶∶MAKE-SORTED-REALS function}@c
@functionsubindex{make-sorted-reals}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sparse-counter%} &key (TABLE TABLE)
@anchor{go to the NUM-UTILS․STATISTICS∶∶MAKE-SPARSE-COUNTER% function}@c
@functionsubindex{make-sparse-counter%}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-tally-mixin} &key (W W)
@anchor{go to the NUM-UTILS․STATISTICS∶∶MAKE-TALLY-MIXIN function}@c
@functionsubindex{make-tally-mixin}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-test-results} &key (WORST-CASE WORST-CASE) (MIN-ERROR MIN-ERROR) (MAX-ERROR MAX-ERROR) (MEAN-ERROR MEAN-ERROR) (TEST-COUNT TEST-COUNT) (VARIANCE0 VARIANCE0) (VARIANCE1 VARIANCE1) (RMS RMS)
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶MAKE-TEST-RESULTS function}@c
@functionsubindex{make-test-results}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-upper-triangular-matrix} &key (ELEMENTS ELEMENTS)
@anchor{go to the NUM-UTILS․MATRIX∶∶MAKE-UPPER-TRIANGULAR-MATRIX function}@c
@functionsubindex{make-upper-triangular-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-wrapped-matrix} &key (ELEMENTS ELEMENTS)
@anchor{go to the NUM-UTILS․MATRIX∶∶MAKE-WRAPPED-MATRIX function}@c
@functionsubindex{make-wrapped-matrix}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature} F A B
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE function}@c
@functionsubindex{midpoint-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature%} &key (F F) (A A) (B B) (H H) (N N) (SUM SUM)
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE% function}@c
@functionsubindex{midpoint-quadrature%}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-a} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-A function}@c
@functionsubindex{midpoint-quadrature-a}@c
@deffnx {Function} {(setf midpoint-quadrature-a)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-A❩ function}@c
@functionsubindex{(setf midpoint-quadrature-a)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-b} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-B function}@c
@functionsubindex{midpoint-quadrature-b}@c
@deffnx {Function} {(setf midpoint-quadrature-b)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-B❩ function}@c
@functionsubindex{(setf midpoint-quadrature-b)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-f} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-F function}@c
@functionsubindex{midpoint-quadrature-f}@c
@deffnx {Function} {(setf midpoint-quadrature-f)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-F❩ function}@c
@functionsubindex{(setf midpoint-quadrature-f)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-h} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-H function}@c
@functionsubindex{midpoint-quadrature-h}@c
@deffnx {Function} {(setf midpoint-quadrature-h)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-H❩ function}@c
@functionsubindex{(setf midpoint-quadrature-h)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-n} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-N function}@c
@functionsubindex{midpoint-quadrature-n}@c
@deffnx {Function} {(setf midpoint-quadrature-n)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-N❩ function}@c
@functionsubindex{(setf midpoint-quadrature-n)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-p} OBJECT
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-P function}@c
@functionsubindex{midpoint-quadrature-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-sum} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE-SUM function}@c
@functionsubindex{midpoint-quadrature-sum}@c
@deffnx {Function} {(setf midpoint-quadrature-sum)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF MIDPOINT-QUADRATURE-SUM❩ function}@c
@functionsubindex{(setf midpoint-quadrature-sum)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {narrow-bracket?} A B DELTA
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶NARROW-BRACKET? function}@c
@functionsubindex{narrow-bracket?}@c
Return true iff $|a-b| < @backslashchar{}delta$.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end deffn
@deffn {Function} {near-root?} F EPSILON
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶NEAR-ROOT? function}@c
@functionsubindex{near-root?}@c
Return true iff $|f| < @backslashchar{}epsilon$.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end deffn
@deffn {Function} {opposite-sign?} A B
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶OPPOSITE-SIGN? function}@c
@functionsubindex{opposite-sign?}@c
Return true iff A and B are on opposite sides of 0.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pad-left-expansion} ROWS NCOL
@anchor{go to the NUM-UTILS․MATRIX-SHORTHAND∶∶PAD-LEFT-EXPANSION function}@c
@functionsubindex{pad-left-expansion}@c
Pad ragged-right rows.  Used internally to implement ragged right matrix specifications.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX-SHORTHAND package, , @t{num-utils.matrix-shorthand}}
@item Source
@ref{go to the num-utils/matrix-shorthand․lisp file, , @t{matrix-shorthand.lisp}} (file)
@end table
@end deffn
@deffn {Function} {print-matrix-formatter} X
@anchor{go to the NUM-UTILS․PRINT-MATRIX∶∶PRINT-MATRIX-FORMATTER function}@c
@functionsubindex{print-matrix-formatter}@c
Standard formatter for matrix printing.  Respects *print-precision*@comma{} and formats complex numbers as a+bi@comma{} eg 0.0+1.0i.
@table @strong
@item Package
@ref{go to the NUM-UTILS․PRINT-MATRIX package, , @t{num-utils.print-matrix}}
@item Source
@ref{go to the num-utils/print-matrix․lisp file, , @t{print-matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {relative-fraction} INSTANCE
@anchor{go to the NUM-UTILS․INTERVAL∶∶RELATIVE-FRACTION function}@c
@functionsubindex{relative-fraction}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {relative-p} OBJECT
@anchor{go to the NUM-UTILS․INTERVAL∶∶RELATIVE-P function}@c
@functionsubindex{relative-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {richardson-extrapolation} COEFFICIENT ITERATIONS &aux DIAGONAL
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION function}@c
@functionsubindex{richardson-extrapolation}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {richardson-extrapolation-coefficient} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-COEFFICIENT function}@c
@functionsubindex{richardson-extrapolation-coefficient}@c
@deffnx {Function} {(setf richardson-extrapolation-coefficient)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-COEFFICIENT❩ function}@c
@functionsubindex{(setf richardson-extrapolation-coefficient)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {richardson-extrapolation-diagonal} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-DIAGONAL function}@c
@functionsubindex{richardson-extrapolation-diagonal}@c
@deffnx {Function} {(setf richardson-extrapolation-diagonal)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-DIAGONAL❩ function}@c
@functionsubindex{(setf richardson-extrapolation-diagonal)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {richardson-extrapolation-n} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-N function}@c
@functionsubindex{richardson-extrapolation-n}@c
@deffnx {Function} {(setf richardson-extrapolation-n)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-N❩ function}@c
@functionsubindex{(setf richardson-extrapolation-n)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {richardson-extrapolation-p} OBJECT
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-P function}@c
@functionsubindex{richardson-extrapolation-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {richardson-iteration} EXTRAPOLATION STEP
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-ITERATION function}@c
@functionsubindex{richardson-iteration}@c
Add STEP (= $A(h q^@lbracechar{}-k@rbracechar{}$) to an existing Richardson EXTRAPOLATION.  See the documentation of RICHARDSON-EXTRAPOLATION for details.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {romberg-quadrature%} QUADRATURE EPSILON MIN-ITER MAX-ITER
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ROMBERG-QUADRATURE% function}@c
@functionsubindex{romberg-quadrature%}@c
Internal function implementing Romberg quadrature.  Requires an iterative quadrature instance@comma{} a relative EPSILON and MIN-ITER for the stopping criterion@comma{} and the maximum number of iterations allowed.  Works on finite intervals.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {rootfinding-delta} INTERVAL &optional DELTA-RELATIVE
@anchor{go to the NUM-UTILS․ROOTFINDING∶∶ROOTFINDING-DELTA function}@c
@functionsubindex{rootfinding-delta}@c
Default DELTA for rootfinding methods@comma{} uses bracket width.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ROOTFINDING package, , @t{num-utils.rootfinding}}
@item Source
@ref{go to the num-utils/rootfinding․lisp file, , @t{rootfinding.lisp}} (file)
@end table
@end deffn
@deffn {Function} {similar-element-type} ELEMENT-TYPE
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SIMILAR-ELEMENT-TYPE function}@c
@functionsubindex{similar-element-type}@c
Return a type that is a supertype of ELEMENT-TYPE and is closed under arithmetic operations.  May not be the narrowest.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {similar-sequence-type} SEQUENCE
@anchor{go to the NUM-UTILS․ARITHMETIC∶∶SIMILAR-SEQUENCE-TYPE function}@c
@functionsubindex{similar-sequence-type}@c
Return type that sequence can be mapped to using arithmetic operations.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ARITHMETIC package, , @t{num-utils.arithmetic}}
@item Source
@ref{go to the num-utils/arithmetic․lisp file, , @t{arithmetic.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sort-reals} SEQUENCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶SORT-REALS function}@c
@functionsubindex{sort-reals}@c
Return a SORTED-REALS structure.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sorted-reals-ordered-elements} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-ORDERED-ELEMENTS function}@c
@functionsubindex{sorted-reals-ordered-elements}@c
@deffnx {Function} {(setf sorted-reals-ordered-elements)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-ORDERED-ELEMENTS❩ function}@c
@functionsubindex{(setf sorted-reals-ordered-elements)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sorted-reals-p} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-P function}@c
@functionsubindex{sorted-reals-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sorted-reals-unordered-elements} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶SORTED-REALS-UNORDERED-ELEMENTS function}@c
@functionsubindex{sorted-reals-unordered-elements}@c
@deffnx {Function} {(setf sorted-reals-unordered-elements)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF SORTED-REALS-UNORDERED-ELEMENTS❩ function}@c
@functionsubindex{(setf sorted-reals-unordered-elements)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {spacer-p} OBJECT
@anchor{go to the NUM-UTILS․INTERVAL∶∶SPACER-P function}@c
@functionsubindex{spacer-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {spacer-weight} INSTANCE
@anchor{go to the NUM-UTILS․INTERVAL∶∶SPACER-WEIGHT function}@c
@functionsubindex{spacer-weight}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sparse-counter-p} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶SPARSE-COUNTER-P function}@c
@functionsubindex{sparse-counter-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tally-mixin-p} OBJECT
@anchor{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN-P function}@c
@functionsubindex{tally-mixin-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tally-mixin-w} INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN-W function}@c
@functionsubindex{tally-mixin-w}@c
@deffnx {Function} {(setf tally-mixin-w)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․STATISTICS∶∶❨SETF TALLY-MIXIN-W❩ function}@c
@functionsubindex{(setf tally-mixin-w)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {test-results-p} OBJECT
@anchor{go to the NUM-UTILS․TEST-UTILITIES∶∶TEST-RESULTS-P function}@c
@functionsubindex{test-results-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․TEST-UTILITIES package, , @t{num-utils.test-utilities}}
@item Source
@ref{go to the num-utils/test-utilities․lisp file, , @t{test-utilities.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature} F A B
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE function}@c
@functionsubindex{trapezoidal-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature%} &key (F F) (A A) (B B) (H H) (N N) (SUM SUM)
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE% function}@c
@functionsubindex{trapezoidal-quadrature%}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-a} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-A function}@c
@functionsubindex{trapezoidal-quadrature-a}@c
@deffnx {Function} {(setf trapezoidal-quadrature-a)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-A❩ function}@c
@functionsubindex{(setf trapezoidal-quadrature-a)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-b} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-B function}@c
@functionsubindex{trapezoidal-quadrature-b}@c
@deffnx {Function} {(setf trapezoidal-quadrature-b)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-B❩ function}@c
@functionsubindex{(setf trapezoidal-quadrature-b)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-f} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-F function}@c
@functionsubindex{trapezoidal-quadrature-f}@c
@deffnx {Function} {(setf trapezoidal-quadrature-f)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-F❩ function}@c
@functionsubindex{(setf trapezoidal-quadrature-f)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-h} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-H function}@c
@functionsubindex{trapezoidal-quadrature-h}@c
@deffnx {Function} {(setf trapezoidal-quadrature-h)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-H❩ function}@c
@functionsubindex{(setf trapezoidal-quadrature-h)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-n} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-N function}@c
@functionsubindex{trapezoidal-quadrature-n}@c
@deffnx {Function} {(setf trapezoidal-quadrature-n)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-N❩ function}@c
@functionsubindex{(setf trapezoidal-quadrature-n)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-p} OBJECT
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-P function}@c
@functionsubindex{trapezoidal-quadrature-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-sum} INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE-SUM function}@c
@functionsubindex{trapezoidal-quadrature-sum}@c
@deffnx {Function} {(setf trapezoidal-quadrature-sum)} VALUE INSTANCE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶❨SETF TRAPEZOIDAL-QUADRATURE-SUM❩ function}@c
@functionsubindex{(setf trapezoidal-quadrature-sum)}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@end table
@end deffn
@deffn {Function} {upper-triangular-matrix-elements} INSTANCE
@anchor{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX-ELEMENTS function}@c
@functionsubindex{upper-triangular-matrix-elements}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {upper-triangular-matrix-p} OBJECT
@anchor{go to the NUM-UTILS․MATRIX∶∶UPPER-TRIANGULAR-MATRIX-P function}@c
@functionsubindex{upper-triangular-matrix-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {valid-sparse-type?} TYPE
@anchor{go to the NUM-UTILS․MATRIX∶∶VALID-SPARSE-TYPE? function}@c
@functionsubindex{valid-sparse-type?}@c
Check if TYPE is a valid type for sparse matrices.  Only supertypes and subtypes of NUMBER are allowed.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {weighted-empirical-quantile} SORTED-REALS P-TABLE Q
@anchor{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-EMPIRICAL-QUANTILE function}@c
@functionsubindex{weighted-empirical-quantile}@c
Return the empirical quantile of a vector of real numbers@comma{} sorted in ascending order (not checked).  Uses a 0.5 correction.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {weighted-quantile-p-table} WEIGHTS
@anchor{go to the NUM-UTILS․STATISTICS∶∶WEIGHTED-QUANTILE-P-TABLE function}@c
@functionsubindex{weighted-quantile-p-table}@c
Return table of probability brackets for weighted quantile calculations.@comma{} built from the weights (which should be positive reals@comma{} not checked).  Uses a 0.5 correction.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrapped-matrix-p} OBJECT
@anchor{go to the NUM-UTILS․MATRIX∶∶WRAPPED-MATRIX-P function}@c
@functionsubindex{wrapped-matrix-p}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn
@deffn {Function} {zero-like} ARRAY
@anchor{go to the NUM-UTILS․MATRIX∶∶ZERO-LIKE function}@c
@functionsubindex{zero-like}@c
Return 0 coerced to the element type of ARRAY.  It is assumed that the latter satisfies VALID-SPARSE-TYPE?.
@table @strong
@item Package
@ref{go to the NUM-UTILS․MATRIX package, , @t{num-utils.matrix}}
@item Source
@ref{go to the num-utils/matrix․lisp file, , @t{matrix.lisp}} (file)
@end table
@end deffn

@node Internal generic functions, Internal structures, Internal functions, Internal definitions
@subsection Generic functions
@deffn {Generic Function} {chebyshev-approximate-implementation} F INTERVAL N-POLYNOMIALS N-POINTS
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION generic function}@c
@genericsubindex{chebyshev-approximate-implementation}@c
Implementation of CHEBYSHEV-APPROXIMATE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․CHEBYSHEV package, , @t{num-utils.chebyshev}}
@item Source
@ref{go to the num-utils/chebyshev․lisp file, , @t{chebyshev.lisp}} (file)
@item Methods
@deffn {Method} {chebyshev-approximate-implementation} F (INTERVAL @t{plusinf-interval}) N-POLYNOMIALS N-POINTS
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method}@c
@methodsubindex{chebyshev-approximate-implementation}@c
@end deffn
@deffn {Method} {chebyshev-approximate-implementation} F (INTERVAL @t{finite-interval}) N-POLYNOMIALS N-POINTS
@anchor{go to the NUM-UTILS․CHEBYSHEV∶∶CHEBYSHEV-APPROXIMATE-IMPLEMENTATION COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶T COMMON-LISP∶∶T method}@c
@methodsubindex{chebyshev-approximate-implementation}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {esquare} A
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE generic function}@c
@genericsubindex{esquare}@c
Univariate elementwise SQUARE.
@table @strong
@item Package
@ref{go to the NUM-UTILS․ELEMENTWISE package, , @t{num-utils.elementwise}}
@item Source
@ref{go to the num-utils/elementwise․lisp file, , @t{elementwise.lisp}} (file)
@item Methods
@deffn {Method} {esquare} (A @t{number})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE COMMON-LISP∶∶NUMBER method}@c
@methodsubindex{esquare}@c
@end deffn
@deffn {Method} {esquare} (A @t{array})
@anchor{go to the NUM-UTILS․ELEMENTWISE∶∶ESQUARE COMMON-LISP∶∶ARRAY method}@c
@methodsubindex{esquare}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pool2} ACCUMULATOR1 ACCUMULATOR2
@anchor{go to the NUM-UTILS․STATISTICS∶∶POOL2 generic function}@c
@genericsubindex{pool2}@c
Pool two accumulators.  When they are of a different type@comma{} the resulting accumulator will be downgraded to the level afforded by the information available in the accumulators.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Methods
@deffn {Method} {pool2} (MOMENTS-A @t{central-sample-moments}) (MOMENTS-B @t{central-sample-moments})
@anchor{go to the NUM-UTILS․STATISTICS∶∶POOL2 NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS method}@c
@methodsubindex{pool2}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {print-left-endpoint} INTERVAL STREAM
@anchor{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT generic function}@c
@genericsubindex{print-left-endpoint}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {print-left-endpoint} (INTERVAL @t{interval/finite-left}) STREAM
@anchor{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT COMMON-LISP∶∶T method}@c
@methodsubindex{print-left-endpoint}@c
@end deffn
@deffn {Method} {print-left-endpoint} (INTERVAL @t{interval/infinite-left}) STREAM
@anchor{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT COMMON-LISP∶∶T method}@c
@methodsubindex{print-left-endpoint}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {print-right-endpoint} INTERVAL STREAM
@anchor{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT generic function}@c
@genericsubindex{print-right-endpoint}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Methods
@deffn {Method} {print-right-endpoint} (INTERVAL @t{interval/finite-right}) STREAM
@anchor{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT COMMON-LISP∶∶T method}@c
@methodsubindex{print-right-endpoint}@c
@end deffn
@deffn {Method} {print-right-endpoint} (INTERVAL @t{interval/infinite-right}) STREAM
@anchor{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT COMMON-LISP∶∶T method}@c
@methodsubindex{print-right-endpoint}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {refine-quadrature} QUADRATURE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE generic function}@c
@genericsubindex{refine-quadrature}@c
Refine quadrature with more points.  Return the sum for those points.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Methods
@deffn {Method} {refine-quadrature} (QUADRATURE @t{midpoint-quadrature})
@anchor{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method}@c
@methodsubindex{refine-quadrature}@c
@end deffn
@deffn {Method} {refine-quadrature} (QUADRATURE @t{trapezoidal-quadrature})
@anchor{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method}@c
@methodsubindex{refine-quadrature}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {richardson-coefficient} QUADRATURE
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT generic function}@c
@genericsubindex{richardson-coefficient}@c
Return the coefficient $q$ for Richardson approximation.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Methods
@deffn {Method} {richardson-coefficient} (QUADRATURE @t{midpoint-quadrature})
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method}@c
@methodsubindex{richardson-coefficient}@c
@end deffn
@deffn {Method} {richardson-coefficient} (QUADRATURE @t{trapezoidal-quadrature})
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method}@c
@methodsubindex{richardson-coefficient}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {transformed-quadrature} FUNCTION INTERVAL TRANSFORMATION
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE generic function}@c
@genericsubindex{transformed-quadrature}@c
Return a quadrature for integrating FUNCTION on INTERVAL@comma{} which may be infinite@comma{} in which case FUNCTION will be transformed.  TRANSFORMATION can be used to select the transformation when applicable@comma{} otherwise it is NIL.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Methods
@deffn {Method} {transformed-quadrature} FUNCTION (INTERVAL @t{finite-interval}) (TRANSFORMATION @t{null})
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL COMMON-LISP∶∶NULL method}@c
@methodsubindex{transformed-quadrature}@c
@end deffn
@deffn {Method} {transformed-quadrature} FUNCTION (INTERVAL @t{plusinf-interval}) (TRANSFORMATION @t{null})
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRANSFORMED-QUADRATURE COMMON-LISP∶∶T NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL COMMON-LISP∶∶NULL method}@c
@methodsubindex{transformed-quadrature}@c
@end deffn
@end table
@end deffn

@node Internal structures, Internal classes, Internal generic functions, Internal definitions
@subsection Structures
@deftp {Structure} {iterative-quadrature} ()
@anchor{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE structure}@c
@structuresubindex{iterative-quadrature}@c
Quadrature building block.

F is the function.@*

A and B are the endpoints.

H is the stepsize.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE structure, , @t{trapezoidal-quadrature}} (structure)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE structure, , @t{midpoint-quadrature}} (structure)
@end itemize
@item Direct slots
@defvr {Slot} f
@slotsubindex{f}@c
@table @strong
@item Type
@t{(function (double-float) double-float)}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-F function, , @t{iterative-quadrature-f}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-F❩ function, , @t{(setf iterative-quadrature-f)}} (function)
@end table
@end defvr
@defvr {Slot} a
@slotsubindex{a}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-A function, , @t{iterative-quadrature-a}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-A❩ function, , @t{(setf iterative-quadrature-a)}} (function)
@end table
@end defvr
@defvr {Slot} b
@slotsubindex{b}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-B function, , @t{iterative-quadrature-b}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-B❩ function, , @t{(setf iterative-quadrature-b)}} (function)
@end table
@end defvr
@defvr {Slot} h
@slotsubindex{h}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-H function, , @t{iterative-quadrature-h}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-H❩ function, , @t{(setf iterative-quadrature-h)}} (function)
@end table
@end defvr
@defvr {Slot} n
@slotsubindex{n}@c
@table @strong
@item Type
@t{fixnum}
@item Initform
@t{0}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-N function, , @t{iterative-quadrature-n}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-N❩ function, , @t{(setf iterative-quadrature-n)}} (function)
@end table
@end defvr
@defvr {Slot} sum
@slotsubindex{sum}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE-SUM function, , @t{iterative-quadrature-sum}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF ITERATIVE-QUADRATURE-SUM❩ function, , @t{(setf iterative-quadrature-sum)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {midpoint-quadrature} ()
@anchor{go to the NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE structure}@c
@structuresubindex{midpoint-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Direct superclasses
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE structure, , @t{iterative-quadrature}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method, , @t{richardson-coefficient}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶MIDPOINT-QUADRATURE method, , @t{refine-quadrature}} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {richardson-extrapolation} ()
@anchor{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION structure}@c
@structuresubindex{richardson-extrapolation}@c
Given A(h)=A_0 + sum_@lbracechar{}k=1@rbracechar{}^infty a_k h^@lbracechar{}kp@rbracechar{}@comma{} calculate approximations for A given A(h q^@lbracechar{}-k@rbracechar{})@comma{} where the latter can be incorporated using RICHARDSON-ITERATION with consecutive values for k=1@comma{}...@comma{}max_iter@comma{} which returns the latest A(0) as the first and the largest relative change@comma{} which can be used to test termination.

The algorithm uses Richardson extrapolation@comma{} the required coefficient is q^k.
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} coefficient
@slotsubindex{coefficient}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-COEFFICIENT function, , @t{richardson-extrapolation-coefficient}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-COEFFICIENT❩ function, , @t{(setf richardson-extrapolation-coefficient)}} (function)
@end table
@end defvr
@defvr {Slot} n
@slotsubindex{n}@c
@table @strong
@item Type
@t{fixnum}
@item Initform
@t{0}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-N function, , @t{richardson-extrapolation-n}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-N❩ function, , @t{(setf richardson-extrapolation-n)}} (function)
@end table
@end defvr
@defvr {Slot} diagonal
@slotsubindex{diagonal}@c
@table @strong
@item Type
@t{(array double-float (*))}
@item Readers
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-EXTRAPOLATION-DIAGONAL function, , @t{richardson-extrapolation-diagonal}} (function)
@item Writers
@ref{go to the NUM-UTILS․QUADRATURE∶∶❨SETF RICHARDSON-EXTRAPOLATION-DIAGONAL❩ function, , @t{(setf richardson-extrapolation-diagonal)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {tally-mixin} ()
@anchor{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN structure}@c
@structuresubindex{tally-mixin}@c
Mixin structure that contains a tally.  Not exported.  W is the total weight.
@table @strong
@item Package
@ref{go to the NUM-UTILS․STATISTICS package, , @t{num-utils.statistics}}
@item Source
@ref{go to the num-utils/statistics․lisp file, , @t{statistics.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct subclasses
@ref{go to the NUM-UTILS․STATISTICS∶∶CENTRAL-SAMPLE-MOMENTS structure, , @t{central-sample-moments}} (structure)
@item Direct methods
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY NUM-UTILS․STATISTICS∶∶TALLY-MIXIN method, , @t{tally}} (method)
@item Direct slots
@defvr {Slot} w
@slotsubindex{w}@c
@table @strong
@item Type
@t{(real 0)}
@item Initform
@t{0}
@item Readers
@ref{go to the NUM-UTILS․STATISTICS∶∶TALLY-MIXIN-W function, , @t{tally-mixin-w}} (function)
@item Writers
@ref{go to the NUM-UTILS․STATISTICS∶∶❨SETF TALLY-MIXIN-W❩ function, , @t{(setf tally-mixin-w)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {trapezoidal-quadrature} ()
@anchor{go to the NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE structure}@c
@structuresubindex{trapezoidal-quadrature}@c
@table @strong
@item Package
@ref{go to the NUM-UTILS․QUADRATURE package, , @t{num-utils.quadrature}}
@item Source
@ref{go to the num-utils/quadrature․lisp file, , @t{quadrature.lisp}} (file)
@item Direct superclasses
@ref{go to the NUM-UTILS․QUADRATURE∶∶ITERATIVE-QUADRATURE structure, , @t{iterative-quadrature}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶RICHARDSON-COEFFICIENT NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method, , @t{richardson-coefficient}} (method)
@item
@ref{go to the NUM-UTILS․QUADRATURE∶∶REFINE-QUADRATURE NUM-UTILS․QUADRATURE∶∶TRAPEZOIDAL-QUADRATURE method, , @t{refine-quadrature}} (method)
@end itemize
@end table
@end deftp

@node Internal classes, Internal types, Internal structures, Internal definitions
@subsection Classes
@deftp {Class} {interval/finite-left} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT class}@c
@classsubindex{interval/finite-left}@c
Interval with left endpoint.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@t{standard-object} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL class, , @t{finite-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL class, , @t{plusinf-interval}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT COMMON-LISP∶∶T method, , @t{print-left-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method, , @t{open-left?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-LEFT method, , @t{left}} (method)
@end itemize
@item Direct slots
@defvr {Slot} left
@slotsubindex{left}@c
@table @strong
@item Type
@t{real}
@item Initargs
@t{:left}
@item Readers
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT generic function, , @t{left}} (generic function)
@end table
@end defvr
@defvr {Slot} open-left?
@slotsubindex{open-left?}@c
@table @strong
@item Type
@t{boolean}
@item Initargs
@t{:open-left?}
@item Readers
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? generic function, , @t{open-left?}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} {interval/finite-right} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT class}@c
@classsubindex{interval/finite-right}@c
Interval with right endpoint.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@t{standard-object} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶FINITE-INTERVAL class, , @t{finite-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶MINUSINF-INTERVAL class, , @t{minusinf-interval}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT COMMON-LISP∶∶T method, , @t{print-right-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method, , @t{open-right?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/FINITE-RIGHT method, , @t{right}} (method)
@end itemize
@item Direct slots
@defvr {Slot} right
@slotsubindex{right}@c
@table @strong
@item Type
@t{real}
@item Initargs
@t{:right}
@item Readers
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT generic function, , @t{right}} (generic function)
@end table
@end defvr
@defvr {Slot} open-right?
@slotsubindex{open-right?}@c
@table @strong
@item Type
@t{boolean}
@item Initargs
@t{:open-right?}
@item Readers
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? generic function, , @t{open-right?}} (generic function)
@end table
@end defvr
@end table
@end deftp
@deftp {Class} {interval/infinite-left} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT class}@c
@classsubindex{interval/infinite-left}@c
Left endpoint is -∞.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@t{standard-object} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶MINUSINF-INTERVAL class, , @t{minusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶REAL-LINE class, , @t{real-line}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-LEFT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT COMMON-LISP∶∶T method, , @t{print-left-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-LEFT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method, , @t{open-left?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶LEFT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-LEFT method, , @t{left}} (method)
@end itemize
@end table
@end deftp
@deftp {Class} {interval/infinite-right} ()
@anchor{go to the NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT class}@c
@classsubindex{interval/infinite-right}@c
Right endpoint is ∞.
@table @strong
@item Package
@ref{go to the NUM-UTILS․INTERVAL package, , @t{num-utils.interval}}
@item Source
@ref{go to the num-utils/interval․lisp file, , @t{interval.lisp}} (file)
@item Direct superclasses
@t{standard-object} (class)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PLUSINF-INTERVAL class, , @t{plusinf-interval}} (class)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶REAL-LINE class, , @t{real-line}} (class)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶PRINT-RIGHT-ENDPOINT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT COMMON-LISP∶∶T method, , @t{print-right-endpoint}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶OPEN-RIGHT? NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method, , @t{open-right?}} (method)
@item
@ref{go to the NUM-UTILS․INTERVAL∶∶RIGHT NUM-UTILS․INTERVAL∶∶INTERVAL/INFINITE-RIGHT method, , @t{right}} (method)
@end itemize
@end table
@end deftp

@node Internal types, , Internal classes, Internal definitions
@subsection Types
@deftp {Type} {infinite} ()
@anchor{go to the NUM-UTILS․EXTENDED-REAL∶∶INFINITE type}@c
@typesubindex{infinite}@c
Representing infinity (extending the real line).
@table @strong
@item Package
@ref{go to the NUM-UTILS․EXTENDED-REAL package, , @t{num-utils.extended-real}}
@item Source
@ref{go to the num-utils/extended-real․lisp file, , @t{extended-real.lisp}} (file)
@end table
@end deftp



@c ====================================================================
@c Indexes
@c ====================================================================
@node Indexes, , Definitions, Top
@appendix Indexes
@menu
* Concept index::
* Function index::
* Variable index::
* Data type index::
@end menu


@c -------------
@c Concept index
@c -------------
@node Concept index, Function index, Indexes, Indexes
@appendixsec Concepts
@printindex cp

@page


@c --------------
@c Function index
@c --------------
@node Function index, Variable index, Concept index, Indexes
@appendixsec Functions
@printindex fn

@page


@c --------------
@c Variable index
@c --------------
@node Variable index, Data type index, Function index, Indexes
@appendixsec Variables
@printindex vr

@page


@c ---------------
@c Data type index
@c ---------------
@node Data type index, , Variable index, Indexes
@appendixsec Data types
@printindex tp

@bye

@c num-utils.texi ends here
