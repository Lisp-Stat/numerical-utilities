\input texinfo

@c num-utils.texi --- Reference manual

@c Copyright (C) 2019-2022 Steven Nunez

@c This file is part of NUM-UTILS.

@c This program is distributed under the terms of the Microsoft Public
@c License.


@c Commentary:

@c Generated automatically by Declt version 4.0 beta 2 "William Riker"
@c on Mon Sep 05 14:50:58 2022 GMT+8.


@c ====================================================================
@c Header
@c ====================================================================
@c %**start of header
@setfilename num-utils.info
@settitle The NUM-UTILS Reference Manual
@afourpaper
@documentencoding UTF-8
@c %**end of header



@c ====================================================================
@c Format Specific Tweaks
@c ====================================================================
@tex
%% Declt uses several Unicode characters to "reveal" blanks. This
%% works fine in HTML or Info output, but TeX will have problems with
%% these. The code below translates those characters to something that
%% TeX can handle.

%% U+23B5 (Bottom Square Bracket), used to reveal white spaces, is
%% translated to its Computer Modern teletype version.
\DeclareUnicodeCharacter{23B5}{{\tt\char'040}}

%% U+21B5 (Downwards Arrow With Corner Leftwards), used to reveal
%% carriage returns, is translated to \hookleftarrow in math mode.
\DeclareUnicodeCharacter{21B5}{\ensuremath\hookleftarrow}

%% U+21E5 (Rightwards Arrow To Bar), used to reveal tabs, is
%% translated to something that looks similar, based on a rightarrow
%% and a vertical bar from the math extension font.
\DeclareUnicodeCharacter{21E5}{%
  \ensuremath{\rightarrow\kern-.5em\mathchar\"130C}}


%% Declt uses several Unicode characters to replace "fragile" ones in
%% anchor names and references. These characters are chosen to resemble
%% the original ones, without interfering with Info syntax. In TeX
%% however, we can switch them back to the original versions, because
%% cross-references are done differently. In theory, I think we could do
%% something similar for HTML output (again, only the Info syntax poses
%% problems), but I don't know how to do something similar to what's
%% below.

%% U+2024 (One Dot Leader) replaces periods.
\DeclareUnicodeCharacter{2024}{.}

%% U+2236 (Ratio) replaces colons.
\DeclareUnicodeCharacter{2236}{:}

%% U+2768 (Medium Left Parenthesis Ornament) replaces left parenthesis.
\DeclareUnicodeCharacter{2768}{(}

%% U+2769 (Medium Right Parenthesis Ornament) replaces right parenthesis.
\DeclareUnicodeCharacter{2769}{)}

%% U+214B (Turned Ampersand) replaces ampersands.
\DeclareUnicodeCharacter{214B}{&}

%% U+2216 (Set Minus) replaces backslashes.
\DeclareUnicodeCharacter{2216}{\char"5C}

%% The following ones are already defined in texinfo.tex so we have nothing
%% more to do:
%% U+201A (Single Low-9 Quotation Mark) replaces commas.
%% U+2205 (Empty Set) replaces empty symbol names.

@end tex



@c ====================================================================
@c Settings
@c ====================================================================
@setchapternewpage odd
@documentdescription
The NUM-UTILS Reference Manual, version 1.1.0.
@end documentdescription



@c ====================================================================
@c New Commands
@c ====================================================================

@c ---------------
@c Indexing macros
@c ---------------

@c Packages
@macro packageindex{name}
@tpindex \name\
@tpindex @r{Package, }\name\
@end macro

@c Systems
@macro systemindex{name}
@tpindex \name\
@tpindex @r{System, }\name\
@end macro

@c Modules
@macro moduleindex{name}
@tpindex @t{\name\}
@tpindex Module, @t{\name\}
@end macro

@c Files
@macro fileindex{name}
@tpindex @t{\name\}
@tpindex File, @t{\name\}
@end macro

@c The following macros are meant to be used within @defxxx environments.
@c Texinfo performs half the indexing job and we do the other half.

@c Constants
@macro constantsubindex{name}
@vindex @r{Constant, }\name\
@end macro

@c Special variables
@macro specialsubindex{name}
@vindex @r{Special Variable, }\name\
@end macro

@c Symbol macros
@macro symbolmacrosubindex{name}
@vindex @r{Symbol Macro, }\name\
@end macro

@c Slots
@macro slotsubindex{name}
@vindex @r{Slot, }\name\
@end macro

@c Macros
@macro macrosubindex{name}
@findex @r{Macro, }\name\
@end macro

@c Compiler Macros
@macro compilermacrosubindex{name}
@findex @r{Compiler Macro, }\name\
@end macro

@c Functions
@macro functionsubindex{name}
@findex @r{Function, }\name\
@end macro

@c Methods
@macro methodsubindex{name}
@findex @r{Method, }\name\
@end macro

@c Generic Functions
@macro genericsubindex{name}
@findex @r{Generic Function, }\name\
@end macro

@c Setf Expanders
@macro expandersubindex{name}
@findex @r{Setf Expander, }\name\
@end macro

@c Method Combinations
@macro combinationsubindex{name}
@findex @r{Method Combination, }\name\
@end macro

@c Conditions
@macro conditionsubindex{name}
@tpindex @r{Condition, }\name\
@end macro

@c Structures
@macro structuresubindex{name}
@tpindex @r{Structure, }\name\
@end macro

@c Types
@macro typesubindex{name}
@tpindex @r{Type, }\name\
@end macro

@c Classes
@macro classsubindex{name}
@tpindex @r{Class, }\name\
@end macro



@c ====================================================================
@c Info Category and Directory
@c ====================================================================
@dircategory Common Lisp
@direntry
* NUM-UTILS Reference Manual: (num-utils). The NUM-UTILS Reference Manual.
@end direntry



@c ====================================================================
@c Copying
@c ====================================================================
@copying
@quotation
Copyright @copyright{} 2019-2022 Steven Nunez

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``Copying'' is included exactly as in the original.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be translated as well.
@end quotation
@end copying



@c ====================================================================
@c Title Page
@c ====================================================================
@titlepage
@title The NUM-UTILS Reference Manual
@subtitle Numerical Utilities, version 1.1.0

@author Steven Nunez <@email{steve@atchar{}symbolics.tech}>

@page
@quotation
This manual was generated automatically by Declt 4.0b2.
@end quotation
@vskip 0pt plus 1filll
@insertcopying
@end titlepage



@c ====================================================================
@c Table of Contents
@c ====================================================================
@contents



@c ====================================================================
@c Top
@c ====================================================================
@ifnottex
@node Top, Copying, (dir), (dir)
@top The NUM-UTILS Reference Manual
This is the NUM-UTILS Reference Manual, version 1.1.0,
generated automatically by Declt version 4.0b2.

@menu
* Copying:: The Microsoft Public License
* Systems:: The systems documentation
* Files:: The files documentation
* Packages:: The packages documentation
* Definitions:: The symbols documentation
* Indexes:: Concepts, functions, variables and data types
@end menu

@insertcopying
@end ifnottex



@c ====================================================================
@c Copying
@c ====================================================================
@node Copying, Systems, Top, Top
@unnumbered Copying
@quotation
This program is distributed under the terms of the Microsoft Public
License.
@end quotation



@c ====================================================================
@c Systems
@c ====================================================================
@node Systems, Files, Copying, Top
@chapter Systems
The main system appears first, followed by any subsystem dependency.

@menu
* The num-utils system::
@end menu


@c --------------------
@c The num-utils system
@c --------------------
@node The num-utils system, , Systems, Systems
@section @t{num-utils}
@anchor{❨1❩}@c
@systemindex{num-utils}@c
Numerical utilities for Common Lisp
@table @strong
@item Long Name
Numerical Utilities
@item Author
Steven Nunez <@email{steve@atchar{}symbolics.tech}>
@item Source Control
@t{(GIT https://github.com/Lisp-Stat/numerical-utilities.git)}
@item Bug Tracker
@uref{https://github.com/Lisp-Stat/numerical-utilities/issues}
@item License
MS-PL
@item Long Description
This library implements simple numerical functions for Common Lisp@comma{} including

    num=@comma{} a comparison operator for floats@*
    simple arithmeric functions@comma{} like sum and l2norm@*
    elementwise operations for arrays@*
    intervals@*
    special matrices and shorthand for their input@*
    sample statistics@*
    Chebyshev polynomials@*
    univariate rootfinding
@item Version
1.1.0
@item Dependencies
@itemize @bullet
@item
@t{anaphora}@: (system).
@item
@t{alexandria}@: (system).
@item
@t{array-operations}@: (system).
@item
@t{select}@: (system).
@item
@t{let-plus}@: (system).
@end itemize
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Child Components
@itemize @bullet
@item
@ref{❨3❩, , @t{packages.lisp}}@: (file).
@item
@ref{❨4❩, , @t{utilities.lisp}}@: (file).
@item
@ref{❨5❩, , @t{num=.lisp}}@: (file).
@item
@ref{❨6❩, , @t{arithmetic.lisp}}@: (file).
@item
@ref{❨7❩, , @t{elementwise.lisp}}@: (file).
@item
@ref{❨8❩, , @t{extended-real.lisp}}@: (file).
@item
@ref{❨9❩, , @t{interval.lisp}}@: (file).
@item
@ref{❨10❩, , @t{print-matrix.lisp}}@: (file).
@item
@ref{❨11❩, , @t{matrix.lisp}}@: (file).
@item
@ref{❨12❩, , @t{matrix-shorthand.lisp}}@: (file).
@item
@ref{❨13❩, , @t{chebyshev.lisp}}@: (file).
@item
@ref{❨14❩, , @t{polynomial.lisp}}@: (file).
@item
@ref{❨15❩, , @t{rootfinding.lisp}}@: (file).
@item
@ref{❨16❩, , @t{quadrature.lisp}}@: (file).
@item
@ref{❨17❩, , @t{log-exp.lisp}}@: (file).
@item
@ref{❨18❩, , @t{test-utilities.lisp}}@: (file).
@item
@ref{❨19❩, , @t{pkgdcl.lisp}}@: (file).
@end itemize
@end table



@c ====================================================================
@c Files
@c ====================================================================
@node Files, Packages, Systems, Top
@chapter Files
Files are sorted by type and then listed depth-first from the systems
components trees.

@menu
* Lisp files::
@end menu


@c ----------
@c Lisp files
@c ----------
@node Lisp files, , Files, Files
@section Lisp
@menu
* The num-utils/num-utils․asd file::
* The num-utils/packages․lisp file::
* The num-utils/utilities․lisp file::
* The num-utils/num=․lisp file::
* The num-utils/arithmetic․lisp file::
* The num-utils/elementwise․lisp file::
* The num-utils/extended-real․lisp file::
* The num-utils/interval․lisp file::
* The num-utils/print-matrix․lisp file::
* The num-utils/matrix․lisp file::
* The num-utils/matrix-shorthand․lisp file::
* The num-utils/chebyshev․lisp file::
* The num-utils/polynomial․lisp file::
* The num-utils/rootfinding․lisp file::
* The num-utils/quadrature․lisp file::
* The num-utils/log-exp․lisp file::
* The num-utils/test-utilities․lisp file::
* The num-utils/pkgdcl․lisp file::
@end menu

@node The num-utils/num-utils․asd file, The num-utils/packages․lisp file, Lisp files, Lisp files
@subsection @t{num-utils/num-utils.asd}
@anchor{❨2❩}@c
@fileindex{num-utils.asd}@c
@table @strong
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item ASDF Systems
@ref{❨1❩, , @t{num-utils}}.
@end table

@node The num-utils/packages․lisp file, The num-utils/utilities․lisp file, The num-utils/num-utils․asd file, Lisp files
@subsection @t{num-utils/packages.lisp}
@anchor{❨3❩}@c
@fileindex{packages.lisp}@c
@table @strong
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Packages
@itemize @bullet
@item
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item
@ref{❨21❩, , @t{num-utils.print-matrix}}.
@item
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item
@ref{❨23❩, , @t{num-utils.interval}}.
@item
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item
@ref{❨26❩, , @t{num-utils.matrix}}.
@item
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@item
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item
@ref{❨32❩, , @t{num-utils.num=}}.
@item
@ref{❨33❩, , @t{num-utils.polynomial}}.
@item
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@end itemize
@end table

@node The num-utils/utilities․lisp file, The num-utils/num=․lisp file, The num-utils/packages․lisp file, Lisp files
@subsection @t{num-utils/utilities.lisp}
@anchor{❨4❩}@c
@fileindex{utilities.lisp}@c
@table @strong
@item Dependency
@ref{❨3❩, , @t{packages.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨287❩, , @t{as-alist}}@: (generic function).
@item
@ref{❨310❩, , @t{as-bit-vector}}@: (function).
@item
@ref{❨308❩, , @t{as-double-float}}@: (function).
@item
@ref{❨303❩, , @t{as-plist}}@: (generic function).
@item
@ref{❨300❩, , @t{as-simple-fixnum-vector}}@: (function).
@item
@ref{❨286❩, , @t{bic}}@: (function).
@item
@ref{❨292❩, , @t{binary-search}}@: (function).
@item
@ref{❨290❩, , @t{check-types}}@: (macro).
@item
@ref{❨301❩, , @t{curry*}}@: (macro).
@item
@ref{❨293❩, , @t{define-with-multiple-bindings}}@: (macro).
@item
@ref{❨302❩, , @t{expanding}}@: (macro).
@item
@ref{❨298❩, , @t{fixnum?}}@: (function).
@item
@ref{❨307❩, , @t{generate-sequence}}@: (function).
@item
@ref{❨299❩, , @t{gethash*}}@: (macro).
@item
@ref{❨288❩, , @t{make-vector}}@: (compiler macro).
@item
@ref{❨289❩, , @t{make-vector}}@: (function).
@item
@ref{❨297❩, , @t{simple-boolean-vector}}@: (type).
@item
@ref{❨295❩, , @t{simple-double-float-vector}}@: (type).
@item
@ref{❨294❩, , @t{simple-fixnum-vector}}@: (type).
@item
@ref{❨305❩, , @t{simple-single-float-vector}}@: (type).
@item
@ref{❨309❩, , @t{splice-awhen}}@: (macro).
@item
@ref{❨306❩, , @t{splice-when}}@: (macro).
@item
@ref{❨291❩, , @t{with-double-floats}}@: (macro).
@item
@ref{❨296❩, , @t{within?}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨312❩, , @t{boolean-sequence-p}}@: (function).
@item
@ref{❨311❩, , @t{boolean?}}@: (function).
@end itemize
@end table

@node The num-utils/num=․lisp file, The num-utils/arithmetic․lisp file, The num-utils/utilities․lisp file, Lisp files
@subsection @t{num-utils/num=.lisp}
@anchor{❨5❩}@c
@fileindex{num=.lisp}@c
@table @strong
@item Dependency
@ref{❨4❩, , @t{utilities.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨552❩, , @t{*num=-tolerance*}}@: (special variable).
@item
@ref{❨539❩, , @t{define-num=-with-accessors}}@: (macro).
@item
@ref{❨538❩, , @t{define-structure-num=}}@: (macro).
@item
@ref{❨540❩, , @t{num-delta}}@: (function).
@item
@ref{❨541❩, , @t{num=}}@: (generic function).
@item
@ref{❨551❩, , @t{num=-function}}@: (function).
@end itemize
@end table

@node The num-utils/arithmetic․lisp file, The num-utils/elementwise․lisp file, The num-utils/num=․lisp file, Lisp files
@subsection @t{num-utils/arithmetic.lisp}
@anchor{❨6❩}@c
@fileindex{arithmetic.lisp}@c
@table @strong
@item Dependency
@ref{❨5❩, , @t{num=.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨369❩, , @t{1c}}@: (function).
@item
@ref{❨346❩, , @t{abs-diff}}@: (function).
@item
@ref{❨352❩, , @t{absolute-square}}@: (function).
@item
@ref{❨364❩, , @t{as-integer}}@: (function).
@item
@ref{❨371❩, , @t{ceiling*}}@: (function).
@item
@ref{❨368❩, , @t{cube}}@: (function).
@item
@ref{❨367❩, , @t{cumulative-product}}@: (function).
@item
@ref{❨370❩, , @t{cumulative-sum}}@: (function).
@item
@ref{❨366❩, , @t{divides?}}@: (function).
@item
@ref{❨355❩, , @t{floor*}}@: (function).
@item
@ref{❨363❩, , @t{ivec}}@: (function).
@item
@ref{❨362❩, , @t{l2norm}}@: (function).
@item
@ref{❨344❩, , @t{l2norm-square}}@: (generic function).
@item
@ref{❨372❩, , @t{log10}}@: (function).
@item
@ref{❨365❩, , @t{log2}}@: (function).
@item
@ref{❨350❩, , @t{normalize-probabilities}}@: (function).
@item
@ref{❨373❩, , @t{numseq}}@: (function).
@item
@ref{❨357❩, , @t{product}}@: (generic function).
@item
@ref{❨360❩, , @t{round*}}@: (function).
@item
@ref{❨361❩, , @t{same-sign-p}}@: (function).
@item
@ref{❨351❩, , @t{sequence-maximum}}@: (function).
@item
@ref{❨354❩, , @t{sequence-minimum}}@: (function).
@item
@ref{❨356❩, , @t{square}}@: (function).
@item
@ref{❨347❩, , @t{sum}}@: (generic function).
@item
@ref{❨353❩, , @t{truncate*}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨377❩, , @t{define-rounding-with-offset}}@: (macro).
@item
@ref{❨376❩, , @t{ln}}@: (function).
@item
@ref{❨375❩, , @t{similar-element-type}}@: (function).
@item
@ref{❨374❩, , @t{similar-sequence-type}}@: (function).
@end itemize
@end table

@node The num-utils/elementwise․lisp file, The num-utils/extended-real․lisp file, The num-utils/arithmetic․lisp file, Lisp files
@subsection @t{num-utils/elementwise.lisp}
@anchor{❨7❩}@c
@fileindex{elementwise.lisp}@c
@table @strong
@item Dependency
@ref{❨6❩, , @t{arithmetic.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨404❩, , @t{e*}}@: (function).
@item
@ref{❨505❩, , @t{e+}}@: (function).
@item
@ref{❨506❩, , @t{e-}}@: (function).
@item
@ref{❨399❩, , @t{e/}}@: (function).
@item
@ref{❨385❩, , @t{e1-}}@: (generic function).
@item
@ref{❨378❩, , @t{e1/}}@: (generic function).
@item
@ref{❨454❩, , @t{e1log}}@: (generic function).
@item
@ref{❨475❩, , @t{e2*}}@: (generic function).
@item
@ref{❨461❩, , @t{e2+}}@: (generic function).
@item
@ref{❨516❩, , @t{e2-}}@: (generic function).
@item
@ref{❨423❩, , @t{e2/}}@: (generic function).
@item
@ref{❨497❩, , @t{e2log}}@: (generic function).
@item
@ref{❨393❩, , @t{eceiling}}@: (generic function).
@item
@ref{❨451❩, , @t{econjugate}}@: (generic function).
@item
@ref{❨396❩, , @t{ecos}}@: (generic function).
@item
@ref{❨441❩, , @t{eexp}}@: (generic function).
@item
@ref{❨415❩, , @t{eexpt}}@: (generic function).
@item
@ref{❨448❩, , @t{efloor}}@: (generic function).
@item
@ref{❨440❩, , @t{elementwise-float-contagion}}@: (function).
@item
@ref{❨392❩, , @t{elog}}@: (function).
@item
@ref{❨515❩, , @t{emax}}@: (function).
@item
@ref{❨439❩, , @t{emin}}@: (function).
@item
@ref{❨507❩, , @t{emod}}@: (generic function).
@item
@ref{❨400❩, , @t{ereduce}}@: (generic function).
@item
@ref{❨405❩, , @t{esin}}@: (generic function).
@item
@ref{❨408❩, , @t{esqrt}}@: (generic function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨535❩, , @t{define-e@ampchar{}}}@: (macro).
@item
@ref{❨534❩, , @t{define-e1}}@: (macro).
@item
@ref{❨530❩, , @t{define-e2}}@: (macro).
@item
@ref{❨536❩, , @t{define-elementwise-reduction}}@: (macro).
@item
@ref{❨531❩, , @t{esquare}}@: (generic function).
@item
@ref{❨537❩, , @t{mapping-array}}@: (macro).
@end itemize
@end table

@node The num-utils/extended-real․lisp file, The num-utils/interval․lisp file, The num-utils/elementwise․lisp file, Lisp files
@subsection @t{num-utils/extended-real.lisp}
@anchor{❨8❩}@c
@fileindex{extended-real.lisp}@c
@table @strong
@item Dependency
@ref{❨7❩, , @t{elementwise.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨281❩, , @t{<}}@: (function).
@item
@ref{❨274❩, , @t{<=}}@: (function).
@item
@ref{❨282❩, , @t{=}}@: (function).
@item
@ref{❨277❩, , @t{>}}@: (function).
@item
@ref{❨280❩, , @t{>=}}@: (function).
@item
@ref{❨278❩, , @t{extended-real}}@: (type).
@item
@ref{❨276❩, , @t{infinite?}}@: (function).
@item
@ref{❨275❩, , @t{lambda-template}}@: (macro).
@item
@ref{❨279❩, , @t{with-template}}@: (macro).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨285❩, , @t{define-comparison}}@: (macro).
@item
@ref{❨284❩, , @t{extend-pairwise-comparison}}@: (function).
@item
@ref{❨283❩, , @t{infinite}}@: (type).
@end itemize
@end table

@node The num-utils/interval․lisp file, The num-utils/print-matrix․lisp file, The num-utils/extended-real․lisp file, Lisp files
@subsection @t{num-utils/interval.lisp}
@anchor{❨9❩}@c
@fileindex{interval.lisp}@c
@table @strong
@item Dependency
@ref{❨8❩, , @t{extended-real.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨153❩, , @t{@ampchar{}interval}}@: (macro).
@item
@ref{❨138❩, , @t{extend-interval}}@: (generic function).
@item
@ref{❨134❩, , @t{extendf-interval}}@: (macro).
@item
@ref{❨172❩, , @t{finite-interval}}@: (class).
@item
@ref{❨152❩, , @t{grid-in}}@: (function).
@item
@ref{❨133❩, , @t{in-interval?}}@: (function).
@item
@ref{❨588❩, , @t{initialize-instance}}@: (method).
@item
@ref{❨169❩, , @t{interval}}@: (function).
@item
@ref{❨170❩, , @t{interval}}@: (class).
@item
@ref{❨167❩, , @t{interval-hull}}@: (function).
@item
@ref{❨151❩, , @t{interval-length}}@: (function).
@item
@ref{❨176❩, , @t{interval-midpoint}}@: (function).
@item
@ref{❨155❩, , @t{left}}@: (generic function).
@item
@ref{❨171❩, , @t{minusinf-interval}}@: (class).
@item
@ref{❨544❩, , @t{num=}}@: (method).
@item
@ref{❨545❩, , @t{num=}}@: (method).
@item
@ref{❨135❩, , @t{open-left?}}@: (generic function).
@item
@ref{❨173❩, , @t{open-right?}}@: (generic function).
@item
@ref{❨150❩, , @t{plusinf-interval}}@: (class).
@item
@ref{❨168❩, , @t{plusminus-interval}}@: (function).
@item
@ref{❨587❩, , @t{print-object}}@: (method).
@item
@ref{❨148❩, , @t{real-line}}@: (class).
@item
@ref{❨159❩, , @t{relative}}@: (function).
@item
@ref{❨160❩, , @t{relative}}@: (structure).
@item
@ref{❨164❩, , @t{right}}@: (generic function).
@item
@ref{❨162❩, , @t{shift-interval}}@: (generic function).
@item
@ref{❨158❩, , @t{shrink-interval}}@: (function).
@item
@ref{❨145❩, , @t{spacer}}@: (function).
@item
@ref{❨146❩, , @t{spacer}}@: (structure).
@item
@ref{❨154❩, , @t{split-interval}}@: (function).
@item
@ref{❨149❩, , @t{subintervals-in}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨195❩, , @t{copy-relative}}@: (function).
@item
@ref{❨186❩, , @t{copy-spacer}}@: (function).
@item
@ref{❨190❩, , @t{interval/finite-left}}@: (class).
@item
@ref{❨187❩, , @t{interval/finite-right}}@: (class).
@item
@ref{❨182❩, , @t{interval/infinite-left}}@: (class).
@item
@ref{❨196❩, , @t{interval/infinite-right}}@: (class).
@item
@ref{❨183❩, , @t{print-left-endpoint}}@: (generic function).
@item
@ref{❨179❩, , @t{print-right-endpoint}}@: (generic function).
@item
@ref{❨178❩, , @t{relative-fraction}}@: (reader).
@item
@ref{❨193❩, , @t{relative-p}}@: (function).
@item
@ref{❨177❩, , @t{spacer-p}}@: (function).
@item
@ref{❨194❩, , @t{spacer-weight}}@: (reader).
@end itemize
@end table

@node The num-utils/print-matrix․lisp file, The num-utils/matrix․lisp file, The num-utils/interval․lisp file, Lisp files
@subsection @t{num-utils/print-matrix.lisp}
@anchor{❨10❩}@c
@fileindex{print-matrix.lisp}@c
@table @strong
@item Dependency
@ref{❨9❩, , @t{interval.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨117❩, , @t{*print-matrix-precision*}}@: (special variable).
@item
@ref{❨119❩, , @t{print-length-truncate}}@: (function).
@item
@ref{❨118❩, , @t{print-matrix}}@: (function).
@end itemize
@item Internals
@ref{❨120❩, , @t{print-matrix-formatter}}@: (function).
@end table

@node The num-utils/matrix․lisp file, The num-utils/matrix-shorthand․lisp file, The num-utils/print-matrix․lisp file, Lisp files
@subsection @t{num-utils/matrix.lisp}
@anchor{❨11❩}@c
@fileindex{matrix.lisp}@c
@table @strong
@item Dependency
@ref{❨10❩, , @t{print-matrix.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨591❩, , @t{as-array}}@: (method).
@item
@ref{❨594❩, , @t{as-array}}@: (method).
@item
@ref{❨600❩, , @t{as-array}}@: (method).
@item
@ref{❨603❩, , @t{as-array}}@: (method).
@item
@ref{❨235❩, , @t{diagonal-matrix}}@: (function).
@item
@ref{❨236❩, , @t{diagonal-matrix}}@: (structure).
@item
@ref{❨231❩, , @t{diagonal-matrix-elements}}@: (reader).
@item
@ref{❨232❩, , @t{(setf diagonal-matrix-elements)}}@: (writer).
@item
@ref{❨223❩, , @t{diagonal-vector}}@: (generic function).
@item
@ref{❨226❩, , @t{(setf diagonal-vector)}}@: (generic function).
@item
@ref{❨596❩, , @t{dims}}@: (method).
@item
@ref{❨601❩, , @t{dims}}@: (method).
@item
@ref{❨386❩, , @t{e1-}}@: (method).
@item
@ref{❨387❩, , @t{e1-}}@: (method).
@item
@ref{❨388❩, , @t{e1-}}@: (method).
@item
@ref{❨389❩, , @t{e1-}}@: (method).
@item
@ref{❨379❩, , @t{e1/}}@: (method).
@item
@ref{❨380❩, , @t{e1/}}@: (method).
@item
@ref{❨381❩, , @t{e1/}}@: (method).
@item
@ref{❨382❩, , @t{e1/}}@: (method).
@item
@ref{❨455❩, , @t{e1log}}@: (method).
@item
@ref{❨456❩, , @t{e1log}}@: (method).
@item
@ref{❨457❩, , @t{e1log}}@: (method).
@item
@ref{❨458❩, , @t{e1log}}@: (method).
@item
@ref{❨476❩, , @t{e2*}}@: (method).
@item
@ref{❨477❩, , @t{e2*}}@: (method).
@item
@ref{❨478❩, , @t{e2*}}@: (method).
@item
@ref{❨479❩, , @t{e2*}}@: (method).
@item
@ref{❨480❩, , @t{e2*}}@: (method).
@item
@ref{❨481❩, , @t{e2*}}@: (method).
@item
@ref{❨482❩, , @t{e2*}}@: (method).
@item
@ref{❨483❩, , @t{e2*}}@: (method).
@item
@ref{❨484❩, , @t{e2*}}@: (method).
@item
@ref{❨485❩, , @t{e2*}}@: (method).
@item
@ref{❨486❩, , @t{e2*}}@: (method).
@item
@ref{❨487❩, , @t{e2*}}@: (method).
@item
@ref{❨488❩, , @t{e2*}}@: (method).
@item
@ref{❨489❩, , @t{e2*}}@: (method).
@item
@ref{❨462❩, , @t{e2+}}@: (method).
@item
@ref{❨463❩, , @t{e2+}}@: (method).
@item
@ref{❨464❩, , @t{e2+}}@: (method).
@item
@ref{❨465❩, , @t{e2+}}@: (method).
@item
@ref{❨466❩, , @t{e2+}}@: (method).
@item
@ref{❨467❩, , @t{e2+}}@: (method).
@item
@ref{❨517❩, , @t{e2-}}@: (method).
@item
@ref{❨518❩, , @t{e2-}}@: (method).
@item
@ref{❨519❩, , @t{e2-}}@: (method).
@item
@ref{❨520❩, , @t{e2-}}@: (method).
@item
@ref{❨521❩, , @t{e2-}}@: (method).
@item
@ref{❨522❩, , @t{e2-}}@: (method).
@item
@ref{❨424❩, , @t{e2/}}@: (method).
@item
@ref{❨425❩, , @t{e2/}}@: (method).
@item
@ref{❨426❩, , @t{e2/}}@: (method).
@item
@ref{❨427❩, , @t{e2/}}@: (method).
@item
@ref{❨428❩, , @t{e2/}}@: (method).
@item
@ref{❨429❩, , @t{e2/}}@: (method).
@item
@ref{❨430❩, , @t{e2/}}@: (method).
@item
@ref{❨431❩, , @t{e2/}}@: (method).
@item
@ref{❨442❩, , @t{eexp}}@: (method).
@item
@ref{❨443❩, , @t{eexp}}@: (method).
@item
@ref{❨444❩, , @t{eexp}}@: (method).
@item
@ref{❨445❩, , @t{eexp}}@: (method).
@item
@ref{❨597❩, , @t{element-type}}@: (method).
@item
@ref{❨602❩, , @t{element-type}}@: (method).
@item
@ref{❨409❩, , @t{esqrt}}@: (method).
@item
@ref{❨410❩, , @t{esqrt}}@: (method).
@item
@ref{❨411❩, , @t{esqrt}}@: (method).
@item
@ref{❨412❩, , @t{esqrt}}@: (method).
@item
@ref{❨221❩, , @t{hermitian-matrix}}@: (function).
@item
@ref{❨222❩, , @t{hermitian-matrix}}@: (structure).
@item
@ref{❨233❩, , @t{lower-triangular-matrix}}@: (function).
@item
@ref{❨234❩, , @t{lower-triangular-matrix}}@: (structure).
@item
@ref{❨220❩, , @t{map-array}}@: (method).
@item
@ref{❨542❩, , @t{num=}}@: (method).
@item
@ref{❨543❩, , @t{num=}}@: (method).
@item
@ref{❨590❩, , @t{print-object}}@: (method).
@item
@ref{❨593❩, , @t{print-object}}@: (method).
@item
@ref{❨599❩, , @t{print-object}}@: (method).
@item
@ref{❨589❩, , @t{select}}@: (method).
@item
@ref{❨592❩, , @t{select}}@: (method).
@item
@ref{❨598❩, , @t{select}}@: (method).
@item
@ref{❨238❩, , @t{transpose}}@: (generic function).
@item
@ref{❨216❩, , @t{triangular-matrix}}@: (type).
@item
@ref{❨217❩, , @t{upper-triangular-matrix}}@: (function).
@item
@ref{❨218❩, , @t{upper-triangular-matrix}}@: (structure).
@item
@ref{❨228❩, , @t{wrapped-matrix}}@: (structure).
@item
@ref{❨230❩, , @t{wrapped-matrix-elements}}@: (reader).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨250❩, , @t{@ampchar{}diagonal-matrix}}@: (macro).
@item
@ref{❨264❩, , @t{@ampchar{}diagonal-matrix-r/o}}@: (macro).
@item
@ref{❨260❩, , @t{above-diagonal?}}@: (function).
@item
@ref{❨256❩, , @t{below-diagonal?}}@: (function).
@item
@ref{❨258❩, , @t{copy-diagonal-matrix}}@: (function).
@item
@ref{❨265❩, , @t{copy-hermitian-matrix}}@: (function).
@item
@ref{❨244❩, , @t{copy-lower-triangular-matrix}}@: (function).
@item
@ref{❨269❩, , @t{copy-upper-triangular-matrix}}@: (function).
@item
@ref{❨262❩, , @t{copy-wrapped-matrix}}@: (function).
@item
@ref{❨257❩, , @t{define-elementwise-as-array}}@: (macro).
@item
@ref{❨261❩, , @t{define-elementwise-same-class}}@: (macro).
@item
@ref{❨251❩, , @t{define-elementwise-univariate}}@: (macro).
@item
@ref{❨248❩, , @t{define-elementwise-with-constant}}@: (macro).
@item
@ref{❨268❩, , @t{define-wrapped-matrix}}@: (macro).
@item
@ref{❨247❩, , @t{diagonal-matrix-p}}@: (function).
@item
@ref{❨273❩, , @t{ensure-valid-elements}}@: (function).
@item
@ref{❨249❩, , @t{hermitian-matrix-elements}}@: (function).
@item
@ref{❨253❩, , @t{hermitian-matrix-p}}@: (function).
@item
@ref{❨254❩, , @t{lower-triangular-matrix-elements}}@: (function).
@item
@ref{❨259❩, , @t{lower-triangular-matrix-p}}@: (function).
@item
@ref{❨245❩, , @t{make-diagonal-matrix}}@: (function).
@item
@ref{❨266❩, , @t{make-hermitian-matrix}}@: (function).
@item
@ref{❨272❩, , @t{make-lower-triangular-matrix}}@: (function).
@item
@ref{❨271❩, , @t{make-upper-triangular-matrix}}@: (function).
@item
@ref{❨252❩, , @t{make-wrapped-matrix}}@: (function).
@item
@ref{❨246❩, , @t{upper-triangular-matrix-elements}}@: (function).
@item
@ref{❨267❩, , @t{upper-triangular-matrix-p}}@: (function).
@item
@ref{❨255❩, , @t{valid-sparse-type?}}@: (function).
@item
@ref{❨263❩, , @t{wrapped-matrix-p}}@: (function).
@item
@ref{❨270❩, , @t{zero-like}}@: (function).
@end itemize
@end table

@node The num-utils/matrix-shorthand․lisp file, The num-utils/chebyshev․lisp file, The num-utils/matrix․lisp file, Lisp files
@subsection @t{num-utils/matrix-shorthand.lisp}
@anchor{❨12❩}@c
@fileindex{matrix-shorthand.lisp}@c
@table @strong
@item Dependency
@ref{❨11❩, , @t{matrix.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨197❩, , @t{diagonal-mx}}@: (function).
@item
@ref{❨201❩, , @t{hermitian-mx}}@: (macro).
@item
@ref{❨200❩, , @t{lower-triangular-mx}}@: (macro).
@item
@ref{❨202❩, , @t{mx}}@: (macro).
@item
@ref{❨198❩, , @t{upper-triangular-mx}}@: (macro).
@item
@ref{❨199❩, , @t{vec}}@: (function).
@end itemize
@item Internals
@ref{❨203❩, , @t{pad-left-expansion}}@: (function).
@end table

@node The num-utils/chebyshev․lisp file, The num-utils/polynomial․lisp file, The num-utils/matrix-shorthand․lisp file, Lisp files
@subsection @t{num-utils/chebyshev.lisp}
@anchor{❨13❩}@c
@fileindex{chebyshev.lisp}@c
@table @strong
@item Dependency
@ref{❨12❩, , @t{matrix-shorthand.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨121❩, , @t{chebyshev-approximate}}@: (function).
@item
@ref{❨123❩, , @t{chebyshev-regression}}@: (function).
@item
@ref{❨122❩, , @t{chebyshev-root}}@: (function).
@item
@ref{❨124❩, , @t{chebyshev-roots}}@: (function).
@item
@ref{❨125❩, , @t{evaluate-chebyshev}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨132❩, , @t{ab-to-cd-intercept-slope}}@: (function).
@item
@ref{❨130❩, , @t{ab-to-cinf}}@: (function).
@item
@ref{❨126❩, , @t{chebyshev-approximate-implementation}}@: (generic function).
@item
@ref{❨131❩, , @t{chebyshev-recursion}}@: (function).
@item
@ref{❨129❩, , @t{cinf-to-ab}}@: (function).
@end itemize
@end table

@node The num-utils/polynomial․lisp file, The num-utils/rootfinding․lisp file, The num-utils/chebyshev․lisp file, Lisp files
@subsection @t{num-utils/polynomial.lisp}
@anchor{❨14❩}@c
@fileindex{polynomial.lisp}@c
@table @strong
@item Dependency
@ref{❨13❩, , @t{chebyshev.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨554❩, , @t{evaluate-polynomial}}@: (function).
@item
@ref{❨553❩, , @t{evaluate-rational}}@: (function).
@end itemize
@end table

@node The num-utils/rootfinding․lisp file, The num-utils/quadrature․lisp file, The num-utils/polynomial․lisp file, Lisp files
@subsection @t{num-utils/rootfinding.lisp}
@anchor{❨15❩}@c
@fileindex{rootfinding.lisp}@c
@table @strong
@item Dependency
@ref{❨14❩, , @t{polynomial.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨557❩, , @t{*rootfinding-delta-relative*}}@: (special variable).
@item
@ref{❨555❩, , @t{*rootfinding-epsilon*}}@: (special variable).
@item
@ref{❨556❩, , @t{root-bisection}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨562❩, , @t{narrow-bracket?}}@: (function).
@item
@ref{❨560❩, , @t{near-root?}}@: (function).
@item
@ref{❨561❩, , @t{opposite-sign?}}@: (function).
@item
@ref{❨559❩, , @t{rootfinding-delta}}@: (function).
@item
@ref{❨558❩, , @t{univariate-rootfinder-loop%}}@: (macro).
@end itemize
@end table

@node The num-utils/quadrature․lisp file, The num-utils/log-exp․lisp file, The num-utils/rootfinding․lisp file, Lisp files
@subsection @t{num-utils/quadrature.lisp}
@anchor{❨16❩}@c
@fileindex{quadrature.lisp}@c
@table @strong
@item Dependency
@ref{❨15❩, , @t{rootfinding.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@ref{❨36❩, , @t{romberg-quadrature}}@: (function).
@item Internals
@itemize @bullet
@item
@ref{❨38❩, , @t{copy-iterative-quadrature}}@: (function).
@item
@ref{❨56❩, , @t{copy-midpoint-quadrature}}@: (function).
@item
@ref{❨83❩, , @t{copy-richardson-extrapolation}}@: (function).
@item
@ref{❨78❩, , @t{copy-trapezoidal-quadrature}}@: (function).
@item
@ref{❨98❩, , @t{iterative-quadrature}}@: (structure).
@item
@ref{❨41❩, , @t{iterative-quadrature-a}}@: (reader).
@item
@ref{❨42❩, , @t{(setf iterative-quadrature-a)}}@: (writer).
@item
@ref{❨91❩, , @t{iterative-quadrature-b}}@: (reader).
@item
@ref{❨92❩, , @t{(setf iterative-quadrature-b)}}@: (writer).
@item
@ref{❨76❩, , @t{iterative-quadrature-f}}@: (reader).
@item
@ref{❨77❩, , @t{(setf iterative-quadrature-f)}}@: (writer).
@item
@ref{❨89❩, , @t{iterative-quadrature-h}}@: (reader).
@item
@ref{❨90❩, , @t{(setf iterative-quadrature-h)}}@: (writer).
@item
@ref{❨111❩, , @t{iterative-quadrature-n}}@: (reader).
@item
@ref{❨112❩, , @t{(setf iterative-quadrature-n)}}@: (writer).
@item
@ref{❨113❩, , @t{iterative-quadrature-p}}@: (function).
@item
@ref{❨66❩, , @t{iterative-quadrature-sum}}@: (reader).
@item
@ref{❨67❩, , @t{(setf iterative-quadrature-sum)}}@: (writer).
@item
@ref{❨57❩, , @t{make-iterative-quadrature}}@: (function).
@item
@ref{❨85❩, , @t{midpoint-quadrature}}@: (function).
@item
@ref{❨86❩, , @t{midpoint-quadrature}}@: (structure).
@item
@ref{❨88❩, , @t{midpoint-quadrature%}}@: (function).
@item
@ref{❨74❩, , @t{midpoint-quadrature-a}}@: (function).
@item
@ref{❨75❩, , @t{(setf midpoint-quadrature-a)}}@: (function).
@item
@ref{❨43❩, , @t{midpoint-quadrature-b}}@: (function).
@item
@ref{❨44❩, , @t{(setf midpoint-quadrature-b)}}@: (function).
@item
@ref{❨47❩, , @t{midpoint-quadrature-f}}@: (function).
@item
@ref{❨48❩, , @t{(setf midpoint-quadrature-f)}}@: (function).
@item
@ref{❨39❩, , @t{midpoint-quadrature-h}}@: (function).
@item
@ref{❨40❩, , @t{(setf midpoint-quadrature-h)}}@: (function).
@item
@ref{❨49❩, , @t{midpoint-quadrature-n}}@: (function).
@item
@ref{❨50❩, , @t{(setf midpoint-quadrature-n)}}@: (function).
@item
@ref{❨110❩, , @t{midpoint-quadrature-p}}@: (function).
@item
@ref{❨105❩, , @t{midpoint-quadrature-sum}}@: (function).
@item
@ref{❨106❩, , @t{(setf midpoint-quadrature-sum)}}@: (function).
@item
@ref{❨114❩, , @t{refine-quadrature}}@: (generic function).
@item
@ref{❨107❩, , @t{richardson-coefficient}}@: (generic function).
@item
@ref{❨93❩, , @t{richardson-extrapolation}}@: (function).
@item
@ref{❨94❩, , @t{richardson-extrapolation}}@: (structure).
@item
@ref{❨64❩, , @t{richardson-extrapolation-coefficient}}@: (reader).
@item
@ref{❨65❩, , @t{(setf richardson-extrapolation-coefficient)}}@: (writer).
@item
@ref{❨79❩, , @t{richardson-extrapolation-diagonal}}@: (reader).
@item
@ref{❨80❩, , @t{(setf richardson-extrapolation-diagonal)}}@: (writer).
@item
@ref{❨62❩, , @t{richardson-extrapolation-n}}@: (reader).
@item
@ref{❨63❩, , @t{(setf richardson-extrapolation-n)}}@: (writer).
@item
@ref{❨61❩, , @t{richardson-extrapolation-p}}@: (function).
@item
@ref{❨84❩, , @t{richardson-iteration}}@: (function).
@item
@ref{❨87❩, , @t{romberg-quadrature%}}@: (function).
@item
@ref{❨51❩, , @t{transformed-quadrature}}@: (generic function).
@item
@ref{❨58❩, , @t{trapezoidal-quadrature}}@: (function).
@item
@ref{❨59❩, , @t{trapezoidal-quadrature}}@: (structure).
@item
@ref{❨37❩, , @t{trapezoidal-quadrature%}}@: (function).
@item
@ref{❨81❩, , @t{trapezoidal-quadrature-a}}@: (function).
@item
@ref{❨82❩, , @t{(setf trapezoidal-quadrature-a)}}@: (function).
@item
@ref{❨45❩, , @t{trapezoidal-quadrature-b}}@: (function).
@item
@ref{❨46❩, , @t{(setf trapezoidal-quadrature-b)}}@: (function).
@item
@ref{❨70❩, , @t{trapezoidal-quadrature-f}}@: (function).
@item
@ref{❨71❩, , @t{(setf trapezoidal-quadrature-f)}}@: (function).
@item
@ref{❨72❩, , @t{trapezoidal-quadrature-h}}@: (function).
@item
@ref{❨73❩, , @t{(setf trapezoidal-quadrature-h)}}@: (function).
@item
@ref{❨68❩, , @t{trapezoidal-quadrature-n}}@: (function).
@item
@ref{❨69❩, , @t{(setf trapezoidal-quadrature-n)}}@: (function).
@item
@ref{❨60❩, , @t{trapezoidal-quadrature-p}}@: (function).
@item
@ref{❨54❩, , @t{trapezoidal-quadrature-sum}}@: (function).
@item
@ref{❨55❩, , @t{(setf trapezoidal-quadrature-sum)}}@: (function).
@end itemize
@end table

@node The num-utils/log-exp․lisp file, The num-utils/test-utilities․lisp file, The num-utils/quadrature․lisp file, Lisp files
@subsection @t{num-utils/log-exp.lisp}
@anchor{❨17❩}@c
@fileindex{log-exp.lisp}@c
@table @strong
@item Dependency
@ref{❨16❩, , @t{quadrature.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨204❩, , @t{exp-1}}@: (function).
@item
@ref{❨215❩, , @t{exp-1/x}}@: (function).
@item
@ref{❨214❩, , @t{expt-1}}@: (function).
@item
@ref{❨213❩, , @t{hypot}}@: (function).
@item
@ref{❨205❩, , @t{log1+}}@: (function).
@item
@ref{❨208❩, , @t{log1+/x}}@: (function).
@item
@ref{❨207❩, , @t{log1+exp}}@: (function).
@item
@ref{❨206❩, , @t{log1-}}@: (function).
@item
@ref{❨210❩, , @t{log1-exp}}@: (function).
@item
@ref{❨209❩, , @t{log1pmx}}@: (function).
@item
@ref{❨212❩, , @t{log2-exp}}@: (function).
@item
@ref{❨211❩, , @t{logexp-1}}@: (function).
@end itemize
@end table

@node The num-utils/test-utilities․lisp file, The num-utils/pkgdcl․lisp file, The num-utils/log-exp․lisp file, Lisp files
@subsection @t{num-utils/test-utilities.lisp}
@anchor{❨18❩}@c
@fileindex{test-utilities.lisp}@c
@table @strong
@item Dependency
@ref{❨17❩, , @t{log-exp.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Public Interface
@itemize @bullet
@item
@ref{❨334❩, , @t{compare-fns}}@: (function).
@item
@ref{❨333❩, , @t{compare-vectors}}@: (function).
@item
@ref{❨329❩, , @t{max-error}}@: (reader).
@item
@ref{❨330❩, , @t{(setf max-error)}}@: (writer).
@item
@ref{❨327❩, , @t{mean-error}}@: (reader).
@item
@ref{❨328❩, , @t{(setf mean-error)}}@: (writer).
@item
@ref{❨316❩, , @t{min-error}}@: (reader).
@item
@ref{❨317❩, , @t{(setf min-error)}}@: (writer).
@item
@ref{❨339❩, , @t{rms}}@: (reader).
@item
@ref{❨340❩, , @t{(setf rms)}}@: (writer).
@item
@ref{❨335❩, , @t{test-count}}@: (reader).
@item
@ref{❨336❩, , @t{(setf test-count)}}@: (writer).
@item
@ref{❨315❩, , @t{test-fn}}@: (function).
@item
@ref{❨318❩, , @t{test-results}}@: (structure).
@item
@ref{❨331❩, , @t{variance0}}@: (reader).
@item
@ref{❨332❩, , @t{(setf variance0)}}@: (writer).
@item
@ref{❨313❩, , @t{variance1}}@: (reader).
@item
@ref{❨314❩, , @t{(setf variance1)}}@: (writer).
@item
@ref{❨337❩, , @t{worst-case}}@: (reader).
@item
@ref{❨338❩, , @t{(setf worst-case)}}@: (writer).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨341❩, , @t{copy-test-results}}@: (function).
@item
@ref{❨342❩, , @t{make-test-results}}@: (function).
@item
@ref{❨343❩, , @t{test-results-p}}@: (function).
@end itemize
@end table

@node The num-utils/pkgdcl․lisp file, , The num-utils/test-utilities․lisp file, Lisp files
@subsection @t{num-utils/pkgdcl.lisp}
@anchor{❨19❩}@c
@fileindex{pkgdcl.lisp}@c
@table @strong
@item Dependency
@ref{❨18❩, , @t{test-utilities.lisp}}@: (file).
@item Source
@ref{❨2❩, , @t{num-utils.asd}}.
@item Parent Component
@ref{❨1❩, , @t{num-utils}}@: (system).
@item Packages
@ref{❨34❩, , @t{num-utils}}.
@end table



@c ====================================================================
@c Packages
@c ====================================================================
@node Packages, Definitions, Files, Top
@chapter Packages
Packages are listed by definition order.

@menu
* The num-utils․quadrature package::
* The num-utils․print-matrix package::
* The num-utils․chebyshev package::
* The num-utils․interval package::
* The num-utils․matrix-shorthand package::
* The num-utils․log-exp package::
* The num-utils․matrix package::
* The num-utils․extended-real package::
* The num-utils․utilities package::
* The num-utils․test-utilities package::
* The num-utils․arithmetic package::
* The num-utils․elementwise package::
* The num-utils․num= package::
* The num-utils․polynomial package::
* The num-utils package::
* The num-utils․rootfinding package::
@end menu


@c --------------------------------
@c The num-utils.quadrature package
@c --------------------------------
@node The num-utils․quadrature package, The num-utils․print-matrix package, Packages, Packages
@section @t{num-utils.quadrature}
@anchor{❨20❩}@c
@packageindex{num-utils.quadrature}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{alexandria+}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item
@ref{❨23❩, , @t{num-utils.interval}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Used By List
@ref{❨34❩, , @t{num-utils}}.
@item Public Interface
@ref{❨36❩, , @t{romberg-quadrature}}@: (function).
@item Internals
@itemize @bullet
@item
@ref{❨38❩, , @t{copy-iterative-quadrature}}@: (function).
@item
@ref{❨56❩, , @t{copy-midpoint-quadrature}}@: (function).
@item
@ref{❨83❩, , @t{copy-richardson-extrapolation}}@: (function).
@item
@ref{❨78❩, , @t{copy-trapezoidal-quadrature}}@: (function).
@item
@ref{❨98❩, , @t{iterative-quadrature}}@: (structure).
@item
@ref{❨41❩, , @t{iterative-quadrature-a}}@: (reader).
@item
@ref{❨42❩, , @t{(setf iterative-quadrature-a)}}@: (writer).
@item
@ref{❨91❩, , @t{iterative-quadrature-b}}@: (reader).
@item
@ref{❨92❩, , @t{(setf iterative-quadrature-b)}}@: (writer).
@item
@ref{❨76❩, , @t{iterative-quadrature-f}}@: (reader).
@item
@ref{❨77❩, , @t{(setf iterative-quadrature-f)}}@: (writer).
@item
@ref{❨89❩, , @t{iterative-quadrature-h}}@: (reader).
@item
@ref{❨90❩, , @t{(setf iterative-quadrature-h)}}@: (writer).
@item
@ref{❨111❩, , @t{iterative-quadrature-n}}@: (reader).
@item
@ref{❨112❩, , @t{(setf iterative-quadrature-n)}}@: (writer).
@item
@ref{❨113❩, , @t{iterative-quadrature-p}}@: (function).
@item
@ref{❨66❩, , @t{iterative-quadrature-sum}}@: (reader).
@item
@ref{❨67❩, , @t{(setf iterative-quadrature-sum)}}@: (writer).
@item
@ref{❨57❩, , @t{make-iterative-quadrature}}@: (function).
@item
@ref{❨85❩, , @t{midpoint-quadrature}}@: (function).
@item
@ref{❨86❩, , @t{midpoint-quadrature}}@: (structure).
@item
@ref{❨88❩, , @t{midpoint-quadrature%}}@: (function).
@item
@ref{❨74❩, , @t{midpoint-quadrature-a}}@: (function).
@item
@ref{❨75❩, , @t{(setf midpoint-quadrature-a)}}@: (function).
@item
@ref{❨43❩, , @t{midpoint-quadrature-b}}@: (function).
@item
@ref{❨44❩, , @t{(setf midpoint-quadrature-b)}}@: (function).
@item
@ref{❨47❩, , @t{midpoint-quadrature-f}}@: (function).
@item
@ref{❨48❩, , @t{(setf midpoint-quadrature-f)}}@: (function).
@item
@ref{❨39❩, , @t{midpoint-quadrature-h}}@: (function).
@item
@ref{❨40❩, , @t{(setf midpoint-quadrature-h)}}@: (function).
@item
@ref{❨49❩, , @t{midpoint-quadrature-n}}@: (function).
@item
@ref{❨50❩, , @t{(setf midpoint-quadrature-n)}}@: (function).
@item
@ref{❨110❩, , @t{midpoint-quadrature-p}}@: (function).
@item
@ref{❨105❩, , @t{midpoint-quadrature-sum}}@: (function).
@item
@ref{❨106❩, , @t{(setf midpoint-quadrature-sum)}}@: (function).
@item
@ref{❨114❩, , @t{refine-quadrature}}@: (generic function).
@item
@ref{❨107❩, , @t{richardson-coefficient}}@: (generic function).
@item
@ref{❨93❩, , @t{richardson-extrapolation}}@: (function).
@item
@ref{❨94❩, , @t{richardson-extrapolation}}@: (structure).
@item
@ref{❨64❩, , @t{richardson-extrapolation-coefficient}}@: (reader).
@item
@ref{❨65❩, , @t{(setf richardson-extrapolation-coefficient)}}@: (writer).
@item
@ref{❨79❩, , @t{richardson-extrapolation-diagonal}}@: (reader).
@item
@ref{❨80❩, , @t{(setf richardson-extrapolation-diagonal)}}@: (writer).
@item
@ref{❨62❩, , @t{richardson-extrapolation-n}}@: (reader).
@item
@ref{❨63❩, , @t{(setf richardson-extrapolation-n)}}@: (writer).
@item
@ref{❨61❩, , @t{richardson-extrapolation-p}}@: (function).
@item
@ref{❨84❩, , @t{richardson-iteration}}@: (function).
@item
@ref{❨87❩, , @t{romberg-quadrature%}}@: (function).
@item
@ref{❨51❩, , @t{transformed-quadrature}}@: (generic function).
@item
@ref{❨58❩, , @t{trapezoidal-quadrature}}@: (function).
@item
@ref{❨59❩, , @t{trapezoidal-quadrature}}@: (structure).
@item
@ref{❨37❩, , @t{trapezoidal-quadrature%}}@: (function).
@item
@ref{❨81❩, , @t{trapezoidal-quadrature-a}}@: (function).
@item
@ref{❨82❩, , @t{(setf trapezoidal-quadrature-a)}}@: (function).
@item
@ref{❨45❩, , @t{trapezoidal-quadrature-b}}@: (function).
@item
@ref{❨46❩, , @t{(setf trapezoidal-quadrature-b)}}@: (function).
@item
@ref{❨70❩, , @t{trapezoidal-quadrature-f}}@: (function).
@item
@ref{❨71❩, , @t{(setf trapezoidal-quadrature-f)}}@: (function).
@item
@ref{❨72❩, , @t{trapezoidal-quadrature-h}}@: (function).
@item
@ref{❨73❩, , @t{(setf trapezoidal-quadrature-h)}}@: (function).
@item
@ref{❨68❩, , @t{trapezoidal-quadrature-n}}@: (function).
@item
@ref{❨69❩, , @t{(setf trapezoidal-quadrature-n)}}@: (function).
@item
@ref{❨60❩, , @t{trapezoidal-quadrature-p}}@: (function).
@item
@ref{❨54❩, , @t{trapezoidal-quadrature-sum}}@: (function).
@item
@ref{❨55❩, , @t{(setf trapezoidal-quadrature-sum)}}@: (function).
@end itemize
@end table


@c ----------------------------------
@c The num-utils.print-matrix package
@c ----------------------------------
@node The num-utils․print-matrix package, The num-utils․chebyshev package, The num-utils․quadrature package, Packages
@section @t{num-utils.print-matrix}
@anchor{❨21❩}@c
@packageindex{num-utils.print-matrix}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@end itemize
@item Used By List
@itemize @bullet
@item
@t{lisp-stat}.
@item
@ref{❨26❩, , @t{num-utils.matrix}}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨117❩, , @t{*print-matrix-precision*}}@: (special variable).
@item
@ref{❨119❩, , @t{print-length-truncate}}@: (function).
@item
@ref{❨118❩, , @t{print-matrix}}@: (function).
@end itemize
@item Internals
@ref{❨120❩, , @t{print-matrix-formatter}}@: (function).
@end table


@c -------------------------------
@c The num-utils.chebyshev package
@c -------------------------------
@node The num-utils․chebyshev package, The num-utils․interval package, The num-utils․print-matrix package, Packages
@section @t{num-utils.chebyshev}
@anchor{❨22❩}@c
@packageindex{num-utils.chebyshev}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨23❩, , @t{num-utils.interval}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Used By List
@ref{❨34❩, , @t{num-utils}}.
@item Public Interface
@itemize @bullet
@item
@ref{❨121❩, , @t{chebyshev-approximate}}@: (function).
@item
@ref{❨123❩, , @t{chebyshev-regression}}@: (function).
@item
@ref{❨122❩, , @t{chebyshev-root}}@: (function).
@item
@ref{❨124❩, , @t{chebyshev-roots}}@: (function).
@item
@ref{❨125❩, , @t{evaluate-chebyshev}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨132❩, , @t{ab-to-cd-intercept-slope}}@: (function).
@item
@ref{❨130❩, , @t{ab-to-cinf}}@: (function).
@item
@ref{❨126❩, , @t{chebyshev-approximate-implementation}}@: (generic function).
@item
@ref{❨131❩, , @t{chebyshev-recursion}}@: (function).
@item
@ref{❨129❩, , @t{cinf-to-ab}}@: (function).
@end itemize
@end table


@c ------------------------------
@c The num-utils.interval package
@c ------------------------------
@node The num-utils․interval package, The num-utils․matrix-shorthand package, The num-utils․chebyshev package, Packages
@section @t{num-utils.interval}
@anchor{❨23❩}@c
@packageindex{num-utils.interval}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨32❩, , @t{num-utils.num=}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Used By List
@itemize @bullet
@item
@ref{❨34❩, , @t{num-utils}}.
@item
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨153❩, , @t{@ampchar{}interval}}@: (macro).
@item
@ref{❨138❩, , @t{extend-interval}}@: (generic function).
@item
@ref{❨134❩, , @t{extendf-interval}}@: (macro).
@item
@ref{❨172❩, , @t{finite-interval}}@: (class).
@item
@ref{❨152❩, , @t{grid-in}}@: (function).
@item
@ref{❨133❩, , @t{in-interval?}}@: (function).
@item
@ref{❨169❩, , @t{interval}}@: (function).
@item
@ref{❨170❩, , @t{interval}}@: (class).
@item
@ref{❨167❩, , @t{interval-hull}}@: (function).
@item
@ref{❨151❩, , @t{interval-length}}@: (function).
@item
@ref{❨176❩, , @t{interval-midpoint}}@: (function).
@item
@ref{❨155❩, , @t{left}}@: (generic function).
@item
@ref{❨171❩, , @t{minusinf-interval}}@: (class).
@item
@ref{❨135❩, , @t{open-left?}}@: (generic function).
@item
@ref{❨173❩, , @t{open-right?}}@: (generic function).
@item
@ref{❨150❩, , @t{plusinf-interval}}@: (class).
@item
@ref{❨168❩, , @t{plusminus-interval}}@: (function).
@item
@ref{❨148❩, , @t{real-line}}@: (class).
@item
@ref{❨159❩, , @t{relative}}@: (function).
@item
@ref{❨160❩, , @t{relative}}@: (structure).
@item
@ref{❨164❩, , @t{right}}@: (generic function).
@item
@ref{❨162❩, , @t{shift-interval}}@: (generic function).
@item
@ref{❨158❩, , @t{shrink-interval}}@: (function).
@item
@ref{❨145❩, , @t{spacer}}@: (function).
@item
@ref{❨146❩, , @t{spacer}}@: (structure).
@item
@ref{❨154❩, , @t{split-interval}}@: (function).
@item
@ref{❨149❩, , @t{subintervals-in}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨195❩, , @t{copy-relative}}@: (function).
@item
@ref{❨186❩, , @t{copy-spacer}}@: (function).
@item
@ref{❨190❩, , @t{interval/finite-left}}@: (class).
@item
@ref{❨187❩, , @t{interval/finite-right}}@: (class).
@item
@ref{❨182❩, , @t{interval/infinite-left}}@: (class).
@item
@ref{❨196❩, , @t{interval/infinite-right}}@: (class).
@item
@ref{❨183❩, , @t{print-left-endpoint}}@: (generic function).
@item
@ref{❨179❩, , @t{print-right-endpoint}}@: (generic function).
@item
@ref{❨178❩, , @t{relative-fraction}}@: (reader).
@item
@ref{❨193❩, , @t{relative-p}}@: (function).
@item
@ref{❨177❩, , @t{spacer-p}}@: (function).
@item
@ref{❨194❩, , @t{spacer-weight}}@: (reader).
@end itemize
@end table


@c --------------------------------------
@c The num-utils.matrix-shorthand package
@c --------------------------------------
@node The num-utils․matrix-shorthand package, The num-utils․log-exp package, The num-utils․interval package, Packages
@section @t{num-utils.matrix-shorthand}
@anchor{❨24❩}@c
@packageindex{num-utils.matrix-shorthand}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Nickname
@t{nu.mx}
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨26❩, , @t{num-utils.matrix}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨197❩, , @t{diagonal-mx}}@: (function).
@item
@ref{❨201❩, , @t{hermitian-mx}}@: (macro).
@item
@ref{❨200❩, , @t{lower-triangular-mx}}@: (macro).
@item
@ref{❨202❩, , @t{mx}}@: (macro).
@item
@ref{❨198❩, , @t{upper-triangular-mx}}@: (macro).
@item
@ref{❨199❩, , @t{vec}}@: (function).
@end itemize
@item Internals
@ref{❨203❩, , @t{pad-left-expansion}}@: (function).
@end table


@c -----------------------------
@c The num-utils.log-exp package
@c -----------------------------
@node The num-utils․log-exp package, The num-utils․matrix package, The num-utils․matrix-shorthand package, Packages
@section @t{num-utils.log-exp}
@anchor{❨25❩}@c
@packageindex{num-utils.log-exp}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{common-lisp}.
@item
@t{let-plus}.
@end itemize
@item Used By List
@ref{❨34❩, , @t{num-utils}}.
@item Public Interface
@itemize @bullet
@item
@ref{❨204❩, , @t{exp-1}}@: (function).
@item
@ref{❨215❩, , @t{exp-1/x}}@: (function).
@item
@ref{❨214❩, , @t{expt-1}}@: (function).
@item
@ref{❨213❩, , @t{hypot}}@: (function).
@item
@ref{❨205❩, , @t{log1+}}@: (function).
@item
@ref{❨208❩, , @t{log1+/x}}@: (function).
@item
@ref{❨207❩, , @t{log1+exp}}@: (function).
@item
@ref{❨206❩, , @t{log1-}}@: (function).
@item
@ref{❨210❩, , @t{log1-exp}}@: (function).
@item
@ref{❨209❩, , @t{log1pmx}}@: (function).
@item
@ref{❨212❩, , @t{log2-exp}}@: (function).
@item
@ref{❨211❩, , @t{logexp-1}}@: (function).
@end itemize
@end table


@c ----------------------------
@c The num-utils.matrix package
@c ----------------------------
@node The num-utils․matrix package, The num-utils․extended-real package, The num-utils․log-exp package, Packages
@section @t{num-utils.matrix}
@anchor{❨26❩}@c
@packageindex{num-utils.matrix}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item
@ref{❨32❩, , @t{num-utils.num=}}.
@item
@ref{❨21❩, , @t{num-utils.print-matrix}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@item
@t{select}.
@end itemize
@item Used By List
@itemize @bullet
@item
@t{distributions}.
@item
@ref{❨34❩, , @t{num-utils}}.
@item
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨235❩, , @t{diagonal-matrix}}@: (function).
@item
@ref{❨236❩, , @t{diagonal-matrix}}@: (structure).
@item
@ref{❨231❩, , @t{diagonal-matrix-elements}}@: (reader).
@item
@ref{❨232❩, , @t{(setf diagonal-matrix-elements)}}@: (writer).
@item
@ref{❨223❩, , @t{diagonal-vector}}@: (generic function).
@item
@ref{❨226❩, , @t{(setf diagonal-vector)}}@: (generic function).
@item
@ref{❨221❩, , @t{hermitian-matrix}}@: (function).
@item
@ref{❨222❩, , @t{hermitian-matrix}}@: (structure).
@item
@ref{❨233❩, , @t{lower-triangular-matrix}}@: (function).
@item
@ref{❨234❩, , @t{lower-triangular-matrix}}@: (structure).
@item
@ref{❨219❩, , @t{map-array}}@: (generic function).
@item
@ref{❨238❩, , @t{transpose}}@: (generic function).
@item
@ref{❨216❩, , @t{triangular-matrix}}@: (type).
@item
@ref{❨217❩, , @t{upper-triangular-matrix}}@: (function).
@item
@ref{❨218❩, , @t{upper-triangular-matrix}}@: (structure).
@item
@ref{❨228❩, , @t{wrapped-matrix}}@: (structure).
@item
@ref{❨230❩, , @t{wrapped-matrix-elements}}@: (reader).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨250❩, , @t{@ampchar{}diagonal-matrix}}@: (macro).
@item
@ref{❨264❩, , @t{@ampchar{}diagonal-matrix-r/o}}@: (macro).
@item
@ref{❨260❩, , @t{above-diagonal?}}@: (function).
@item
@ref{❨256❩, , @t{below-diagonal?}}@: (function).
@item
@ref{❨258❩, , @t{copy-diagonal-matrix}}@: (function).
@item
@ref{❨265❩, , @t{copy-hermitian-matrix}}@: (function).
@item
@ref{❨244❩, , @t{copy-lower-triangular-matrix}}@: (function).
@item
@ref{❨269❩, , @t{copy-upper-triangular-matrix}}@: (function).
@item
@ref{❨262❩, , @t{copy-wrapped-matrix}}@: (function).
@item
@ref{❨257❩, , @t{define-elementwise-as-array}}@: (macro).
@item
@ref{❨261❩, , @t{define-elementwise-same-class}}@: (macro).
@item
@ref{❨251❩, , @t{define-elementwise-univariate}}@: (macro).
@item
@ref{❨248❩, , @t{define-elementwise-with-constant}}@: (macro).
@item
@ref{❨268❩, , @t{define-wrapped-matrix}}@: (macro).
@item
@ref{❨247❩, , @t{diagonal-matrix-p}}@: (function).
@item
@ref{❨273❩, , @t{ensure-valid-elements}}@: (function).
@item
@ref{❨249❩, , @t{hermitian-matrix-elements}}@: (function).
@item
@ref{❨253❩, , @t{hermitian-matrix-p}}@: (function).
@item
@ref{❨254❩, , @t{lower-triangular-matrix-elements}}@: (function).
@item
@ref{❨259❩, , @t{lower-triangular-matrix-p}}@: (function).
@item
@ref{❨245❩, , @t{make-diagonal-matrix}}@: (function).
@item
@ref{❨266❩, , @t{make-hermitian-matrix}}@: (function).
@item
@ref{❨272❩, , @t{make-lower-triangular-matrix}}@: (function).
@item
@ref{❨271❩, , @t{make-upper-triangular-matrix}}@: (function).
@item
@ref{❨252❩, , @t{make-wrapped-matrix}}@: (function).
@item
@ref{❨246❩, , @t{upper-triangular-matrix-elements}}@: (function).
@item
@ref{❨267❩, , @t{upper-triangular-matrix-p}}@: (function).
@item
@ref{❨255❩, , @t{valid-sparse-type?}}@: (function).
@item
@ref{❨263❩, , @t{wrapped-matrix-p}}@: (function).
@item
@ref{❨270❩, , @t{zero-like}}@: (function).
@end itemize
@end table


@c -----------------------------------
@c The num-utils.extended-real package
@c -----------------------------------
@node The num-utils․extended-real package, The num-utils․utilities package, The num-utils․matrix package, Packages
@section @t{num-utils.extended-real}
@anchor{❨27❩}@c
@packageindex{num-utils.extended-real}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Nickname
@t{xreal}
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{common-lisp}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨281❩, , @t{<}}@: (function).
@item
@ref{❨274❩, , @t{<=}}@: (function).
@item
@ref{❨282❩, , @t{=}}@: (function).
@item
@ref{❨277❩, , @t{>}}@: (function).
@item
@ref{❨280❩, , @t{>=}}@: (function).
@item
@ref{❨278❩, , @t{extended-real}}@: (type).
@item
@ref{❨276❩, , @t{infinite?}}@: (function).
@item
@ref{❨275❩, , @t{lambda-template}}@: (macro).
@item
@ref{❨279❩, , @t{with-template}}@: (macro).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨285❩, , @t{define-comparison}}@: (macro).
@item
@ref{❨284❩, , @t{extend-pairwise-comparison}}@: (function).
@item
@ref{❨283❩, , @t{infinite}}@: (type).
@end itemize
@end table


@c -------------------------------
@c The num-utils.utilities package
@c -------------------------------
@node The num-utils․utilities package, The num-utils․test-utilities package, The num-utils․extended-real package, Packages
@section @t{num-utils.utilities}
@anchor{❨28❩}@c
@packageindex{num-utils.utilities}@c
A collection of utilities to work with floating point values. Optimised for double-float.
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@end itemize
@item Used By List
@itemize @bullet
@item
@t{lisp-stat}.
@item
@t{nu.statistics}.
@item
@ref{❨34❩, , @t{num-utils}}.
@item
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item
@ref{❨23❩, , @t{num-utils.interval}}.
@item
@ref{❨26❩, , @t{num-utils.matrix}}.
@item
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item
@ref{❨33❩, , @t{num-utils.polynomial}}.
@item
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨287❩, , @t{as-alist}}@: (generic function).
@item
@ref{❨310❩, , @t{as-bit-vector}}@: (function).
@item
@ref{❨308❩, , @t{as-double-float}}@: (function).
@item
@ref{❨303❩, , @t{as-plist}}@: (generic function).
@item
@ref{❨300❩, , @t{as-simple-fixnum-vector}}@: (function).
@item
@ref{❨286❩, , @t{bic}}@: (function).
@item
@ref{❨292❩, , @t{binary-search}}@: (function).
@item
@ref{❨290❩, , @t{check-types}}@: (macro).
@item
@ref{❨301❩, , @t{curry*}}@: (macro).
@item
@ref{❨293❩, , @t{define-with-multiple-bindings}}@: (macro).
@item
@ref{❨302❩, , @t{expanding}}@: (macro).
@item
@ref{❨298❩, , @t{fixnum?}}@: (function).
@item
@ref{❨307❩, , @t{generate-sequence}}@: (function).
@item
@ref{❨299❩, , @t{gethash*}}@: (macro).
@item
@ref{❨288❩, , @t{make-vector}}@: (compiler macro).
@item
@ref{❨289❩, , @t{make-vector}}@: (function).
@item
@ref{❨297❩, , @t{simple-boolean-vector}}@: (type).
@item
@ref{❨295❩, , @t{simple-double-float-vector}}@: (type).
@item
@ref{❨294❩, , @t{simple-fixnum-vector}}@: (type).
@item
@ref{❨305❩, , @t{simple-single-float-vector}}@: (type).
@item
@ref{❨309❩, , @t{splice-awhen}}@: (macro).
@item
@ref{❨306❩, , @t{splice-when}}@: (macro).
@item
@ref{❨291❩, , @t{with-double-floats}}@: (macro).
@item
@ref{❨296❩, , @t{within?}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨312❩, , @t{boolean-sequence-p}}@: (function).
@item
@ref{❨311❩, , @t{boolean?}}@: (function).
@end itemize
@end table


@c ------------------------------------
@c The num-utils.test-utilities package
@c ------------------------------------
@node The num-utils․test-utilities package, The num-utils․arithmetic package, The num-utils․utilities package, Packages
@section @t{num-utils.test-utilities}
@anchor{❨29❩}@c
@packageindex{num-utils.test-utilities}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@t{common-lisp}.
@item Used By List
@ref{❨34❩, , @t{num-utils}}.
@item Public Interface
@itemize @bullet
@item
@ref{❨334❩, , @t{compare-fns}}@: (function).
@item
@ref{❨333❩, , @t{compare-vectors}}@: (function).
@item
@ref{❨329❩, , @t{max-error}}@: (reader).
@item
@ref{❨330❩, , @t{(setf max-error)}}@: (writer).
@item
@ref{❨327❩, , @t{mean-error}}@: (reader).
@item
@ref{❨328❩, , @t{(setf mean-error)}}@: (writer).
@item
@ref{❨316❩, , @t{min-error}}@: (reader).
@item
@ref{❨317❩, , @t{(setf min-error)}}@: (writer).
@item
@ref{❨339❩, , @t{rms}}@: (reader).
@item
@ref{❨340❩, , @t{(setf rms)}}@: (writer).
@item
@ref{❨335❩, , @t{test-count}}@: (reader).
@item
@ref{❨336❩, , @t{(setf test-count)}}@: (writer).
@item
@ref{❨315❩, , @t{test-fn}}@: (function).
@item
@ref{❨318❩, , @t{test-results}}@: (structure).
@item
@ref{❨331❩, , @t{variance0}}@: (reader).
@item
@ref{❨332❩, , @t{(setf variance0)}}@: (writer).
@item
@ref{❨313❩, , @t{variance1}}@: (reader).
@item
@ref{❨314❩, , @t{(setf variance1)}}@: (writer).
@item
@ref{❨337❩, , @t{worst-case}}@: (reader).
@item
@ref{❨338❩, , @t{(setf worst-case)}}@: (writer).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨341❩, , @t{copy-test-results}}@: (function).
@item
@ref{❨342❩, , @t{make-test-results}}@: (function).
@item
@ref{❨343❩, , @t{test-results-p}}@: (function).
@end itemize
@end table


@c --------------------------------
@c The num-utils.arithmetic package
@c --------------------------------
@node The num-utils․arithmetic package, The num-utils․elementwise package, The num-utils․test-utilities package, Packages
@section @t{num-utils.arithmetic}
@anchor{❨30❩}@c
@packageindex{num-utils.arithmetic}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria+}.
@item
@t{alexandria-2}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Used By List
@itemize @bullet
@item
@t{lisp-stat}.
@item
@t{nu.statistics}.
@item
@ref{❨34❩, , @t{num-utils}}.
@item
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item
@t{special-functions}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨369❩, , @t{1c}}@: (function).
@item
@ref{❨346❩, , @t{abs-diff}}@: (function).
@item
@ref{❨352❩, , @t{absolute-square}}@: (function).
@item
@ref{❨364❩, , @t{as-integer}}@: (function).
@item
@ref{❨371❩, , @t{ceiling*}}@: (function).
@item
@ref{❨368❩, , @t{cube}}@: (function).
@item
@ref{❨367❩, , @t{cumulative-product}}@: (function).
@item
@ref{❨370❩, , @t{cumulative-sum}}@: (function).
@item
@ref{❨366❩, , @t{divides?}}@: (function).
@item
@ref{❨355❩, , @t{floor*}}@: (function).
@item
@ref{❨363❩, , @t{ivec}}@: (function).
@item
@ref{❨362❩, , @t{l2norm}}@: (function).
@item
@ref{❨344❩, , @t{l2norm-square}}@: (generic function).
@item
@ref{❨372❩, , @t{log10}}@: (function).
@item
@ref{❨365❩, , @t{log2}}@: (function).
@item
@ref{❨350❩, , @t{normalize-probabilities}}@: (function).
@item
@ref{❨373❩, , @t{numseq}}@: (function).
@item
@ref{❨357❩, , @t{product}}@: (generic function).
@item
@ref{❨360❩, , @t{round*}}@: (function).
@item
@ref{❨361❩, , @t{same-sign-p}}@: (function).
@item
@ref{❨351❩, , @t{sequence-maximum}}@: (function).
@item
@ref{❨354❩, , @t{sequence-minimum}}@: (function).
@item
@ref{❨356❩, , @t{square}}@: (function).
@item
@ref{❨104❩, , @t{sum}}@: (slot).
@item
@ref{❨347❩, , @t{sum}}@: (generic function).
@item
@ref{❨353❩, , @t{truncate*}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨377❩, , @t{define-rounding-with-offset}}@: (macro).
@item
@ref{❨376❩, , @t{ln}}@: (function).
@item
@ref{❨375❩, , @t{similar-element-type}}@: (function).
@item
@ref{❨374❩, , @t{similar-sequence-type}}@: (function).
@end itemize
@end table


@c ---------------------------------
@c The num-utils.elementwise package
@c ---------------------------------
@node The num-utils․elementwise package, The num-utils․num= package, The num-utils․arithmetic package, Packages
@section @t{num-utils.elementwise}
@anchor{❨31❩}@c
@packageindex{num-utils.elementwise}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Nickname
@t{elmt}
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Used By List
@itemize @bullet
@item
@t{distributions}.
@item
@t{lisp-stat}.
@item
@ref{❨34❩, , @t{num-utils}}.
@item
@ref{❨26❩, , @t{num-utils.matrix}}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨404❩, , @t{e*}}@: (function).
@item
@ref{❨505❩, , @t{e+}}@: (function).
@item
@ref{❨506❩, , @t{e-}}@: (function).
@item
@ref{❨399❩, , @t{e/}}@: (function).
@item
@ref{❨385❩, , @t{e1-}}@: (generic function).
@item
@ref{❨378❩, , @t{e1/}}@: (generic function).
@item
@ref{❨454❩, , @t{e1log}}@: (generic function).
@item
@ref{❨475❩, , @t{e2*}}@: (generic function).
@item
@ref{❨461❩, , @t{e2+}}@: (generic function).
@item
@ref{❨516❩, , @t{e2-}}@: (generic function).
@item
@ref{❨423❩, , @t{e2/}}@: (generic function).
@item
@ref{❨497❩, , @t{e2log}}@: (generic function).
@item
@ref{❨393❩, , @t{eceiling}}@: (generic function).
@item
@ref{❨451❩, , @t{econjugate}}@: (generic function).
@item
@ref{❨396❩, , @t{ecos}}@: (generic function).
@item
@ref{❨441❩, , @t{eexp}}@: (generic function).
@item
@ref{❨415❩, , @t{eexpt}}@: (generic function).
@item
@ref{❨448❩, , @t{efloor}}@: (generic function).
@item
@ref{❨440❩, , @t{elementwise-float-contagion}}@: (function).
@item
@ref{❨392❩, , @t{elog}}@: (function).
@item
@ref{❨515❩, , @t{emax}}@: (function).
@item
@ref{❨439❩, , @t{emin}}@: (function).
@item
@ref{❨507❩, , @t{emod}}@: (generic function).
@item
@ref{❨400❩, , @t{ereduce}}@: (generic function).
@item
@ref{❨405❩, , @t{esin}}@: (generic function).
@item
@ref{❨408❩, , @t{esqrt}}@: (generic function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨535❩, , @t{define-e@ampchar{}}}@: (macro).
@item
@ref{❨534❩, , @t{define-e1}}@: (macro).
@item
@ref{❨530❩, , @t{define-e2}}@: (macro).
@item
@ref{❨536❩, , @t{define-elementwise-reduction}}@: (macro).
@item
@ref{❨531❩, , @t{esquare}}@: (generic function).
@item
@ref{❨537❩, , @t{mapping-array}}@: (macro).
@end itemize
@end table


@c --------------------------
@c The num-utils.num= package
@c --------------------------
@node The num-utils․num= package, The num-utils․polynomial package, The num-utils․elementwise package, Packages
@section @t{num-utils.num=}
@anchor{❨32❩}@c
@packageindex{num-utils.num=}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{anaphora}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@end itemize
@item Used By List
@itemize @bullet
@item
@t{distributions}.
@item
@t{nu.statistics}.
@item
@ref{❨34❩, , @t{num-utils}}.
@item
@ref{❨23❩, , @t{num-utils.interval}}.
@item
@ref{❨26❩, , @t{num-utils.matrix}}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨552❩, , @t{*num=-tolerance*}}@: (special variable).
@item
@ref{❨539❩, , @t{define-num=-with-accessors}}@: (macro).
@item
@ref{❨538❩, , @t{define-structure-num=}}@: (macro).
@item
@ref{❨540❩, , @t{num-delta}}@: (function).
@item
@ref{❨541❩, , @t{num=}}@: (generic function).
@item
@ref{❨551❩, , @t{num=-function}}@: (function).
@end itemize
@end table


@c --------------------------------
@c The num-utils.polynomial package
@c --------------------------------
@node The num-utils․polynomial package, The num-utils package, The num-utils․num= package, Packages
@section @t{num-utils.polynomial}
@anchor{❨33❩}@c
@packageindex{num-utils.polynomial}@c
Efficient evaluation of polynomial functions using Horner's method
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Nickname
@t{poly}
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{common-lisp}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Used By List
@itemize @bullet
@item
@ref{❨34❩, , @t{num-utils}}.
@item
@t{special-functions}.
@end itemize
@item Public Interface
@itemize @bullet
@item
@ref{❨554❩, , @t{evaluate-polynomial}}@: (function).
@item
@ref{❨553❩, , @t{evaluate-rational}}@: (function).
@end itemize
@end table


@c ---------------------
@c The num-utils package
@c ---------------------
@node The num-utils package, The num-utils․rootfinding package, The num-utils․polynomial package, Packages
@section @t{num-utils}
@anchor{❨34❩}@c
@packageindex{num-utils}@c
Numerical utilities for Lisp-Stat
@table @strong
@item Source
@ref{❨19❩, , @t{pkgdcl.lisp}}.
@item Nickname
@t{nu}
@item Use List
@itemize @bullet
@item
@t{common-lisp}.
@item
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item
@ref{❨23❩, , @t{num-utils.interval}}.
@item
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item
@ref{❨26❩, , @t{num-utils.matrix}}.
@item
@ref{❨32❩, , @t{num-utils.num=}}.
@item
@ref{❨33❩, , @t{num-utils.polynomial}}.
@item
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@end table


@c ---------------------------------
@c The num-utils.rootfinding package
@c ---------------------------------
@node The num-utils․rootfinding package, , The num-utils package, Packages
@section @t{num-utils.rootfinding}
@anchor{❨35❩}@c
@packageindex{num-utils.rootfinding}@c
@table @strong
@item Source
@ref{❨3❩, , @t{packages.lisp}}.
@item Use List
@itemize @bullet
@item
@t{alexandria}.
@item
@t{common-lisp}.
@item
@t{let-plus}.
@item
@ref{❨23❩, , @t{num-utils.interval}}.
@item
@ref{❨28❩, , @t{num-utils.utilities}}.
@end itemize
@item Used By List
@ref{❨34❩, , @t{num-utils}}.
@item Public Interface
@itemize @bullet
@item
@ref{❨557❩, , @t{*rootfinding-delta-relative*}}@: (special variable).
@item
@ref{❨555❩, , @t{*rootfinding-epsilon*}}@: (special variable).
@item
@ref{❨556❩, , @t{root-bisection}}@: (function).
@end itemize
@item Internals
@itemize @bullet
@item
@ref{❨562❩, , @t{narrow-bracket?}}@: (function).
@item
@ref{❨560❩, , @t{near-root?}}@: (function).
@item
@ref{❨561❩, , @t{opposite-sign?}}@: (function).
@item
@ref{❨559❩, , @t{rootfinding-delta}}@: (function).
@item
@ref{❨558❩, , @t{univariate-rootfinder-loop%}}@: (macro).
@end itemize
@end table



@c ====================================================================
@c Definitions
@c ====================================================================
@node Definitions, Indexes, Packages, Top
@chapter Definitions
Definitions are sorted by export status, category, package, and then by
lexicographic order.

@menu
* Public Interface::
* Internals::
@end menu


@c ----------------
@c Public Interface
@c ----------------
@node Public Interface, Internals, Definitions, Definitions
@section Public Interface
@menu
* Public special variables::
* Public macros::
* Public compiler macros::
* Public ordinary functions::
* Public generic functions::
* Public standalone methods::
* Public structures::
* Public classes::
* Public types::
@end menu

@node Public special variables, Public macros, Public Interface, Public Interface
@subsection Special variables
@defvr {Special Variable} {*num=-tolerance*}
@anchor{❨552❩}@c
@specialsubindex{*num=-tolerance*}@c
Default tolerance for NUM=.
@table @strong
@item Package
@ref{❨32❩, , @t{num-utils.num=}}.
@item Source
@ref{❨5❩, , @t{num=.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*print-matrix-precision*}
@anchor{❨117❩}@c
@specialsubindex{*print-matrix-precision*}@c
Number of digits after the decimal point when printing numeric matrices.
@table @strong
@item Package
@ref{❨21❩, , @t{num-utils.print-matrix}}.
@item Source
@ref{❨10❩, , @t{print-matrix.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*rootfinding-delta-relative*}
@anchor{❨557❩}@c
@specialsubindex{*rootfinding-delta-relative*}@c
Default relative interval width for rootfinding.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end defvr
@defvr {Special Variable} {*rootfinding-epsilon*}
@anchor{❨555❩}@c
@specialsubindex{*rootfinding-epsilon*}@c
Default maximum for the absolute value of the function@comma{} used for rootfinding.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end defvr

@node Public macros, Public compiler macros, Public special variables, Public Interface
@subsection Macros
@deffn {Macro} {@ampchar{}interval} (left right)
@anchor{❨153❩}@c
@macrosubindex{@ampchar{}interval}@c
LET+ expansion for interval endpoints.  If given a list of two values@comma{}
the second value is an indicator for whether the endpoint is open.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Macro} {check-types} ((&rest arguments) type)
@anchor{❨290❩}@c
@macrosubindex{check-types}@c
CHECK-TYPE for multiple places of the same type.  Each argument is either a place@comma{} or a list of a place and a type-string.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {curry*} (function &rest arguments)
@anchor{❨301❩}@c
@macrosubindex{curry*}@c
Currying in all variables that are not *.  Note that this is a macro@comma{} so * should not be quoted@comma{} and FUNCTION will be used as is@comma{} ie it can be a LAMBDA form.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-num=-with-accessors} (class accessors)
@anchor{❨539❩}@c
@macrosubindex{define-num=-with-accessors}@c
Define a method for NUM=@comma{} specialized to the given class@comma{} comparing values obtained with accessors.
@table @strong
@item Package
@ref{❨32❩, , @t{num-utils.num=}}.
@item Source
@ref{❨5❩, , @t{num=.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-structure-num=} (structure &rest slots)
@anchor{❨538❩}@c
@macrosubindex{define-structure-num=}@c
Define a NUM= method for the given structure@comma{} comparing the given slots.
@table @strong
@item Package
@ref{❨32❩, , @t{num-utils.num=}}.
@item Source
@ref{❨5❩, , @t{num=.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-with-multiple-bindings} (macro &key plural docstring)
@anchor{❨293❩}@c
@macrosubindex{define-with-multiple-bindings}@c
Define a version of MACRO with multiple arguments@comma{} given as a list.  Application of MACRO will be nested.  The new name is the plural of the old one (generated using format by default).
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {expanding} (&body body)
@anchor{❨302❩}@c
@macrosubindex{expanding}@c
Expand BODY. Useful for generating code programmatically.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {extendf-interval} (place object)
@anchor{❨134❩}@c
@macrosubindex{extendf-interval}@c
Apply EXTEND-INTERVAL on PLACE using OBJECT.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Macro} {gethash*} (key hash-table &optional datum &rest arguments)
@anchor{❨299❩}@c
@macrosubindex{gethash*}@c
Like GETHASH@comma{} but checking that KEY is present and raising the given error if not.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {hermitian-mx} (element-type &body rows)
@anchor{❨201❩}@c
@macrosubindex{hermitian-mx}@c
Macro for creating a lower triangular matrix.  ROWS should be a list of lists@comma{} elements are evaluated.  Masked elements (above the diagonal) are ignored at the expansion@comma{} rows which don't have enough elements are padded with zeros.
@table @strong
@item Package
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item Source
@ref{❨12❩, , @t{matrix-shorthand.lisp}}.
@end table
@end deffn
@deffn {Macro} {lambda-template} ((prefix &rest variables) &body body)
@anchor{❨275❩}@c
@macrosubindex{lambda-template}@c
LAMBDA with WITH-TEMPLATE in its BODY.
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Macro} {lower-triangular-mx} (element-type &body rows)
@anchor{❨200❩}@c
@macrosubindex{lower-triangular-mx}@c
Macro for creating a lower triangular matrix.  ROWS should be a list of lists@comma{} elements are evaluated.  Masked elements (above the diagonal) are ignored at the expansion@comma{} rows which don't have enough elements are padded with zeros.
@table @strong
@item Package
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item Source
@ref{❨12❩, , @t{matrix-shorthand.lisp}}.
@end table
@end deffn
@deffn {Macro} {mx} (element-type &body rows)
@anchor{❨202❩}@c
@macrosubindex{mx}@c
Macro for creating a (dense) matrix (ie a rank 2 array).  ROWS should be a list of lists (or atoms@comma{} which are treated as lists)@comma{} elements are evaluated.
@table @strong
@item Package
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item Source
@ref{❨12❩, , @t{matrix-shorthand.lisp}}.
@end table
@end deffn
@deffn {Macro} {splice-awhen} (test &body forms)
@anchor{❨309❩}@c
@macrosubindex{splice-awhen}@c
Similar to splice-when@comma{} but binds IT to test.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {splice-when} (test &body forms)
@anchor{❨306❩}@c
@macrosubindex{splice-when}@c
Similar to when@comma{} but wraps the result in list.

Example: `(@comma{}foo @comma{}@atchar{}(splice-when add-bar? bar))
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {upper-triangular-mx} (element-type &body rows)
@anchor{❨198❩}@c
@macrosubindex{upper-triangular-mx}@c
Macro for creating an upper triangular matrix.  ROWS should be a list of lists@comma{} elements are evaluated.  Masked elements (below the diagonal) are ignored at the expansion.
@table @strong
@item Package
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item Source
@ref{❨12❩, , @t{matrix-shorthand.lisp}}.
@end table
@end deffn
@deffn {Macro} {with-double-floats} (bindings &body body)
@anchor{❨291❩}@c
@macrosubindex{with-double-floats}@c
For each binding = (variable value)@comma{} coerce VALUE to DOUBLE-FLOAT and bind it to VARIABLE for BODY.  When VALUE is omitted@comma{} VARIABLE is used instead.  When BINDING is an atom@comma{} it is used for both the value and the variable.

Example:@*
  (with-double-floats (a@*
                       (b)@*
                       (c 1))@*
    ...)
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Macro} {with-template} ((prefix &rest variables) &body body)
@anchor{❨279❩}@c
@macrosubindex{with-template}@c
Define the function (PREFIX @ampchar{}rest VARIABLES) which can be used to match variables using :PLUSINF@comma{} :MINUSINF@comma{} REAL@comma{} or T.
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn

@node Public compiler macros, Public ordinary functions, Public macros, Public Interface
@subsection Compiler macros
@deffn {Compiler Macro} {make-vector} (element-type &rest initial-contents)
@anchor{❨288❩}@c
@compilermacrosubindex{make-vector}@c
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn

@node Public ordinary functions, Public generic functions, Public compiler macros, Public Interface
@subsection Ordinary functions
@deffn {Function} {1c} (number)
@anchor{❨369❩}@c
@functionsubindex{1c}@c
Return 1-number.  The mnemonic is "1 complement"@comma{} 1- is already a CL library function.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {<} (number &rest more-numbers)
@anchor{❨281❩}@c
@functionsubindex{<}@c
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Function} {<=} (number &rest more-numbers)
@anchor{❨274❩}@c
@functionsubindex{<=}@c
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Function} {=} (number &rest more-numbers)
@anchor{❨282❩}@c
@functionsubindex{=}@c
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Function} {>} (number &rest more-numbers)
@anchor{❨277❩}@c
@functionsubindex{>}@c
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Function} {>=} (number &rest more-numbers)
@anchor{❨280❩}@c
@functionsubindex{>=}@c
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Function} {abs-diff} (a b)
@anchor{❨346❩}@c
@functionsubindex{abs-diff}@c
Absolute difference of A and B.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {absolute-square} (number)
@anchor{❨352❩}@c
@functionsubindex{absolute-square}@c
Number multiplied by its complex conjugate.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {as-bit-vector} (v)
@anchor{❨310❩}@c
@functionsubindex{as-bit-vector}@c
Return a bit vector where each non-nil element of V is mapped to 1 and each NIL element is mapped to 0
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {as-double-float} (x)
@anchor{❨308❩}@c
@functionsubindex{as-double-float}@c
Convert argument to DOUBLE-FLOAT.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {as-integer} (number)
@anchor{❨364❩}@c
@functionsubindex{as-integer}@c
If NUMBER represents an integer (as an integer@comma{} complex@comma{} or float@comma{} etc)@comma{} return it as an integer@comma{} otherwise signal an error.  Floats are converted with RATIONALIZE.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {as-simple-fixnum-vector} (sequence &optional copy?)
@anchor{❨300❩}@c
@functionsubindex{as-simple-fixnum-vector}@c
Convert SEQUENCE to a SIMPLE-FIXNUM-VECTOR.  When COPY?@comma{} make sure that the they don't share structure.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {bic} (a b)
@anchor{❨286❩}@c
@functionsubindex{bic}@c
Biconditional.  Returns A <=> B.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {binary-search} (sorted-reals value)
@anchor{❨292❩}@c
@functionsubindex{binary-search}@c
Return INDEX such that@*

  (WITHIN? (AREF SORTED-REALS INDEX) VALUE (AREF SORTED-REALS (1+ INDEX)).@*

SORTED-REALS is assumed to be reals sorted in ascending order (not checked@comma{} if this does not hold the result may be nonsensical@comma{} though the algorithm will terminate).

If value is below (or above) the first (last) break@comma{} NIL (T) is returned.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {ceiling*} (number &optional divisor offset)
@anchor{❨371❩}@c
@functionsubindex{ceiling*}@c
Find the lowest A=I*DIVISOR+OFFSET >= NUMBER@comma{} return (values A (- A NUMBER).
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {chebyshev-approximate} (f interval n-polynomials &key n-points)
@anchor{❨121❩}@c
@functionsubindex{chebyshev-approximate}@c
Return a closure approximating F on the given INTERVAL (may be infinite on
either end) using the given number of Chebyshev polynomials.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {chebyshev-regression} (f n-polynomials &optional n-points)
@anchor{❨123❩}@c
@functionsubindex{chebyshev-regression}@c
Chebyshev polynomial regression using the given number of polynomials and
points (zeroes of the corresponding Chebyshev polynomial).
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {chebyshev-root} (m i)
@anchor{❨122❩}@c
@functionsubindex{chebyshev-root}@c
Return the iTH root of the Mth Chebyshev polynomial as double-float.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {chebyshev-roots} (m)
@anchor{❨124❩}@c
@functionsubindex{chebyshev-roots}@c
Return the roots of the Mth Chebyshev polynomial as a vector of
double-floats.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {compare-fns} (fn-1 fn-2 &rest fn-params)
@anchor{❨334❩}@c
@functionsubindex{compare-fns}@c
Compare the values returned by two functions
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {compare-vectors} (reference-values computed-values)
@anchor{❨333❩}@c
@functionsubindex{compare-vectors}@c
Compare two vectors containing the results of previous computations
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {cube} (number)
@anchor{❨368❩}@c
@functionsubindex{cube}@c
Cube of number.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {cumulative-product} (sequence &key result-type)
@anchor{❨367❩}@c
@functionsubindex{cumulative-product}@c
Cumulative product of sequence.  Return a sequence of the same kind and length; last element is the total product.  The latter is also returned as the second value.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {cumulative-sum} (sequence &key result-type)
@anchor{❨370❩}@c
@functionsubindex{cumulative-sum}@c
Cumulative sum of sequence.  Return a sequence of the same kind and length; last element is the total.  The latter is returned as the second value.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {diagonal-matrix} (elements)
@anchor{❨235❩}@c
@functionsubindex{diagonal-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Reader} {diagonal-matrix-elements} (instance)
@anchor{❨231❩}@c
@functionsubindex{diagonal-matrix-elements}@c
@deffnx {Writer} {(setf diagonal-matrix-elements)} (instance)
@anchor{❨232❩}@c
@functionsubindex{(setf diagonal-matrix-elements)}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Target Slot
@ref{❨237❩, , @t{elements}}.
@end table
@end deffn
@deffn {Function} {diagonal-mx} (element-type &rest elements)
@anchor{❨197❩}@c
@functionsubindex{diagonal-mx}@c
Return a DIAGONAL-MATRIX with elements coerced to ELEMENT-TYPE.
@table @strong
@item Package
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item Source
@ref{❨12❩, , @t{matrix-shorthand.lisp}}.
@end table
@end deffn
@deffn {Function} {divides?} (number divisor)
@anchor{❨366❩}@c
@functionsubindex{divides?}@c
Test if DIVISOR divides NUMBER without remainder@comma{} and if so@comma{} return the
  quotient.  Works generally@comma{} but makes most sense for rationals.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {e*} (argument &rest more-arguments)
@anchor{❨404❩}@c
@functionsubindex{e*}@c
Elementwise *.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {e+} (argument &rest more-arguments)
@anchor{❨505❩}@c
@functionsubindex{e+}@c
Elementwise +.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {e-} (argument &rest more-arguments)
@anchor{❨506❩}@c
@functionsubindex{e-}@c
Elementwise -.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {e/} (argument &rest more-arguments)
@anchor{❨399❩}@c
@functionsubindex{e/}@c
Elementwise /.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {elementwise-float-contagion} (&rest objects)
@anchor{❨440❩}@c
@functionsubindex{elementwise-float-contagion}@c
Return the resulting float type when objects (or their elements) are combined using arithmetic operations.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {elog} (a &optional base)
@anchor{❨392❩}@c
@functionsubindex{elog}@c
Elementwise logarithm.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {emax} (object)
@anchor{❨515❩}@c
@functionsubindex{emax}@c
Elementwise MAX.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {emin} (object)
@anchor{❨439❩}@c
@functionsubindex{emin}@c
Elementwise MIN.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Function} {evaluate-chebyshev} (coefficients x)
@anchor{❨125❩}@c
@functionsubindex{evaluate-chebyshev}@c
Return the sum of Chebyshev polynomials@comma{} weighted by COEFFICIENTS@comma{} at X.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {evaluate-polynomial} (coefficients x)
@anchor{❨554❩}@c
@functionsubindex{evaluate-polynomial}@c
Return the sum of polynomials@comma{} weighted by COEFFICIENTS@comma{} at X.
COFFICIENTS are ordered from the highest degree down to the constant term.
X must be of the same type as COEFFICIENTS.
@table @strong
@item Package
@ref{❨33❩, , @t{num-utils.polynomial}}.
@item Source
@ref{❨14❩, , @t{polynomial.lisp}}.
@end table
@end deffn
@deffn {Function} {evaluate-rational} (numerator denominator z)
@anchor{❨553❩}@c
@functionsubindex{evaluate-rational}@c
Evaluate a rational function using Horner's method.  NUMERATOR and DENOMINATOR must be equal in size.  These always have a loop and so may be less efficient than evaluating a pair of polynomials.  However@comma{} there are some tricks we can use to prevent overflow that might otherwise occur in polynomial evaluation if z is large.  This is important in our Lanczos code for example.
@*
N.B. The order of coefficients for this function is NOT the same as evaluate-polynomial. 
@table @strong
@item Package
@ref{❨33❩, , @t{num-utils.polynomial}}.
@item Source
@ref{❨14❩, , @t{polynomial.lisp}}.
@end table
@end deffn
@deffn {Function} {exp-1} (x)
@anchor{❨204❩}@c
@functionsubindex{exp-1}@c
Compute (- (exp x) 1) stably even when X is near 0
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {exp-1/x} (x)
@anchor{❨215❩}@c
@functionsubindex{exp-1/x}@c
Compute (/ (- (exp x) 1) x) stably even when X is near zero.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {expt-1} (a z)
@anchor{❨214❩}@c
@functionsubindex{expt-1}@c
Compute (a^z)-1 stably even when A is close to 1 or Z is close to
zero.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {fixnum?} (object)
@anchor{❨298❩}@c
@functionsubindex{fixnum?}@c
Check of type of OBJECT is fixnum.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {floor*} (number &optional divisor offset)
@anchor{❨355❩}@c
@functionsubindex{floor*}@c
Find the highest A=I*DIVISOR+OFFSET <= NUMBER@comma{} return (values A (- A NUMBER).
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {generate-sequence} (result-type size function)
@anchor{❨307❩}@c
@functionsubindex{generate-sequence}@c
Like MAKE-SEQUENCE@comma{} but using a function to fill the result.@*

Example to create a sequence of random numbers between 0-1 from the uniform distribution:
(generate-sequence '(vector double-float) 100 (lambda () (random 1.0))).@*
Essentially the initial values are ignored when using this function.@*
See also: aops:generate
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {grid-in} (interval size &optional sequence-type)
@anchor{❨152❩}@c
@functionsubindex{grid-in}@c
Return an arithmetic sequence of the given size (length) between the
endpoints of the interval.  The endpoints of the sequence coincide with the
respective endpoint of the interval iff it is closed.  RESULT-TYPE determines
the result type (eg list)@comma{} if not given it is a simple-array (of rank 1)@comma{}
narrowing to the appropriate float type or fixnum if possible.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {hermitian-matrix} (elements)
@anchor{❨221❩}@c
@functionsubindex{hermitian-matrix}@c
Create a lower-triangular-matrix.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {hypot} (x y)
@anchor{❨213❩}@c
@functionsubindex{hypot}@c
Compute the hypotenuse of X and Y without danger of floating-point
overflow or underflow.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {in-interval?} (interval number)
@anchor{❨133❩}@c
@functionsubindex{in-interval?}@c
Test if NUMBER is in INTERVAL (which can be NIL@comma{} designating the empty
set).
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {infinite?} (object)
@anchor{❨276❩}@c
@functionsubindex{infinite?}@c
Test if an object represents positive or negative infinity.
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Function} {interval} (left right &key open-left? open-right?)
@anchor{❨169❩}@c
@functionsubindex{interval}@c
Create an INTERVAL.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {interval-hull} (object)
@anchor{❨167❩}@c
@functionsubindex{interval-hull}@c
Return the smallest connected interval that contains (elements in) OBJECT.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {interval-length} (interval)
@anchor{❨151❩}@c
@functionsubindex{interval-length}@c
Difference between left and right.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {interval-midpoint} (interval &optional alpha)
@anchor{❨176❩}@c
@functionsubindex{interval-midpoint}@c
Convex combination of left and right@comma{} with alpha (defaults to 0.5)
weight on right.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {ivec} (end-or-start &optional end by strict-direction?)
@anchor{❨363❩}@c
@functionsubindex{ivec}@c
Return a vector of fixnums.@*

   (ivec end) =>  @hashchar{}(0 ... end-1) (or @hashchar{}(0 ... end+1) when end is negative).@*

   (ivec start end) => @hashchar{}(start ... end-1) or to end+1 when end is negative.@*

When BY is given it determines the increment@comma{} adjusted to match the direction unless STRICT-DIRECTION@comma{} in which case an error is signalled. 
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {l2norm} (object)
@anchor{❨362❩}@c
@functionsubindex{l2norm}@c
$L_2$ norm of OBJECT.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {log1+} (x)
@anchor{❨205❩}@c
@functionsubindex{log1+}@c
Compute (log (1+ x)) stably even when X is near 0.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {log1+/x} (x)
@anchor{❨208❩}@c
@functionsubindex{log1+/x}@c
Compute (/ (log (+ 1 x)) x) stably even when X is near zero.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {log1+exp} (a)
@anchor{❨207❩}@c
@functionsubindex{log1+exp}@c
Accurately compute log(1+exp(x)) even when A is near zero.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {log1-} (x)
@anchor{❨206❩}@c
@functionsubindex{log1-}@c
Compute (log (- 1 x)) stably even when X is near zero.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {log1-exp} (a)
@anchor{❨210❩}@c
@functionsubindex{log1-exp}@c
Compute log(1-exp(x)) stably even when A is near zero.@*
This is sometimes known as the E_3@comma{} the third Einstein function.@*
See Mächler 2008 for notes on accurate calculation.
https://cran.r-project.org/web/packages/Rmpfr/vignettes/log1mexp-note.pdf
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {log10} (number)
@anchor{❨372❩}@c
@functionsubindex{log10}@c
Abbreviation for decimal logarithm.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {log1pmx} (x)
@anchor{❨209❩}@c
@functionsubindex{log1pmx}@c
Compute (- (log (1+ x)) x)@*
Accuracy within ~2ulps for -0.227 < x < 0.315
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {log2} (number)
@anchor{❨365❩}@c
@functionsubindex{log2}@c
Abbreviation for binary logarithm.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {log2-exp} (x)
@anchor{❨212❩}@c
@functionsubindex{log2-exp}@c
Compute log(2-exp(x)) stably even when X is near zero.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {logexp-1} (a)
@anchor{❨211❩}@c
@functionsubindex{logexp-1}@c
Compute log(exp(a)-1) stably even when A is small.
@table @strong
@item Package
@ref{❨25❩, , @t{num-utils.log-exp}}.
@item Source
@ref{❨17❩, , @t{log-exp.lisp}}.
@end table
@end deffn
@deffn {Function} {lower-triangular-matrix} (elements)
@anchor{❨233❩}@c
@functionsubindex{lower-triangular-matrix}@c
Create a lower-triangular-matrix.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {make-vector} (element-type &rest initial-contents)
@anchor{❨289❩}@c
@functionsubindex{make-vector}@c
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Reader} {max-error} (instance)
@anchor{❨329❩}@c
@functionsubindex{max-error}@c
@deffnx {Writer} {(setf max-error)} (instance)
@anchor{❨330❩}@c
@functionsubindex{(setf max-error)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨321❩, , @t{max-error}}.
@end table
@end deffn
@deffn {Reader} {mean-error} (instance)
@anchor{❨327❩}@c
@functionsubindex{mean-error}@c
@deffnx {Writer} {(setf mean-error)} (instance)
@anchor{❨328❩}@c
@functionsubindex{(setf mean-error)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨322❩, , @t{mean-error}}.
@end table
@end deffn
@deffn {Reader} {min-error} (instance)
@anchor{❨316❩}@c
@functionsubindex{min-error}@c
@deffnx {Writer} {(setf min-error)} (instance)
@anchor{❨317❩}@c
@functionsubindex{(setf min-error)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨320❩, , @t{min-error}}.
@end table
@end deffn
@deffn {Function} {normalize-probabilities} (vector &key element-type result)
@anchor{❨350❩}@c
@functionsubindex{normalize-probabilities}@c
Verify that each element of VECTOR is nonnegative and return a vector multiplied so that they sum to 1.  ELEMENT-TYPE can be used to specify the element-type of the result.  When RESULT is given@comma{} the result is placed there.  When RESULT is NIL@comma{} VECTOR is modified instead.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {num-delta} (a b)
@anchor{❨540❩}@c
@functionsubindex{num-delta}@c
|a-b|/max(1@comma{}|a|@comma{}|b|).  Useful for comparing numbers.
@table @strong
@item Package
@ref{❨32❩, , @t{num-utils.num=}}.
@item Source
@ref{❨5❩, , @t{num=.lisp}}.
@end table
@end deffn
@deffn {Function} {num=-function} (tolerance)
@anchor{❨551❩}@c
@functionsubindex{num=-function}@c
Curried version of num=@comma{} with given tolerance.
@table @strong
@item Package
@ref{❨32❩, , @t{num-utils.num=}}.
@item Source
@ref{❨5❩, , @t{num=.lisp}}.
@end table
@end deffn
@deffn {Function} {numseq} (from to &key length by type)
@anchor{❨373❩}@c
@functionsubindex{numseq}@c
Return a sequence between FROM and TO@comma{} progressing by BY@comma{} of the given LENGTH.  Only 3 of these a parameters should be given@comma{} the missing one (NIL) should be inferred automatically.  The sign of BY is adjusted if necessary.  If TYPE is LIST@comma{} the result is a list@comma{} otherwise it determines the element type of the resulting simple array.  If TYPE is nil@comma{} it as autodetected from the arguments (as a FIXNUM@comma{} a RATIONAL@comma{} or some subtype of FLOAT).  Note that the implementation may upgrade the element type.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {plusminus-interval} (center half-width &key open-left? open-right?)
@anchor{❨168❩}@c
@functionsubindex{plusminus-interval}@c
A symmetric interval around CENTER.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {print-length-truncate} (dimension)
@anchor{❨119❩}@c
@functionsubindex{print-length-truncate}@c
Return values (min dimension *print-length*) and whether the constraint is binding.
@table @strong
@item Package
@ref{❨21❩, , @t{num-utils.print-matrix}}.
@item Source
@ref{❨10❩, , @t{print-matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {print-matrix} (matrix stream &key formatter masked-fn aligned? padding indent)
@anchor{❨118❩}@c
@functionsubindex{print-matrix}@c
Format and print the elements of MATRIX (a 2d array) to STREAM@comma{} using PADDING between columns.@*

MASKED-FN is called on row and column indices.  If it returns nil@comma{} the corresponding element is formatted using FORMATTER and printed.  Otherwise@comma{} it should return a string@comma{} which is printed as is.  INDENT is printed before each row.

If ALIGNED?@comma{} columns will be right-aligned.  At most *PRINT-LENGTH* rows and columns are printed@comma{} more is indicated with ellipses (...).
@table @strong
@item Package
@ref{❨21❩, , @t{num-utils.print-matrix}}.
@item Source
@ref{❨10❩, , @t{print-matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {relative} (fraction)
@anchor{❨159❩}@c
@functionsubindex{relative}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Reader} {rms} (instance)
@anchor{❨339❩}@c
@functionsubindex{rms}@c
@deffnx {Writer} {(setf rms)} (instance)
@anchor{❨340❩}@c
@functionsubindex{(setf rms)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨326❩, , @t{rms}}.
@end table
@end deffn
@deffn {Function} {romberg-quadrature} (f interval &key epsilon min-iter max-iter transformation)
@anchor{❨36❩}@c
@functionsubindex{romberg-quadrature}@c
Romberg quadrature of F on the interval.  The iteration stops if the relative change is below EPSILON@comma{} but only after MIN-ITER refinements (to avoid spurious premature convergence).  An error occurs when MAX-ITER iterations are reached without convergence.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {root-bisection} (f bracket &key delta epsilon)
@anchor{❨556❩}@c
@functionsubindex{root-bisection}@c
Find the root of f bracketed between a and b using bisection.@*
The algorithm stops when either the root is bracketed in an interval of length
TOLERANCE (relative to the initial |a-b|)@comma{} or root is found such that
abs(f(root)) <= epsilon.@*

Return five values: the root@comma{} the value of the function at the root@comma{} and a
boolean which is true iff abs(f(root)) <= epsilon.  If the third value is
true@comma{} the fourth and fifth values are the endpoints of the bracketing
interval@comma{} otherwise they are undefined.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end deffn
@deffn {Function} {round*} (number &optional divisor offset)
@anchor{❨360❩}@c
@functionsubindex{round*}@c
Find A=I*DIVISOR+OFFSET that minimizes |A-NUMBER|@comma{} return (values A (- A NUMBER).  When NUMBER is exactly in between two possible A's@comma{} the rounding rule of ROUND is used on NUMBER-OFFSET.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {same-sign-p} (&rest arguments)
@anchor{❨361❩}@c
@functionsubindex{same-sign-p}@c
Test whether all arguments have the same sign (ie all are positive@comma{} negative@comma{} or zero).
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {sequence-maximum} (x)
@anchor{❨351❩}@c
@functionsubindex{sequence-maximum}@c
Return the maximum value in the sequence X
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {sequence-minimum} (x)
@anchor{❨354❩}@c
@functionsubindex{sequence-minimum}@c
Return the minimum value in the sequence X
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {shrink-interval} (interval left &optional right check-flip?)
@anchor{❨158❩}@c
@functionsubindex{shrink-interval}@c
Shrink interval by given magnitudes (which may be REAL or RELATIVE).  When
check-flip?@comma{} the result is checked for endpoints being in a different order
than the original.  Negative LEFT and RIGHT extend the interval.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {spacer} (&optional weight)
@anchor{❨145❩}@c
@functionsubindex{spacer}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {split-interval} (interval divisions)
@anchor{❨154❩}@c
@functionsubindex{split-interval}@c
Return a vector of subintervals (same length as DIVISIONS)@comma{} splitting the
interval using the sequence DIVISIONS@comma{} which can be nonnegative real
numbers (or RELATIVE specifications) and SPACERs which divide the leftover
proportionally.  If there are no spacers and the divisions don't fill up the
interval@comma{} and error is signalled.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {square} (number)
@anchor{❨356❩}@c
@functionsubindex{square}@c
Square of number.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {subintervals-in} (interval count &optional mid-open-right?)
@anchor{❨149❩}@c
@functionsubindex{subintervals-in}@c
Return INTERVAL evenly divided into COUNT subintervals as a vector.  When MID-OPEN-RIGHT?@comma{} subintervals in the middle are open on the right and closed on the left@comma{} otherwise the opposite; openness of endpoints on the edge follows INTERVAL.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Reader} {test-count} (instance)
@anchor{❨335❩}@c
@functionsubindex{test-count}@c
@deffnx {Writer} {(setf test-count)} (instance)
@anchor{❨336❩}@c
@functionsubindex{(setf test-count)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨323❩, , @t{test-count}}.
@end table
@end deffn
@deffn {Function} {test-fn} (expected-column fn &rest fn-param-columns)
@anchor{❨315❩}@c
@functionsubindex{test-fn}@c
Test the differences between expected values and the given function
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {truncate*} (number &optional divisor offset)
@anchor{❨353❩}@c
@functionsubindex{truncate*}@c
Find A=I*DIVISOR+OFFSET that maximizes |A|<=|NUMBER| with the same sign@comma{} return (values A (- A NUMBER).
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {upper-triangular-matrix} (elements)
@anchor{❨217❩}@c
@functionsubindex{upper-triangular-matrix}@c
Create a lower-triangular-matrix.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Reader} {variance0} (instance)
@anchor{❨331❩}@c
@functionsubindex{variance0}@c
@deffnx {Writer} {(setf variance0)} (instance)
@anchor{❨332❩}@c
@functionsubindex{(setf variance0)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨324❩, , @t{variance0}}.
@end table
@end deffn
@deffn {Reader} {variance1} (instance)
@anchor{❨313❩}@c
@functionsubindex{variance1}@c
@deffnx {Writer} {(setf variance1)} (instance)
@anchor{❨314❩}@c
@functionsubindex{(setf variance1)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨325❩, , @t{variance1}}.
@end table
@end deffn
@deffn {Function} {vec} (element-type &rest elements)
@anchor{❨199❩}@c
@functionsubindex{vec}@c
Return a vector with elements coerced to ELEMENT-TYPE.
@table @strong
@item Package
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item Source
@ref{❨12❩, , @t{matrix-shorthand.lisp}}.
@end table
@end deffn
@deffn {Function} {within?} (left value right)
@anchor{❨296❩}@c
@functionsubindex{within?}@c
Return non-nil iff value is in [left@comma{}right).
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Reader} {worst-case} (instance)
@anchor{❨337❩}@c
@functionsubindex{worst-case}@c
@deffnx {Writer} {(setf worst-case)} (instance)
@anchor{❨338❩}@c
@functionsubindex{(setf worst-case)}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Target Slot
@ref{❨319❩, , @t{worst-case}}.
@end table
@end deffn
@deffn {Reader} {wrapped-matrix-elements} (instance)
@anchor{❨230❩}@c
@functionsubindex{wrapped-matrix-elements}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Target Slot
@ref{❨229❩, , @t{elements}}.
@end table
@end deffn

@node Public generic functions, Public standalone methods, Public ordinary functions, Public Interface
@subsection Generic functions
@deffn {Generic Function} {as-alist} (object)
@anchor{❨287❩}@c
@genericsubindex{as-alist}@c
Return OBJECT as an ALIST.  Semantics depends on OBJECT.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Generic Function} {as-plist} (object)
@anchor{❨303❩}@c
@genericsubindex{as-plist}@c
Return OBJECT as a PLIST.  Semantics depends on OBJECT.  The default method uses AS-ALIST.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@item Methods
@deffn {Method} {as-plist} (object)
@anchor{❨304❩}@c
@methodsubindex{as-plist}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {diagonal-vector} (matrix)
@anchor{❨223❩}@c
@genericsubindex{diagonal-vector}@c
Return the diagonal elements of MATRIX as a vector.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Methods
@deffn {Method} {diagonal-vector} ((matrix @t{array}))
@anchor{❨224❩}@c
@methodsubindex{diagonal-vector}@c
@table @strong
@end table
@end deffn
@deffn {Method} {diagonal-vector} (matrix)
@anchor{❨225❩}@c
@methodsubindex{diagonal-vector}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {(setf diagonal-vector)} (matrix)
@anchor{❨226❩}@c
@genericsubindex{(setf diagonal-vector)}@c
Set the diagonal elements of MATRIX using VECTOR.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Methods
@deffn {Method} {(setf diagonal-vector)} ((matrix @t{array}))
@anchor{❨227❩}@c
@methodsubindex{(setf diagonal-vector)}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e1-} (a)
@anchor{❨385❩}@c
@genericsubindex{e1-}@c
Univariate elementwise -.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e1-} ((a @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨386❩}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1-} ((a @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨387❩}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1-} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨388❩}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1-} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨389❩}@c
@methodsubindex{e1-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1-} ((a @t{number}))
@anchor{❨390❩}@c
@methodsubindex{e1-}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e1-} ((a @t{array}))
@anchor{❨391❩}@c
@methodsubindex{e1-}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e1/} (a)
@anchor{❨378❩}@c
@genericsubindex{e1/}@c
Univariate elementwise /.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e1/} ((a @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨379❩}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1/} ((a @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨380❩}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1/} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨381❩}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1/} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨382❩}@c
@methodsubindex{e1/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1/} ((a @t{number}))
@anchor{❨383❩}@c
@methodsubindex{e1/}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e1/} ((a @t{array}))
@anchor{❨384❩}@c
@methodsubindex{e1/}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e1log} (a)
@anchor{❨454❩}@c
@genericsubindex{e1log}@c
Univariate elementwise LOG.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e1log} ((a @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨455❩}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1log} ((a @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨456❩}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1log} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨457❩}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1log} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨458❩}@c
@methodsubindex{e1log}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e1log} ((a @t{number}))
@anchor{❨459❩}@c
@methodsubindex{e1log}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e1log} ((a @t{array}))
@anchor{❨460❩}@c
@methodsubindex{e1log}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2*} (a b)
@anchor{❨475❩}@c
@genericsubindex{e2*}@c
Bivariate elementwise *.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e2*} ((a @ref{❨236❩, , @t{diagonal-matrix}}) (b @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨476❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨222❩, , @t{hermitian-matrix}}) (b @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨477❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}) (b @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨478❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}) (b @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨479❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{number}) (b @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨480❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨236❩, , @t{diagonal-matrix}}) (b @t{number}))
@anchor{❨481❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{number}) (b @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨482❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨222❩, , @t{hermitian-matrix}}) (b @t{number}))
@anchor{❨483❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{number}) (b @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨484❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}) (b @t{number}))
@anchor{❨485❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{number}) (b @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨486❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}) (b @t{number}))
@anchor{❨487❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} (a (b @ref{❨228❩, , @t{wrapped-matrix}}))
@anchor{❨488❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @ref{❨228❩, , @t{wrapped-matrix}}) b)
@anchor{❨489❩}@c
@methodsubindex{e2*}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{number}) (b @t{number}))
@anchor{❨490❩}@c
@methodsubindex{e2*}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{vector}) (b @t{number}))
@anchor{❨491❩}@c
@methodsubindex{e2*}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{number}) (b @t{vector}))
@anchor{❨492❩}@c
@methodsubindex{e2*}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{vector}) (b @t{vector}))
@anchor{❨493❩}@c
@methodsubindex{e2*}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{array}) (b @t{number}))
@anchor{❨494❩}@c
@methodsubindex{e2*}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{number}) (b @t{array}))
@anchor{❨495❩}@c
@methodsubindex{e2*}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2*} ((a @t{array}) (b @t{array}))
@anchor{❨496❩}@c
@methodsubindex{e2*}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2+} (a b)
@anchor{❨461❩}@c
@genericsubindex{e2+}@c
Bivariate elementwise +.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e2+} ((a @ref{❨236❩, , @t{diagonal-matrix}}) (b @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨462❩}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2+} ((a @ref{❨222❩, , @t{hermitian-matrix}}) (b @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨463❩}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2+} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}) (b @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨464❩}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2+} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}) (b @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨465❩}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2+} (a (b @ref{❨228❩, , @t{wrapped-matrix}}))
@anchor{❨466❩}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2+} ((a @ref{❨228❩, , @t{wrapped-matrix}}) b)
@anchor{❨467❩}@c
@methodsubindex{e2+}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2+} ((a @t{number}) (b @t{number}))
@anchor{❨468❩}@c
@methodsubindex{e2+}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2+} ((a @t{vector}) (b @t{number}))
@anchor{❨469❩}@c
@methodsubindex{e2+}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2+} ((a @t{number}) (b @t{vector}))
@anchor{❨470❩}@c
@methodsubindex{e2+}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2+} ((a @t{vector}) (b @t{vector}))
@anchor{❨471❩}@c
@methodsubindex{e2+}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2+} ((a @t{array}) (b @t{number}))
@anchor{❨472❩}@c
@methodsubindex{e2+}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2+} ((a @t{number}) (b @t{array}))
@anchor{❨473❩}@c
@methodsubindex{e2+}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2+} ((a @t{array}) (b @t{array}))
@anchor{❨474❩}@c
@methodsubindex{e2+}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2-} (a b)
@anchor{❨516❩}@c
@genericsubindex{e2-}@c
Bivariate elementwise -.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e2-} ((a @ref{❨236❩, , @t{diagonal-matrix}}) (b @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨517❩}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2-} ((a @ref{❨222❩, , @t{hermitian-matrix}}) (b @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨518❩}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2-} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}) (b @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨519❩}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2-} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}) (b @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨520❩}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2-} (a (b @ref{❨228❩, , @t{wrapped-matrix}}))
@anchor{❨521❩}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2-} ((a @ref{❨228❩, , @t{wrapped-matrix}}) b)
@anchor{❨522❩}@c
@methodsubindex{e2-}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2-} ((a @t{number}) (b @t{number}))
@anchor{❨523❩}@c
@methodsubindex{e2-}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2-} ((a @t{vector}) (b @t{number}))
@anchor{❨524❩}@c
@methodsubindex{e2-}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2-} ((a @t{number}) (b @t{vector}))
@anchor{❨525❩}@c
@methodsubindex{e2-}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2-} ((a @t{vector}) (b @t{vector}))
@anchor{❨526❩}@c
@methodsubindex{e2-}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2-} ((a @t{array}) (b @t{number}))
@anchor{❨527❩}@c
@methodsubindex{e2-}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2-} ((a @t{number}) (b @t{array}))
@anchor{❨528❩}@c
@methodsubindex{e2-}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2-} ((a @t{array}) (b @t{array}))
@anchor{❨529❩}@c
@methodsubindex{e2-}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2/} (a b)
@anchor{❨423❩}@c
@genericsubindex{e2/}@c
Bivariate elementwise /.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e2/} ((a @t{number}) (b @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨424❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @ref{❨236❩, , @t{diagonal-matrix}}) (b @t{number}))
@anchor{❨425❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{number}) (b @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨426❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @ref{❨222❩, , @t{hermitian-matrix}}) (b @t{number}))
@anchor{❨427❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{number}) (b @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨428❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}) (b @t{number}))
@anchor{❨429❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{number}) (b @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨430❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}) (b @t{number}))
@anchor{❨431❩}@c
@methodsubindex{e2/}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{number}) (b @t{number}))
@anchor{❨432❩}@c
@methodsubindex{e2/}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{vector}) (b @t{number}))
@anchor{❨433❩}@c
@methodsubindex{e2/}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{number}) (b @t{vector}))
@anchor{❨434❩}@c
@methodsubindex{e2/}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{vector}) (b @t{vector}))
@anchor{❨435❩}@c
@methodsubindex{e2/}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{array}) (b @t{number}))
@anchor{❨436❩}@c
@methodsubindex{e2/}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{number}) (b @t{array}))
@anchor{❨437❩}@c
@methodsubindex{e2/}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2/} ((a @t{array}) (b @t{array}))
@anchor{❨438❩}@c
@methodsubindex{e2/}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {e2log} (a b)
@anchor{❨497❩}@c
@genericsubindex{e2log}@c
Bivariate elementwise LOG.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {e2log} ((a @t{number}) (b @t{number}))
@anchor{❨498❩}@c
@methodsubindex{e2log}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2log} ((a @t{vector}) (b @t{number}))
@anchor{❨499❩}@c
@methodsubindex{e2log}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2log} ((a @t{number}) (b @t{vector}))
@anchor{❨500❩}@c
@methodsubindex{e2log}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2log} ((a @t{vector}) (b @t{vector}))
@anchor{❨501❩}@c
@methodsubindex{e2log}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2log} ((a @t{array}) (b @t{number}))
@anchor{❨502❩}@c
@methodsubindex{e2log}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2log} ((a @t{number}) (b @t{array}))
@anchor{❨503❩}@c
@methodsubindex{e2log}@c
@table @strong
@end table
@end deffn
@deffn {Method} {e2log} ((a @t{array}) (b @t{array}))
@anchor{❨504❩}@c
@methodsubindex{e2log}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {eceiling} (a)
@anchor{❨393❩}@c
@genericsubindex{eceiling}@c
Univariate elementwise CEILING.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {eceiling} ((a @t{number}))
@anchor{❨394❩}@c
@methodsubindex{eceiling}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eceiling} ((a @t{array}))
@anchor{❨395❩}@c
@methodsubindex{eceiling}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {econjugate} (a)
@anchor{❨451❩}@c
@genericsubindex{econjugate}@c
Univariate elementwise CONJUGATE.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {econjugate} ((a @t{number}))
@anchor{❨452❩}@c
@methodsubindex{econjugate}@c
@table @strong
@end table
@end deffn
@deffn {Method} {econjugate} ((a @t{array}))
@anchor{❨453❩}@c
@methodsubindex{econjugate}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {ecos} (a)
@anchor{❨396❩}@c
@genericsubindex{ecos}@c
Univariate elementwise COS.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {ecos} ((a @t{number}))
@anchor{❨397❩}@c
@methodsubindex{ecos}@c
@table @strong
@end table
@end deffn
@deffn {Method} {ecos} ((a @t{array}))
@anchor{❨398❩}@c
@methodsubindex{ecos}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {eexp} (a)
@anchor{❨441❩}@c
@genericsubindex{eexp}@c
Univariate elementwise EXP.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {eexp} ((a @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨442❩}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {eexp} ((a @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨443❩}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {eexp} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨444❩}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {eexp} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨445❩}@c
@methodsubindex{eexp}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {eexp} ((a @t{number}))
@anchor{❨446❩}@c
@methodsubindex{eexp}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eexp} ((a @t{array}))
@anchor{❨447❩}@c
@methodsubindex{eexp}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {eexpt} (a b)
@anchor{❨415❩}@c
@genericsubindex{eexpt}@c
Bivariate elementwise EXPT.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {eexpt} ((a @t{number}) (b @t{number}))
@anchor{❨416❩}@c
@methodsubindex{eexpt}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eexpt} ((a @t{vector}) (b @t{number}))
@anchor{❨417❩}@c
@methodsubindex{eexpt}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eexpt} ((a @t{number}) (b @t{vector}))
@anchor{❨418❩}@c
@methodsubindex{eexpt}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eexpt} ((a @t{vector}) (b @t{vector}))
@anchor{❨419❩}@c
@methodsubindex{eexpt}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eexpt} ((a @t{array}) (b @t{number}))
@anchor{❨420❩}@c
@methodsubindex{eexpt}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eexpt} ((a @t{number}) (b @t{array}))
@anchor{❨421❩}@c
@methodsubindex{eexpt}@c
@table @strong
@end table
@end deffn
@deffn {Method} {eexpt} ((a @t{array}) (b @t{array}))
@anchor{❨422❩}@c
@methodsubindex{eexpt}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {efloor} (a)
@anchor{❨448❩}@c
@genericsubindex{efloor}@c
Univariate elementwise FLOOR.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {efloor} ((a @t{number}))
@anchor{❨449❩}@c
@methodsubindex{efloor}@c
@table @strong
@end table
@end deffn
@deffn {Method} {efloor} ((a @t{array}))
@anchor{❨450❩}@c
@methodsubindex{efloor}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {emod} (a b)
@anchor{❨507❩}@c
@genericsubindex{emod}@c
Bivariate elementwise MOD.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {emod} ((a @t{number}) (b @t{number}))
@anchor{❨508❩}@c
@methodsubindex{emod}@c
@table @strong
@end table
@end deffn
@deffn {Method} {emod} ((a @t{vector}) (b @t{number}))
@anchor{❨509❩}@c
@methodsubindex{emod}@c
@table @strong
@end table
@end deffn
@deffn {Method} {emod} ((a @t{number}) (b @t{vector}))
@anchor{❨510❩}@c
@methodsubindex{emod}@c
@table @strong
@end table
@end deffn
@deffn {Method} {emod} ((a @t{vector}) (b @t{vector}))
@anchor{❨511❩}@c
@methodsubindex{emod}@c
@table @strong
@end table
@end deffn
@deffn {Method} {emod} ((a @t{array}) (b @t{number}))
@anchor{❨512❩}@c
@methodsubindex{emod}@c
@table @strong
@end table
@end deffn
@deffn {Method} {emod} ((a @t{number}) (b @t{array}))
@anchor{❨513❩}@c
@methodsubindex{emod}@c
@table @strong
@end table
@end deffn
@deffn {Method} {emod} ((a @t{array}) (b @t{array}))
@anchor{❨514❩}@c
@methodsubindex{emod}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {ereduce} (function object &key key)
@anchor{❨400❩}@c
@genericsubindex{ereduce}@c
Elementwise reduce@comma{} traversing in row-major order.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {ereduce} (function (array @t{array}) &key key)
@anchor{❨401❩}@c
@methodsubindex{ereduce}@c
@table @strong
@end table
@end deffn
@deffn {Method} {ereduce} (function (sequence @t{sequence}) &key key)
@anchor{❨402❩}@c
@methodsubindex{ereduce}@c
@table @strong
@end table
@end deffn
@deffn {Method} {ereduce} (function object &key key)
@anchor{❨403❩}@c
@methodsubindex{ereduce}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {esin} (a)
@anchor{❨405❩}@c
@genericsubindex{esin}@c
Univariate elementwise SIN.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {esin} ((a @t{number}))
@anchor{❨406❩}@c
@methodsubindex{esin}@c
@table @strong
@end table
@end deffn
@deffn {Method} {esin} ((a @t{array}))
@anchor{❨407❩}@c
@methodsubindex{esin}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {esqrt} (a)
@anchor{❨408❩}@c
@genericsubindex{esqrt}@c
Univariate elementwise SQRT.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {esqrt} ((a @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨409❩}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {esqrt} ((a @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨410❩}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {esqrt} ((a @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨411❩}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {esqrt} ((a @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨412❩}@c
@methodsubindex{esqrt}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {esqrt} ((a @t{number}))
@anchor{❨413❩}@c
@methodsubindex{esqrt}@c
@table @strong
@end table
@end deffn
@deffn {Method} {esqrt} ((a @t{array}))
@anchor{❨414❩}@c
@methodsubindex{esqrt}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {extend-interval} (interval object)
@anchor{❨138❩}@c
@genericsubindex{extend-interval}@c
Return an interval that includes INTERVAL and OBJECT.  NIL
stands for the empty set.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {extend-interval} ((interval @t{null}) (object @t{null}))
@anchor{❨139❩}@c
@methodsubindex{extend-interval}@c
@table @strong
@end table
@end deffn
@deffn {Method} {extend-interval} ((interval @t{null}) (number @t{real}))
@anchor{❨140❩}@c
@methodsubindex{extend-interval}@c
@table @strong
@end table
@end deffn
@deffn {Method} {extend-interval} ((interval @ref{❨170❩, , @t{interval}}) (number @t{real}))
@anchor{❨141❩}@c
@methodsubindex{extend-interval}@c
@table @strong
@end table
@end deffn
@deffn {Method} {extend-interval} (interval (object @ref{❨170❩, , @t{interval}}))
@anchor{❨142❩}@c
@methodsubindex{extend-interval}@c
@table @strong
@end table
@end deffn
@deffn {Method} {extend-interval} (interval (list @t{list}))
@anchor{❨143❩}@c
@methodsubindex{extend-interval}@c
@table @strong
@end table
@end deffn
@deffn {Method} {extend-interval} (interval (array @t{array}))
@anchor{❨144❩}@c
@methodsubindex{extend-interval}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {l2norm-square} (object)
@anchor{❨344❩}@c
@genericsubindex{l2norm-square}@c
Square of the $L_2$ norm of OBJECT.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@item Methods
@deffn {Method} {l2norm-square} ((sequence @t{sequence}))
@anchor{❨345❩}@c
@methodsubindex{l2norm-square}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {left} (interval)
@anchor{❨155❩}@c
@genericsubindex{left}@c
Left endpoint of interval.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {left} ((interval @ref{❨182❩, , @t{interval/infinite-left}}))
@anchor{❨156❩}@c
@methodsubindex{left}@c
@table @strong
@end table
@end deffn
@deffn {Reader Method} {left} ((interval/finite-left @ref{❨190❩, , @t{interval/finite-left}}))
@anchor{❨157❩}@c
@methodsubindex{left}@c
automatically generated reader method
@table @strong
@item Target Slot
@ref{❨191❩, , @t{left}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {map-array} (array function &optional retval)
@anchor{❨219❩}@c
@genericsubindex{map-array}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Methods
@deffn {Method} {map-array} (array function &optional retval)
@anchor{❨220❩}@c
@methodsubindex{map-array}@c
Apply FUNCTION to each element of ARRAY@*
Return a new array@comma{} or write into the optional 3rd argument.
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {num=} (a b &optional tolerance)
@anchor{❨541❩}@c
@genericsubindex{num=}@c
Compare A and B for approximate equality@comma{} checking corresponding elements when applicable (using TOLERANCE).@*

Two numbers A and B are NUM= iff |a-b|/max(1@comma{}|a|@comma{}|b|) <= tolerance.@*

Unless a method is defined for them@comma{} two objects are compared with EQUALP.@*

Generally@comma{} methods should be defined so that two objects are NUM= if they the same class@comma{} same dimensions@comma{} and all their elements are NUM=.
@table @strong
@item Package
@ref{❨32❩, , @t{num-utils.num=}}.
@item Source
@ref{❨5❩, , @t{num=.lisp}}.
@item Methods
@deffn {Method} {num=} ((a @ref{❨236❩, , @t{diagonal-matrix}}) (b @ref{❨236❩, , @t{diagonal-matrix}}) &optional tolerance)
@anchor{❨542❩}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {num=} ((a @ref{❨228❩, , @t{wrapped-matrix}}) (b @ref{❨228❩, , @t{wrapped-matrix}}) &optional tolerance)
@anchor{❨543❩}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {num=} ((a @ref{❨172❩, , @t{finite-interval}}) (b @ref{❨172❩, , @t{finite-interval}}) &optional tolerance)
@anchor{❨544❩}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Method} {num=} ((a @ref{❨148❩, , @t{real-line}}) (b @ref{❨148❩, , @t{real-line}}) &optional tolerance)
@anchor{❨545❩}@c
@methodsubindex{num=}@c
@table @strong
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Method} {num=} (a b &optional tolerance)
@anchor{❨546❩}@c
@methodsubindex{num=}@c
@table @strong
@end table
@end deffn
@deffn {Method} {num=} ((a @t{number}) (b @t{number}) &optional tolerance)
@anchor{❨547❩}@c
@methodsubindex{num=}@c
@table @strong
@end table
@end deffn
@deffn {Method} {num=} ((a @t{array}) (b @t{array}) &optional tolerance)
@anchor{❨548❩}@c
@methodsubindex{num=}@c
@table @strong
@end table
@end deffn
@deffn {Method} {num=} ((a @t{cons}) (b @t{cons}) &optional tolerance)
@anchor{❨549❩}@c
@methodsubindex{num=}@c
@table @strong
@end table
@end deffn
@deffn {Method} {num=} ((a @t{null}) (b @t{null}) &optional tolerance)
@anchor{❨550❩}@c
@methodsubindex{num=}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {open-left?} (interval)
@anchor{❨135❩}@c
@genericsubindex{open-left?}@c
True iff the left endpoint of the interval is open.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {open-left?} ((interval @ref{❨182❩, , @t{interval/infinite-left}}))
@anchor{❨136❩}@c
@methodsubindex{open-left?}@c
@table @strong
@end table
@end deffn
@deffn {Reader Method} {open-left?} ((interval/finite-left @ref{❨190❩, , @t{interval/finite-left}}))
@anchor{❨137❩}@c
@methodsubindex{open-left?}@c
automatically generated reader method
@table @strong
@item Target Slot
@ref{❨192❩, , @t{open-left?}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {open-right?} (interval)
@anchor{❨173❩}@c
@genericsubindex{open-right?}@c
True iff the right endpoint of the interval is open.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {open-right?} ((interval @ref{❨196❩, , @t{interval/infinite-right}}))
@anchor{❨174❩}@c
@methodsubindex{open-right?}@c
@table @strong
@end table
@end deffn
@deffn {Reader Method} {open-right?} ((interval/finite-right @ref{❨187❩, , @t{interval/finite-right}}))
@anchor{❨175❩}@c
@methodsubindex{open-right?}@c
automatically generated reader method
@table @strong
@item Target Slot
@ref{❨189❩, , @t{open-right?}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {product} (object)
@anchor{❨357❩}@c
@genericsubindex{product}@c
Product of elements in object.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@item Methods
@deffn {Method} {product} ((sequence @t{sequence}))
@anchor{❨358❩}@c
@methodsubindex{product}@c
@table @strong
@end table
@end deffn
@deffn {Method} {product} ((array @t{array}))
@anchor{❨359❩}@c
@methodsubindex{product}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {right} (interval)
@anchor{❨164❩}@c
@genericsubindex{right}@c
Right endpoint of interval.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {right} ((interval @ref{❨196❩, , @t{interval/infinite-right}}))
@anchor{❨165❩}@c
@methodsubindex{right}@c
@table @strong
@end table
@end deffn
@deffn {Reader Method} {right} ((interval/finite-right @ref{❨187❩, , @t{interval/finite-right}}))
@anchor{❨166❩}@c
@methodsubindex{right}@c
automatically generated reader method
@table @strong
@item Target Slot
@ref{❨188❩, , @t{right}}.
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {shift-interval} (interval offset)
@anchor{❨162❩}@c
@genericsubindex{shift-interval}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {shift-interval} ((interval @ref{❨172❩, , @t{finite-interval}}) (offset @t{real}))
@anchor{❨163❩}@c
@methodsubindex{shift-interval}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {sum} (object &key key)
@anchor{❨347❩}@c
@genericsubindex{sum}@c
Sum of elements in object.  KEY is applied to each
  element.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@item Methods
@deffn {Method} {sum} ((sequence @t{sequence}) &key key)
@anchor{❨348❩}@c
@methodsubindex{sum}@c
@table @strong
@end table
@end deffn
@deffn {Method} {sum} ((array @t{array}) &key key)
@anchor{❨349❩}@c
@methodsubindex{sum}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {transpose} (array)
@anchor{❨238❩}@c
@genericsubindex{transpose}@c
Transpose.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Methods
@deffn {Method} {transpose} ((array @t{array}))
@anchor{❨239❩}@c
@methodsubindex{transpose}@c
@table @strong
@end table
@end deffn
@deffn {Method} {transpose} ((matrix @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨240❩}@c
@methodsubindex{transpose}@c
@table @strong
@end table
@end deffn
@deffn {Method} {transpose} ((matrix @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨241❩}@c
@methodsubindex{transpose}@c
@table @strong
@end table
@end deffn
@deffn {Method} {transpose} ((matrix @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨242❩}@c
@methodsubindex{transpose}@c
@table @strong
@end table
@end deffn
@deffn {Method} {transpose} ((diagonal @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨243❩}@c
@methodsubindex{transpose}@c
@table @strong
@end table
@end deffn
@end table
@end deffn

@node Public standalone methods, Public structures, Public generic functions, Public Interface
@subsection Standalone methods
@deffn {Method} {as-array} ((matrix0 @ref{❨218❩, , @t{upper-triangular-matrix}}))
@anchor{❨591❩}@c
@methodsubindex{as-array}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {as-array} ((matrix0 @ref{❨222❩, , @t{hermitian-matrix}}))
@anchor{❨594❩}@c
@methodsubindex{as-array}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {as-array} ((matrix0 @ref{❨234❩, , @t{lower-triangular-matrix}}))
@anchor{❨600❩}@c
@methodsubindex{as-array}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {as-array} ((diagonal-matrix @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨603❩}@c
@methodsubindex{as-array}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {dims} ((wrapped-matrix @ref{❨228❩, , @t{wrapped-matrix}}))
@anchor{❨596❩}@c
@methodsubindex{dims}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {dims} ((diagonal-matrix @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨601❩}@c
@methodsubindex{dims}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {element-type} ((wrapped-matrix @ref{❨228❩, , @t{wrapped-matrix}}))
@anchor{❨597❩}@c
@methodsubindex{element-type}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {element-type} ((diagonal-matrix @ref{❨236❩, , @t{diagonal-matrix}}))
@anchor{❨602❩}@c
@methodsubindex{element-type}@c
@table @strong
@item Package
@t{array-operations/generic}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {initialize-instance} :after ((interval @ref{❨172❩, , @t{finite-interval}}) &key &allow-other-keys)
@anchor{❨588❩}@c
@methodsubindex{initialize-instance}@c
@table @strong
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((interval @ref{❨170❩, , @t{interval}}) stream)
@anchor{❨587❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((matrix0 @ref{❨218❩, , @t{upper-triangular-matrix}}) stream1)
@anchor{❨590❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((matrix0 @ref{❨222❩, , @t{hermitian-matrix}}) stream1)
@anchor{❨593❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {print-object} ((matrix0 @ref{❨234❩, , @t{lower-triangular-matrix}}) stream1)
@anchor{❨599❩}@c
@methodsubindex{print-object}@c
@table @strong
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {select} ((matrix0 @ref{❨218❩, , @t{upper-triangular-matrix}}) &rest slices)
@anchor{❨589❩}@c
@methodsubindex{select}@c
@table @strong
@item Package
@t{select}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {select} ((matrix0 @ref{❨222❩, , @t{hermitian-matrix}}) &rest slices)
@anchor{❨592❩}@c
@methodsubindex{select}@c
@table @strong
@item Package
@t{select}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Method} {select} ((matrix0 @ref{❨234❩, , @t{lower-triangular-matrix}}) &rest slices)
@anchor{❨598❩}@c
@methodsubindex{select}@c
@table @strong
@item Package
@t{select}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn

@node Public structures, Public classes, Public standalone methods, Public Interface
@subsection Structures
@deftp {Structure} {diagonal-matrix}
@anchor{❨236❩}@c
@structuresubindex{diagonal-matrix}@c
Diagonal matrix.  The elements in the diagonal are stored in a vector.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct methods
@itemize @bullet
@item
@ref{❨603❩, , @t{as-array}}.
@item
@ref{❨601❩, , @t{dims}}.
@item
@ref{❨386❩, , @t{e1-}}.
@item
@ref{❨379❩, , @t{e1/}}.
@item
@ref{❨455❩, , @t{e1log}}.
@item
@ref{❨476❩, , @t{e2*}}.
@item
@ref{❨480❩, , @t{e2*}}.
@item
@ref{❨481❩, , @t{e2*}}.
@item
@ref{❨462❩, , @t{e2+}}.
@item
@ref{❨517❩, , @t{e2-}}.
@item
@ref{❨424❩, , @t{e2/}}.
@item
@ref{❨425❩, , @t{e2/}}.
@item
@ref{❨442❩, , @t{eexp}}.
@item
@ref{❨602❩, , @t{element-type}}.
@item
@ref{❨409❩, , @t{esqrt}}.
@item
@ref{❨542❩, , @t{num=}}.
@item
@ref{❨243❩, , @t{transpose}}.
@end itemize
@item Direct slots
@defvr {Slot} {elements}
@anchor{❨237❩}@c
@slotsubindex{elements}@c
@table @strong
@item Type
@t{vector}
@item Readers
@ref{❨231❩, , @t{diagonal-matrix-elements}}.
@item Writers
@ref{❨232❩, , @t{(setf diagonal-matrix-elements)}}.
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {hermitian-matrix}
@anchor{❨222❩}@c
@structuresubindex{hermitian-matrix}@c
Hermitian/symmetric matrix@comma{} with elements stored in the _lower_ triangle.@*

Implements _both_ real symmetric and complex Hermitian matrices --- as technically@comma{} real symmetric matrices are also Hermitian.  Complex symmetric matrices are _not_ implemented as a special matrix type@comma{} as they don't have any special properties (eg real eigenvalues@comma{} etc).
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Direct superclasses
@ref{❨228❩, , @t{wrapped-matrix}}.
@item Direct methods
@itemize @bullet
@item
@ref{❨594❩, , @t{as-array}}.
@item
@ref{❨387❩, , @t{e1-}}.
@item
@ref{❨380❩, , @t{e1/}}.
@item
@ref{❨456❩, , @t{e1log}}.
@item
@ref{❨477❩, , @t{e2*}}.
@item
@ref{❨482❩, , @t{e2*}}.
@item
@ref{❨483❩, , @t{e2*}}.
@item
@ref{❨463❩, , @t{e2+}}.
@item
@ref{❨518❩, , @t{e2-}}.
@item
@ref{❨426❩, , @t{e2/}}.
@item
@ref{❨427❩, , @t{e2/}}.
@item
@ref{❨443❩, , @t{eexp}}.
@item
@ref{❨410❩, , @t{esqrt}}.
@item
@ref{❨593❩, , @t{print-object}}.
@item
@ref{❨592❩, , @t{select}}.
@item
@ref{❨242❩, , @t{transpose}}.
@end itemize
@end table
@end deftp
@deftp {Structure} {lower-triangular-matrix}
@anchor{❨234❩}@c
@structuresubindex{lower-triangular-matrix}@c
Lower triangular matrix.  ELEMENTS in the upper triangle are treated as zero.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Direct superclasses
@ref{❨228❩, , @t{wrapped-matrix}}.
@item Direct methods
@itemize @bullet
@item
@ref{❨600❩, , @t{as-array}}.
@item
@ref{❨389❩, , @t{e1-}}.
@item
@ref{❨382❩, , @t{e1/}}.
@item
@ref{❨458❩, , @t{e1log}}.
@item
@ref{❨479❩, , @t{e2*}}.
@item
@ref{❨486❩, , @t{e2*}}.
@item
@ref{❨487❩, , @t{e2*}}.
@item
@ref{❨465❩, , @t{e2+}}.
@item
@ref{❨520❩, , @t{e2-}}.
@item
@ref{❨430❩, , @t{e2/}}.
@item
@ref{❨431❩, , @t{e2/}}.
@item
@ref{❨445❩, , @t{eexp}}.
@item
@ref{❨412❩, , @t{esqrt}}.
@item
@ref{❨599❩, , @t{print-object}}.
@item
@ref{❨598❩, , @t{select}}.
@item
@ref{❨240❩, , @t{transpose}}.
@end itemize
@end table
@end deftp
@deftp {Structure} {relative}
@anchor{❨160❩}@c
@structuresubindex{relative}@c
Relative sizes are in terms of width.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct slots
@defvr {Slot} {fraction}
@anchor{❨161❩}@c
@slotsubindex{fraction}@c
@table @strong
@item Type
@t{(real 0)}
@item Readers
@ref{❨178❩, , @t{relative-fraction}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {spacer}
@anchor{❨146❩}@c
@structuresubindex{spacer}@c
Spacers divide the leftover portion of an interval.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct slots
@defvr {Slot} {weight}
@anchor{❨147❩}@c
@slotsubindex{weight}@c
@table @strong
@item Type
@t{(real 0)}
@item Initform
@t{1}
@item Readers
@ref{❨194❩, , @t{spacer-weight}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {test-results}
@anchor{❨318❩}@c
@structuresubindex{test-results}@c
Differences between reference values and computed values
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct slots
@defvr {Slot} {worst-case}
@anchor{❨319❩}@c
@slotsubindex{worst-case}@c
@table @strong
@item Type
@t{integer}
@item Initform
@t{0}
@item Readers
@ref{❨337❩, , @t{worst-case}}.
@item Writers
@ref{❨338❩, , @t{(setf worst-case)}}.
@end table
@end defvr
@defvr {Slot} {min-error}
@anchor{❨320❩}@c
@slotsubindex{min-error}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{❨316❩, , @t{min-error}}.
@item Writers
@ref{❨317❩, , @t{(setf min-error)}}.
@end table
@end defvr
@defvr {Slot} {max-error}
@anchor{❨321❩}@c
@slotsubindex{max-error}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{❨329❩, , @t{max-error}}.
@item Writers
@ref{❨330❩, , @t{(setf max-error)}}.
@end table
@end defvr
@defvr {Slot} {mean-error}
@anchor{❨322❩}@c
@slotsubindex{mean-error}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{❨327❩, , @t{mean-error}}.
@item Writers
@ref{❨328❩, , @t{(setf mean-error)}}.
@end table
@end defvr
@defvr {Slot} {test-count}
@anchor{❨323❩}@c
@slotsubindex{test-count}@c
@table @strong
@item Type
@t{integer}
@item Initform
@t{0}
@item Readers
@ref{❨335❩, , @t{test-count}}.
@item Writers
@ref{❨336❩, , @t{(setf test-count)}}.
@end table
@end defvr
@defvr {Slot} {variance0}
@anchor{❨324❩}@c
@slotsubindex{variance0}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{❨331❩, , @t{variance0}}.
@item Writers
@ref{❨332❩, , @t{(setf variance0)}}.
@end table
@end defvr
@defvr {Slot} {variance1}
@anchor{❨325❩}@c
@slotsubindex{variance1}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{❨313❩, , @t{variance1}}.
@item Writers
@ref{❨314❩, , @t{(setf variance1)}}.
@end table
@end defvr
@defvr {Slot} {rms}
@anchor{❨326❩}@c
@slotsubindex{rms}@c
@table @strong
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{❨339❩, , @t{rms}}.
@item Writers
@ref{❨340❩, , @t{(setf rms)}}.
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {upper-triangular-matrix}
@anchor{❨218❩}@c
@structuresubindex{upper-triangular-matrix}@c
Upper triangular matrix.  ELEMENTS in the lower triangle are treated as zero.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Direct superclasses
@ref{❨228❩, , @t{wrapped-matrix}}.
@item Direct methods
@itemize @bullet
@item
@ref{❨591❩, , @t{as-array}}.
@item
@ref{❨388❩, , @t{e1-}}.
@item
@ref{❨381❩, , @t{e1/}}.
@item
@ref{❨457❩, , @t{e1log}}.
@item
@ref{❨478❩, , @t{e2*}}.
@item
@ref{❨484❩, , @t{e2*}}.
@item
@ref{❨485❩, , @t{e2*}}.
@item
@ref{❨464❩, , @t{e2+}}.
@item
@ref{❨519❩, , @t{e2-}}.
@item
@ref{❨428❩, , @t{e2/}}.
@item
@ref{❨429❩, , @t{e2/}}.
@item
@ref{❨444❩, , @t{eexp}}.
@item
@ref{❨411❩, , @t{esqrt}}.
@item
@ref{❨590❩, , @t{print-object}}.
@item
@ref{❨589❩, , @t{select}}.
@item
@ref{❨241❩, , @t{transpose}}.
@end itemize
@end table
@end deftp
@deftp {Structure} {wrapped-matrix}
@anchor{❨228❩}@c
@structuresubindex{wrapped-matrix}@c
A matrix that has some special structure (eg triangular@comma{} symmetric/hermitian).  ELEMENTS is always a matrix.  Not used directly@comma{} not exported.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨222❩, , @t{hermitian-matrix}}.
@item
@ref{❨234❩, , @t{lower-triangular-matrix}}.
@item
@ref{❨218❩, , @t{upper-triangular-matrix}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨596❩, , @t{dims}}.
@item
@ref{❨488❩, , @t{e2*}}.
@item
@ref{❨489❩, , @t{e2*}}.
@item
@ref{❨466❩, , @t{e2+}}.
@item
@ref{❨467❩, , @t{e2+}}.
@item
@ref{❨521❩, , @t{e2-}}.
@item
@ref{❨522❩, , @t{e2-}}.
@item
@ref{❨597❩, , @t{element-type}}.
@item
@ref{❨543❩, , @t{num=}}.
@end itemize
@item Direct slots
@defvr {Slot} {elements}
@anchor{❨229❩}@c
@slotsubindex{elements}@c
@table @strong
@item Type
@t{(array * (* *))}
@item Readers
@ref{❨230❩, , @t{wrapped-matrix-elements}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp

@node Public classes, Public types, Public structures, Public Interface
@subsection Classes
@deftp {Class} {finite-interval}
@anchor{❨172❩}@c
@classsubindex{finite-interval}@c
Interval with finite endpoints.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct superclasses
@itemize @bullet
@item
@ref{❨170❩, , @t{interval}}.
@item
@ref{❨190❩, , @t{interval/finite-left}}.
@item
@ref{❨187❩, , @t{interval/finite-right}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨128❩, , @t{chebyshev-approximate-implementation}}.
@item
@ref{❨588❩, , @t{initialize-instance}}.
@item
@ref{❨544❩, , @t{num=}}.
@item
@ref{❨163❩, , @t{shift-interval}}.
@item
@ref{❨52❩, , @t{transformed-quadrature}}.
@end itemize
@end table
@end deftp
@deftp {Class} {interval}
@anchor{❨170❩}@c
@classsubindex{interval}@c
Abstract superclass for all intervals.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨172❩, , @t{finite-interval}}.
@item
@ref{❨171❩, , @t{minusinf-interval}}.
@item
@ref{❨150❩, , @t{plusinf-interval}}.
@item
@ref{❨148❩, , @t{real-line}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨141❩, , @t{extend-interval}}.
@item
@ref{❨142❩, , @t{extend-interval}}.
@item
@ref{❨587❩, , @t{print-object}}.
@end itemize
@end table
@end deftp
@deftp {Class} {minusinf-interval}
@anchor{❨171❩}@c
@classsubindex{minusinf-interval}@c
Interval from -∞ to RIGHT.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct superclasses
@itemize @bullet
@item
@ref{❨170❩, , @t{interval}}.
@item
@ref{❨187❩, , @t{interval/finite-right}}.
@item
@ref{❨182❩, , @t{interval/infinite-left}}.
@end itemize
@end table
@end deftp
@deftp {Class} {plusinf-interval}
@anchor{❨150❩}@c
@classsubindex{plusinf-interval}@c
Interval from LEFT to ∞.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct superclasses
@itemize @bullet
@item
@ref{❨170❩, , @t{interval}}.
@item
@ref{❨190❩, , @t{interval/finite-left}}.
@item
@ref{❨196❩, , @t{interval/infinite-right}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨127❩, , @t{chebyshev-approximate-implementation}}.
@item
@ref{❨53❩, , @t{transformed-quadrature}}.
@end itemize
@end table
@end deftp
@deftp {Class} {real-line}
@anchor{❨148❩}@c
@classsubindex{real-line}@c
Representing the real line (-∞@comma{}∞).
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct superclasses
@itemize @bullet
@item
@ref{❨170❩, , @t{interval}}.
@item
@ref{❨182❩, , @t{interval/infinite-left}}.
@item
@ref{❨196❩, , @t{interval/infinite-right}}.
@end itemize
@item Direct methods
@ref{❨545❩, , @t{num=}}.
@end table
@end deftp

@node Public types, , Public classes, Public Interface
@subsection Types
@deftp {Type} {extended-real} (&optional base)
@anchor{❨278❩}@c
@typesubindex{extended-real}@c
Extended real number.
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deftp
@deftp {Type} {simple-boolean-vector} (&optional length)
@anchor{❨297❩}@c
@typesubindex{simple-boolean-vector}@c
Vector of BOOLEAN elements.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deftp
@deftp {Type} {simple-double-float-vector} (&optional length)
@anchor{❨295❩}@c
@typesubindex{simple-double-float-vector}@c
Simple vector of double-float elements.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deftp
@deftp {Type} {simple-fixnum-vector} ()
@anchor{❨294❩}@c
@typesubindex{simple-fixnum-vector}@c
Simple vector of fixnum elements.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deftp
@deftp {Type} {simple-single-float-vector} (&optional length)
@anchor{❨305❩}@c
@typesubindex{simple-single-float-vector}@c
Simple vector of single-float elements.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deftp
@deftp {Type} {triangular-matrix} ()
@anchor{❨216❩}@c
@typesubindex{triangular-matrix}@c
Triangular matrix (either lower or upper).
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deftp


@c ---------
@c Internals
@c ---------
@node Internals, , Public Interface, Definitions
@section Internals
@menu
* Private macros::
* Private ordinary functions::
* Private generic functions::
* Private structures::
* Private classes::
* Private types::
@end menu

@node Private macros, Private ordinary functions, Internals, Internals
@subsection Macros
@deffn {Macro} {@ampchar{}diagonal-matrix} (elements)
@anchor{❨250❩}@c
@macrosubindex{@ampchar{}diagonal-matrix}@c
LET+ form for slots of the structure DIAGONAL-MATRIX.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Macro} {@ampchar{}diagonal-matrix-r/o} (elements)
@anchor{❨264❩}@c
@macrosubindex{@ampchar{}diagonal-matrix-r/o}@c
LET+ form for slots of the structure DIAGONAL-MATRIX.  Read-only.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-comparison} (name test)
@anchor{❨285❩}@c
@macrosubindex{define-comparison}@c
Define a comparison@comma{} extendeding a pairwise comparison to an arbitrary number of arguments.
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-e@ampchar{}} (operation &key function bivariate univariate docstring)
@anchor{❨535❩}@c
@macrosubindex{define-e@ampchar{}}@c
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-e1} (operation &key function docstring)
@anchor{❨534❩}@c
@macrosubindex{define-e1}@c
Define an univariate elementwise operation.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-e2} (operation &key function docstring)
@anchor{❨530❩}@c
@macrosubindex{define-e2}@c
Define a bivariate elementwise operation.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-elementwise-as-array} (type &key functions)
@anchor{❨257❩}@c
@macrosubindex{define-elementwise-as-array}@c
Define binary elementwise operations for FUNCTION@comma{} implemented by converting them to arrays.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-elementwise-reduction} (name function &optional docstring)
@anchor{❨536❩}@c
@macrosubindex{define-elementwise-reduction}@c
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-elementwise-same-class} (type &key functions elements-accessor)
@anchor{❨261❩}@c
@macrosubindex{define-elementwise-same-class}@c
Define binary elementwise operations for FUNCTION for two arguments of the same class.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-elementwise-univariate} (type &key functions elements-accessor)
@anchor{❨251❩}@c
@macrosubindex{define-elementwise-univariate}@c
Define unary elementwise operations for FUNCTION for all subclasses of wrapped-elements.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-elementwise-with-constant} (type &key functions elements-accessor)
@anchor{❨248❩}@c
@macrosubindex{define-elementwise-with-constant}@c
Define binary elementwise operations for FUNCTION for all subclasses of wrapped-elements.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-rounding-with-offset} (name function docstring)
@anchor{❨377❩}@c
@macrosubindex{define-rounding-with-offset}@c
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Macro} {define-wrapped-matrix} (type elements struct-docstring (masked-test masked-string) check-and-convert-elements regularize-elements)
@anchor{❨268❩}@c
@macrosubindex{define-wrapped-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Macro} {mapping-array} ((ref array &rest other) form)
@anchor{❨537❩}@c
@macrosubindex{mapping-array}@c
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@end table
@end deffn
@deffn {Macro} {univariate-rootfinder-loop%} (((f a b fa fb) (f-tested test-bracket delta epsilon)) &body body)
@anchor{❨558❩}@c
@macrosubindex{univariate-rootfinder-loop%}@c
Common parts for univariate rootfinder functions.@*

Sets up the following:@*

- function OPPOSITE-SIGN-P for checking that two numbers are on the opposite side of 0@*

- function EVALUATE-AND-RETURN-IF-WITHIN-EPSILON which checks that |f(x)| <= EPSILON@comma{} if so@comma{} returns from the block with (VALUES X FX T)@comma{} otherwise simply returns the value@*

- function RETURN-IF-WITHIN-TOLERANCE checks if the interval [A@comma{}B] bracketing X is small enough (smaller than TOLERANCE) and if so@comma{} returns (X FX NIL (INTERVAL A B))@*

- variables FA and FB to hold function values at A and B@*

Initially@comma{} it checks for either $f(a)$ or $f(b)$ being a root@comma{} and establishes $a leq b$ by exchanging $a@comma{}f(a)$ and $b@comma{}f(b)$ if necessary.  Also checks that $f(a)$ and $f(b)$ are of opposite sign.  Checks that both tolerance and epsilon are nonnegative.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end deffn

@node Private ordinary functions, Private generic functions, Private macros, Internals
@subsection Ordinary functions
@deffn {Function} {ab-to-cd-intercept-slope} (a b c d)
@anchor{❨132❩}@c
@functionsubindex{ab-to-cd-intercept-slope}@c
Return (values INTERCEPT SLOPE) for linear mapping x:-> intercept+slope*x
from [a@comma{}b] to [c@comma{}d].
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {ab-to-cinf} (z a b c)
@anchor{❨130❩}@c
@functionsubindex{ab-to-cinf}@c
Inverse of cinf-to-ab.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {above-diagonal?} (row col)
@anchor{❨260❩}@c
@functionsubindex{above-diagonal?}@c
Test if element with indexes row and col is (strictly) above the diagonal.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {below-diagonal?} (row col)
@anchor{❨256❩}@c
@functionsubindex{below-diagonal?}@c
Test if element with indexes row and col is (strictly) below the diagonal.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {boolean-sequence-p} (x)
@anchor{❨312❩}@c
@functionsubindex{boolean-sequence-p}@c
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {boolean?} (object)
@anchor{❨311❩}@c
@functionsubindex{boolean?}@c
Check type of OBJECT is BOOLEAN.
@table @strong
@item Package
@ref{❨28❩, , @t{num-utils.utilities}}.
@item Source
@ref{❨4❩, , @t{utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {chebyshev-recursion} (x value previous-value)
@anchor{❨131❩}@c
@functionsubindex{chebyshev-recursion}@c
Chebyshev polynomial recursion formula.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {cinf-to-ab} (x a b c)
@anchor{❨129❩}@c
@functionsubindex{cinf-to-ab}@c
Map x in [c@comma{}plus-infinity) to z in [a@comma{}b] using x -> (x-c)/(1+x-c)+(b-a)+a.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-diagonal-matrix} (instance)
@anchor{❨258❩}@c
@functionsubindex{copy-diagonal-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-hermitian-matrix} (instance)
@anchor{❨265❩}@c
@functionsubindex{copy-hermitian-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-iterative-quadrature} (instance)
@anchor{❨38❩}@c
@functionsubindex{copy-iterative-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-lower-triangular-matrix} (instance)
@anchor{❨244❩}@c
@functionsubindex{copy-lower-triangular-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-midpoint-quadrature} (instance)
@anchor{❨56❩}@c
@functionsubindex{copy-midpoint-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-relative} (instance)
@anchor{❨195❩}@c
@functionsubindex{copy-relative}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-richardson-extrapolation} (instance)
@anchor{❨83❩}@c
@functionsubindex{copy-richardson-extrapolation}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-spacer} (instance)
@anchor{❨186❩}@c
@functionsubindex{copy-spacer}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-test-results} (instance)
@anchor{❨341❩}@c
@functionsubindex{copy-test-results}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-trapezoidal-quadrature} (instance)
@anchor{❨78❩}@c
@functionsubindex{copy-trapezoidal-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-upper-triangular-matrix} (instance)
@anchor{❨269❩}@c
@functionsubindex{copy-upper-triangular-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {copy-wrapped-matrix} (instance)
@anchor{❨262❩}@c
@functionsubindex{copy-wrapped-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {diagonal-matrix-p} (object)
@anchor{❨247❩}@c
@functionsubindex{diagonal-matrix-p}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {ensure-valid-elements} (array rank &rest predicates)
@anchor{❨273❩}@c
@functionsubindex{ensure-valid-elements}@c
Convert OBJECT to an array@comma{} check that it

1. has the required rank@comma{}@*

2. has a valid sparse element type@comma{} and

3. that it satisfies PREDICATES.@*

Return the array.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {extend-pairwise-comparison} (test first rest)
@anchor{❨284❩}@c
@functionsubindex{extend-pairwise-comparison}@c
Extend TEST (a pairwise comparison) to an arbitrary number of arguments (but at least one@comma{} FIRST).
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deffn
@deffn {Function} {hermitian-matrix-elements} (instance)
@anchor{❨249❩}@c
@functionsubindex{hermitian-matrix-elements}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {hermitian-matrix-p} (object)
@anchor{❨253❩}@c
@functionsubindex{hermitian-matrix-p}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Reader} {iterative-quadrature-a} (instance)
@anchor{❨41❩}@c
@functionsubindex{iterative-quadrature-a}@c
@deffnx {Writer} {(setf iterative-quadrature-a)} (instance)
@anchor{❨42❩}@c
@functionsubindex{(setf iterative-quadrature-a)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨100❩, , @t{a}}.
@end table
@end deffn
@deffn {Reader} {iterative-quadrature-b} (instance)
@anchor{❨91❩}@c
@functionsubindex{iterative-quadrature-b}@c
@deffnx {Writer} {(setf iterative-quadrature-b)} (instance)
@anchor{❨92❩}@c
@functionsubindex{(setf iterative-quadrature-b)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨101❩, , @t{b}}.
@end table
@end deffn
@deffn {Reader} {iterative-quadrature-f} (instance)
@anchor{❨76❩}@c
@functionsubindex{iterative-quadrature-f}@c
@deffnx {Writer} {(setf iterative-quadrature-f)} (instance)
@anchor{❨77❩}@c
@functionsubindex{(setf iterative-quadrature-f)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨99❩, , @t{f}}.
@end table
@end deffn
@deffn {Reader} {iterative-quadrature-h} (instance)
@anchor{❨89❩}@c
@functionsubindex{iterative-quadrature-h}@c
@deffnx {Writer} {(setf iterative-quadrature-h)} (instance)
@anchor{❨90❩}@c
@functionsubindex{(setf iterative-quadrature-h)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨102❩, , @t{h}}.
@end table
@end deffn
@deffn {Reader} {iterative-quadrature-n} (instance)
@anchor{❨111❩}@c
@functionsubindex{iterative-quadrature-n}@c
@deffnx {Writer} {(setf iterative-quadrature-n)} (instance)
@anchor{❨112❩}@c
@functionsubindex{(setf iterative-quadrature-n)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨103❩, , @t{n}}.
@end table
@end deffn
@deffn {Function} {iterative-quadrature-p} (object)
@anchor{❨113❩}@c
@functionsubindex{iterative-quadrature-p}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Reader} {iterative-quadrature-sum} (instance)
@anchor{❨66❩}@c
@functionsubindex{iterative-quadrature-sum}@c
@deffnx {Writer} {(setf iterative-quadrature-sum)} (instance)
@anchor{❨67❩}@c
@functionsubindex{(setf iterative-quadrature-sum)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨104❩, , @t{sum}}.
@end table
@end deffn
@deffn {Function} {ln} (n)
@anchor{❨376❩}@c
@functionsubindex{ln}@c
Natural logarithm.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {lower-triangular-matrix-elements} (instance)
@anchor{❨254❩}@c
@functionsubindex{lower-triangular-matrix-elements}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {lower-triangular-matrix-p} (object)
@anchor{❨259❩}@c
@functionsubindex{lower-triangular-matrix-p}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {make-diagonal-matrix} (&key elements)
@anchor{❨245❩}@c
@functionsubindex{make-diagonal-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {make-hermitian-matrix} (&key elements)
@anchor{❨266❩}@c
@functionsubindex{make-hermitian-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {make-iterative-quadrature} (&key f a b h n sum)
@anchor{❨57❩}@c
@functionsubindex{make-iterative-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {make-lower-triangular-matrix} (&key elements)
@anchor{❨272❩}@c
@functionsubindex{make-lower-triangular-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {make-test-results} (&key worst-case min-error max-error mean-error test-count variance0 variance1 rms)
@anchor{❨342❩}@c
@functionsubindex{make-test-results}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {make-upper-triangular-matrix} (&key elements)
@anchor{❨271❩}@c
@functionsubindex{make-upper-triangular-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {make-wrapped-matrix} (&key elements)
@anchor{❨252❩}@c
@functionsubindex{make-wrapped-matrix}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature} (f a b)
@anchor{❨85❩}@c
@functionsubindex{midpoint-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature%} (&key f a b h n sum)
@anchor{❨88❩}@c
@functionsubindex{midpoint-quadrature%}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-a} (instance)
@anchor{❨74❩}@c
@functionsubindex{midpoint-quadrature-a}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf midpoint-quadrature-a)} (instance)
@anchor{❨75❩}@c
@functionsubindex{(setf midpoint-quadrature-a)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-b} (instance)
@anchor{❨43❩}@c
@functionsubindex{midpoint-quadrature-b}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf midpoint-quadrature-b)} (instance)
@anchor{❨44❩}@c
@functionsubindex{(setf midpoint-quadrature-b)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-f} (instance)
@anchor{❨47❩}@c
@functionsubindex{midpoint-quadrature-f}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf midpoint-quadrature-f)} (instance)
@anchor{❨48❩}@c
@functionsubindex{(setf midpoint-quadrature-f)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-h} (instance)
@anchor{❨39❩}@c
@functionsubindex{midpoint-quadrature-h}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf midpoint-quadrature-h)} (instance)
@anchor{❨40❩}@c
@functionsubindex{(setf midpoint-quadrature-h)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-n} (instance)
@anchor{❨49❩}@c
@functionsubindex{midpoint-quadrature-n}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf midpoint-quadrature-n)} (instance)
@anchor{❨50❩}@c
@functionsubindex{(setf midpoint-quadrature-n)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-p} (object)
@anchor{❨110❩}@c
@functionsubindex{midpoint-quadrature-p}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {midpoint-quadrature-sum} (instance)
@anchor{❨105❩}@c
@functionsubindex{midpoint-quadrature-sum}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf midpoint-quadrature-sum)} (instance)
@anchor{❨106❩}@c
@functionsubindex{(setf midpoint-quadrature-sum)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {narrow-bracket?} (a b delta)
@anchor{❨562❩}@c
@functionsubindex{narrow-bracket?}@c
Return true iff $|a-b| < @backslashchar{}delta$.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end deffn
@deffn {Function} {near-root?} (f epsilon)
@anchor{❨560❩}@c
@functionsubindex{near-root?}@c
Return true iff $|f| < @backslashchar{}epsilon$.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end deffn
@deffn {Function} {opposite-sign?} (a b)
@anchor{❨561❩}@c
@functionsubindex{opposite-sign?}@c
Return true iff A and B are on opposite sides of 0.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end deffn
@deffn {Function} {pad-left-expansion} (rows ncol)
@anchor{❨203❩}@c
@functionsubindex{pad-left-expansion}@c
Pad ragged-right rows.  Used internally to implement ragged right matrix specifications.
@table @strong
@item Package
@ref{❨24❩, , @t{num-utils.matrix-shorthand}}.
@item Source
@ref{❨12❩, , @t{matrix-shorthand.lisp}}.
@end table
@end deffn
@deffn {Function} {print-matrix-formatter} (x)
@anchor{❨120❩}@c
@functionsubindex{print-matrix-formatter}@c
Standard formatter for matrix printing.  Respects *print-precision*@comma{} and formats complex numbers as a+bi@comma{} eg 0.0+1.0i.
@table @strong
@item Package
@ref{❨21❩, , @t{num-utils.print-matrix}}.
@item Source
@ref{❨10❩, , @t{print-matrix.lisp}}.
@end table
@end deffn
@deffn {Reader} {relative-fraction} (instance)
@anchor{❨178❩}@c
@functionsubindex{relative-fraction}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Target Slot
@ref{❨161❩, , @t{fraction}}.
@end table
@end deffn
@deffn {Function} {relative-p} (object)
@anchor{❨193❩}@c
@functionsubindex{relative-p}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Function} {richardson-extrapolation} (coefficient iterations)
@anchor{❨93❩}@c
@functionsubindex{richardson-extrapolation}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Reader} {richardson-extrapolation-coefficient} (instance)
@anchor{❨64❩}@c
@functionsubindex{richardson-extrapolation-coefficient}@c
@deffnx {Writer} {(setf richardson-extrapolation-coefficient)} (instance)
@anchor{❨65❩}@c
@functionsubindex{(setf richardson-extrapolation-coefficient)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨95❩, , @t{coefficient}}.
@end table
@end deffn
@deffn {Reader} {richardson-extrapolation-diagonal} (instance)
@anchor{❨79❩}@c
@functionsubindex{richardson-extrapolation-diagonal}@c
@deffnx {Writer} {(setf richardson-extrapolation-diagonal)} (instance)
@anchor{❨80❩}@c
@functionsubindex{(setf richardson-extrapolation-diagonal)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨97❩, , @t{diagonal}}.
@end table
@end deffn
@deffn {Reader} {richardson-extrapolation-n} (instance)
@anchor{❨62❩}@c
@functionsubindex{richardson-extrapolation-n}@c
@deffnx {Writer} {(setf richardson-extrapolation-n)} (instance)
@anchor{❨63❩}@c
@functionsubindex{(setf richardson-extrapolation-n)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Target Slot
@ref{❨96❩, , @t{n}}.
@end table
@end deffn
@deffn {Function} {richardson-extrapolation-p} (object)
@anchor{❨61❩}@c
@functionsubindex{richardson-extrapolation-p}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {richardson-iteration} (extrapolation step)
@anchor{❨84❩}@c
@functionsubindex{richardson-iteration}@c
Add STEP (= $A(h q^@lbracechar{}-k@rbracechar{}$) to an existing Richardson EXTRAPOLATION.  See the documentation of RICHARDSON-EXTRAPOLATION for details.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {romberg-quadrature%} (quadrature epsilon min-iter max-iter)
@anchor{❨87❩}@c
@functionsubindex{romberg-quadrature%}@c
Internal function implementing Romberg quadrature.  Requires an iterative quadrature instance@comma{} a relative EPSILON and MIN-ITER for the stopping criterion@comma{} and the maximum number of iterations allowed.  Works on finite intervals.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {rootfinding-delta} (interval &optional delta-relative)
@anchor{❨559❩}@c
@functionsubindex{rootfinding-delta}@c
Default DELTA for rootfinding methods@comma{} uses bracket width.
@table @strong
@item Package
@ref{❨35❩, , @t{num-utils.rootfinding}}.
@item Source
@ref{❨15❩, , @t{rootfinding.lisp}}.
@end table
@end deffn
@deffn {Function} {similar-element-type} (element-type)
@anchor{❨375❩}@c
@functionsubindex{similar-element-type}@c
Return a type that is a supertype of ELEMENT-TYPE and is closed under arithmetic operations.  May not be the narrowest.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {similar-sequence-type} (sequence)
@anchor{❨374❩}@c
@functionsubindex{similar-sequence-type}@c
Return type that sequence can be mapped to using arithmetic operations.
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Source
@ref{❨6❩, , @t{arithmetic.lisp}}.
@end table
@end deffn
@deffn {Function} {spacer-p} (object)
@anchor{❨177❩}@c
@functionsubindex{spacer-p}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@end table
@end deffn
@deffn {Reader} {spacer-weight} (instance)
@anchor{❨194❩}@c
@functionsubindex{spacer-weight}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Target Slot
@ref{❨147❩, , @t{weight}}.
@end table
@end deffn
@deffn {Function} {test-results-p} (object)
@anchor{❨343❩}@c
@functionsubindex{test-results-p}@c
@table @strong
@item Package
@ref{❨29❩, , @t{num-utils.test-utilities}}.
@item Source
@ref{❨18❩, , @t{test-utilities.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature} (f a b)
@anchor{❨58❩}@c
@functionsubindex{trapezoidal-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature%} (&key f a b h n sum)
@anchor{❨37❩}@c
@functionsubindex{trapezoidal-quadrature%}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-a} (instance)
@anchor{❨81❩}@c
@functionsubindex{trapezoidal-quadrature-a}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf trapezoidal-quadrature-a)} (instance)
@anchor{❨82❩}@c
@functionsubindex{(setf trapezoidal-quadrature-a)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-b} (instance)
@anchor{❨45❩}@c
@functionsubindex{trapezoidal-quadrature-b}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf trapezoidal-quadrature-b)} (instance)
@anchor{❨46❩}@c
@functionsubindex{(setf trapezoidal-quadrature-b)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-f} (instance)
@anchor{❨70❩}@c
@functionsubindex{trapezoidal-quadrature-f}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf trapezoidal-quadrature-f)} (instance)
@anchor{❨71❩}@c
@functionsubindex{(setf trapezoidal-quadrature-f)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-h} (instance)
@anchor{❨72❩}@c
@functionsubindex{trapezoidal-quadrature-h}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf trapezoidal-quadrature-h)} (instance)
@anchor{❨73❩}@c
@functionsubindex{(setf trapezoidal-quadrature-h)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-n} (instance)
@anchor{❨68❩}@c
@functionsubindex{trapezoidal-quadrature-n}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf trapezoidal-quadrature-n)} (instance)
@anchor{❨69❩}@c
@functionsubindex{(setf trapezoidal-quadrature-n)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-p} (object)
@anchor{❨60❩}@c
@functionsubindex{trapezoidal-quadrature-p}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {trapezoidal-quadrature-sum} (instance)
@anchor{❨54❩}@c
@functionsubindex{trapezoidal-quadrature-sum}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {(setf trapezoidal-quadrature-sum)} (instance)
@anchor{❨55❩}@c
@functionsubindex{(setf trapezoidal-quadrature-sum)}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@end table
@end deffn
@deffn {Function} {upper-triangular-matrix-elements} (instance)
@anchor{❨246❩}@c
@functionsubindex{upper-triangular-matrix-elements}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {upper-triangular-matrix-p} (object)
@anchor{❨267❩}@c
@functionsubindex{upper-triangular-matrix-p}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {valid-sparse-type?} (type)
@anchor{❨255❩}@c
@functionsubindex{valid-sparse-type?}@c
Check if TYPE is a valid type for sparse matrices.  Only supertypes and subtypes of NUMBER are allowed.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {wrapped-matrix-p} (object)
@anchor{❨263❩}@c
@functionsubindex{wrapped-matrix-p}@c
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn
@deffn {Function} {zero-like} (array)
@anchor{❨270❩}@c
@functionsubindex{zero-like}@c
Return 0 coerced to the element type of ARRAY.  It is assumed that the latter satisfies VALID-SPARSE-TYPE?.
@table @strong
@item Package
@ref{❨26❩, , @t{num-utils.matrix}}.
@item Source
@ref{❨11❩, , @t{matrix.lisp}}.
@end table
@end deffn

@node Private generic functions, Private structures, Private ordinary functions, Internals
@subsection Generic functions
@deffn {Generic Function} {chebyshev-approximate-implementation} (f interval n-polynomials n-points)
@anchor{❨126❩}@c
@genericsubindex{chebyshev-approximate-implementation}@c
Implementation of CHEBYSHEV-APPROXIMATE.
@table @strong
@item Package
@ref{❨22❩, , @t{num-utils.chebyshev}}.
@item Source
@ref{❨13❩, , @t{chebyshev.lisp}}.
@item Methods
@deffn {Method} {chebyshev-approximate-implementation} (f (interval @ref{❨150❩, , @t{plusinf-interval}}) n-polynomials n-points)
@anchor{❨127❩}@c
@methodsubindex{chebyshev-approximate-implementation}@c
@table @strong
@end table
@end deffn
@deffn {Method} {chebyshev-approximate-implementation} (f (interval @ref{❨172❩, , @t{finite-interval}}) n-polynomials n-points)
@anchor{❨128❩}@c
@methodsubindex{chebyshev-approximate-implementation}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {esquare} (a)
@anchor{❨531❩}@c
@genericsubindex{esquare}@c
Univariate elementwise SQUARE.
@table @strong
@item Package
@ref{❨31❩, , @t{num-utils.elementwise}}.
@item Source
@ref{❨7❩, , @t{elementwise.lisp}}.
@item Methods
@deffn {Method} {esquare} ((a @t{number}))
@anchor{❨532❩}@c
@methodsubindex{esquare}@c
@table @strong
@end table
@end deffn
@deffn {Method} {esquare} ((a @t{array}))
@anchor{❨533❩}@c
@methodsubindex{esquare}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {print-left-endpoint} (interval stream)
@anchor{❨183❩}@c
@genericsubindex{print-left-endpoint}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {print-left-endpoint} ((interval @ref{❨190❩, , @t{interval/finite-left}}) stream)
@anchor{❨184❩}@c
@methodsubindex{print-left-endpoint}@c
@table @strong
@end table
@end deffn
@deffn {Method} {print-left-endpoint} ((interval @ref{❨182❩, , @t{interval/infinite-left}}) stream)
@anchor{❨185❩}@c
@methodsubindex{print-left-endpoint}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {print-right-endpoint} (interval stream)
@anchor{❨179❩}@c
@genericsubindex{print-right-endpoint}@c
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Methods
@deffn {Method} {print-right-endpoint} ((interval @ref{❨187❩, , @t{interval/finite-right}}) stream)
@anchor{❨180❩}@c
@methodsubindex{print-right-endpoint}@c
@table @strong
@end table
@end deffn
@deffn {Method} {print-right-endpoint} ((interval @ref{❨196❩, , @t{interval/infinite-right}}) stream)
@anchor{❨181❩}@c
@methodsubindex{print-right-endpoint}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {refine-quadrature} (quadrature)
@anchor{❨114❩}@c
@genericsubindex{refine-quadrature}@c
Refine quadrature with more points.  Return the sum for those points.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Methods
@deffn {Method} {refine-quadrature} ((quadrature @ref{❨86❩, , @t{midpoint-quadrature}}))
@anchor{❨115❩}@c
@methodsubindex{refine-quadrature}@c
@table @strong
@end table
@end deffn
@deffn {Method} {refine-quadrature} ((quadrature @ref{❨59❩, , @t{trapezoidal-quadrature}}))
@anchor{❨116❩}@c
@methodsubindex{refine-quadrature}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {richardson-coefficient} (quadrature)
@anchor{❨107❩}@c
@genericsubindex{richardson-coefficient}@c
Return the coefficient $q$ for Richardson approximation.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Methods
@deffn {Method} {richardson-coefficient} ((quadrature @ref{❨86❩, , @t{midpoint-quadrature}}))
@anchor{❨108❩}@c
@methodsubindex{richardson-coefficient}@c
@table @strong
@end table
@end deffn
@deffn {Method} {richardson-coefficient} ((quadrature @ref{❨59❩, , @t{trapezoidal-quadrature}}))
@anchor{❨109❩}@c
@methodsubindex{richardson-coefficient}@c
@table @strong
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {transformed-quadrature} (function interval transformation)
@anchor{❨51❩}@c
@genericsubindex{transformed-quadrature}@c
Return a quadrature for integrating FUNCTION on INTERVAL@comma{} which may be infinite@comma{} in which case FUNCTION will be transformed.  TRANSFORMATION can be used to select the transformation when applicable@comma{} otherwise it is NIL.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Methods
@deffn {Method} {transformed-quadrature} (function (interval @ref{❨172❩, , @t{finite-interval}}) (transformation @t{null}))
@anchor{❨52❩}@c
@methodsubindex{transformed-quadrature}@c
@table @strong
@end table
@end deffn
@deffn {Method} {transformed-quadrature} (function (interval @ref{❨150❩, , @t{plusinf-interval}}) (transformation @t{null}))
@anchor{❨53❩}@c
@methodsubindex{transformed-quadrature}@c
@table @strong
@end table
@end deffn
@end table
@end deffn

@node Private structures, Private classes, Private generic functions, Internals
@subsection Structures
@deftp {Structure} {iterative-quadrature}
@anchor{❨98❩}@c
@structuresubindex{iterative-quadrature}@c
Quadrature building block.

F is the function.@*

A and B are the endpoints.

H is the stepsize.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨86❩, , @t{midpoint-quadrature}}.
@item
@ref{❨59❩, , @t{trapezoidal-quadrature}}.
@end itemize
@item Direct slots
@defvr {Slot} {f}
@anchor{❨99❩}@c
@slotsubindex{f}@c
@table @strong
@item Type
@t{(function (double-float) double-float)}
@item Readers
@ref{❨76❩, , @t{iterative-quadrature-f}}.
@item Writers
@ref{❨77❩, , @t{(setf iterative-quadrature-f)}}.
@end table
@end defvr
@defvr {Slot} {a}
@anchor{❨100❩}@c
@slotsubindex{a}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{❨41❩, , @t{iterative-quadrature-a}}.
@item Writers
@ref{❨42❩, , @t{(setf iterative-quadrature-a)}}.
@end table
@end defvr
@defvr {Slot} {b}
@anchor{❨101❩}@c
@slotsubindex{b}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{❨91❩, , @t{iterative-quadrature-b}}.
@item Writers
@ref{❨92❩, , @t{(setf iterative-quadrature-b)}}.
@end table
@end defvr
@defvr {Slot} {h}
@anchor{❨102❩}@c
@slotsubindex{h}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{❨89❩, , @t{iterative-quadrature-h}}.
@item Writers
@ref{❨90❩, , @t{(setf iterative-quadrature-h)}}.
@end table
@end defvr
@defvr {Slot} {n}
@anchor{❨103❩}@c
@slotsubindex{n}@c
@table @strong
@item Type
@t{fixnum}
@item Initform
@t{0}
@item Readers
@ref{❨111❩, , @t{iterative-quadrature-n}}.
@item Writers
@ref{❨112❩, , @t{(setf iterative-quadrature-n)}}.
@end table
@end defvr
@defvr {Slot} {sum}
@anchor{❨104❩}@c
@slotsubindex{sum}@c
@table @strong
@item Package
@ref{❨30❩, , @t{num-utils.arithmetic}}.
@item Type
@t{double-float}
@item Initform
@t{0.0d0}
@item Readers
@ref{❨66❩, , @t{iterative-quadrature-sum}}.
@item Writers
@ref{❨67❩, , @t{(setf iterative-quadrature-sum)}}.
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {midpoint-quadrature}
@anchor{❨86❩}@c
@structuresubindex{midpoint-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Direct superclasses
@ref{❨98❩, , @t{iterative-quadrature}}.
@item Direct methods
@itemize @bullet
@item
@ref{❨115❩, , @t{refine-quadrature}}.
@item
@ref{❨108❩, , @t{richardson-coefficient}}.
@end itemize
@end table
@end deftp
@deftp {Structure} {richardson-extrapolation}
@anchor{❨94❩}@c
@structuresubindex{richardson-extrapolation}@c
Given A(h)=A_0 + sum_@lbracechar{}k=1@rbracechar{}^infty a_k h^@lbracechar{}kp@rbracechar{}@comma{} calculate approximations for A given A(h q^@lbracechar{}-k@rbracechar{})@comma{} where the latter can be incorporated using RICHARDSON-ITERATION with consecutive values for k=1@comma{}...@comma{}max_iter@comma{} which returns the latest A(0) as the first and the largest relative change@comma{} which can be used to test termination.

The algorithm uses Richardson extrapolation@comma{} the required coefficient is q^k.
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Direct superclasses
@t{structure-object}.
@item Direct slots
@defvr {Slot} {coefficient}
@anchor{❨95❩}@c
@slotsubindex{coefficient}@c
@table @strong
@item Type
@t{double-float}
@item Readers
@ref{❨64❩, , @t{richardson-extrapolation-coefficient}}.
@item Writers
@ref{❨65❩, , @t{(setf richardson-extrapolation-coefficient)}}.
@end table
@end defvr
@defvr {Slot} {n}
@anchor{❨96❩}@c
@slotsubindex{n}@c
@table @strong
@item Type
@t{fixnum}
@item Initform
@t{0}
@item Readers
@ref{❨62❩, , @t{richardson-extrapolation-n}}.
@item Writers
@ref{❨63❩, , @t{(setf richardson-extrapolation-n)}}.
@end table
@end defvr
@defvr {Slot} {diagonal}
@anchor{❨97❩}@c
@slotsubindex{diagonal}@c
@table @strong
@item Type
@t{(array double-float (*))}
@item Readers
@ref{❨79❩, , @t{richardson-extrapolation-diagonal}}.
@item Writers
@ref{❨80❩, , @t{(setf richardson-extrapolation-diagonal)}}.
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {trapezoidal-quadrature}
@anchor{❨59❩}@c
@structuresubindex{trapezoidal-quadrature}@c
@table @strong
@item Package
@ref{❨20❩, , @t{num-utils.quadrature}}.
@item Source
@ref{❨16❩, , @t{quadrature.lisp}}.
@item Direct superclasses
@ref{❨98❩, , @t{iterative-quadrature}}.
@item Direct methods
@itemize @bullet
@item
@ref{❨116❩, , @t{refine-quadrature}}.
@item
@ref{❨109❩, , @t{richardson-coefficient}}.
@end itemize
@end table
@end deftp

@node Private classes, Private types, Private structures, Internals
@subsection Classes
@deftp {Class} {interval/finite-left}
@anchor{❨190❩}@c
@classsubindex{interval/finite-left}@c
Interval with left endpoint.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨172❩, , @t{finite-interval}}.
@item
@ref{❨150❩, , @t{plusinf-interval}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨157❩, , @t{left}}.
@item
@ref{❨137❩, , @t{open-left?}}.
@item
@ref{❨184❩, , @t{print-left-endpoint}}.
@end itemize
@item Direct slots
@defvr {Slot} {left}
@anchor{❨191❩}@c
@slotsubindex{left}@c
@table @strong
@item Type
@t{real}
@item Initargs
@t{:left}
@item Readers
@ref{❨157❩, , @t{left}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {open-left?}
@anchor{❨192❩}@c
@slotsubindex{open-left?}@c
@table @strong
@item Type
@t{boolean}
@item Initargs
@t{:open-left?}
@item Readers
@ref{❨137❩, , @t{open-left?}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Class} {interval/finite-right}
@anchor{❨187❩}@c
@classsubindex{interval/finite-right}@c
Interval with right endpoint.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨172❩, , @t{finite-interval}}.
@item
@ref{❨171❩, , @t{minusinf-interval}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨175❩, , @t{open-right?}}.
@item
@ref{❨180❩, , @t{print-right-endpoint}}.
@item
@ref{❨166❩, , @t{right}}.
@end itemize
@item Direct slots
@defvr {Slot} {right}
@anchor{❨188❩}@c
@slotsubindex{right}@c
@table @strong
@item Type
@t{real}
@item Initargs
@t{:right}
@item Readers
@ref{❨166❩, , @t{right}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@defvr {Slot} {open-right?}
@anchor{❨189❩}@c
@slotsubindex{open-right?}@c
@table @strong
@item Type
@t{boolean}
@item Initargs
@t{:open-right?}
@item Readers
@ref{❨175❩, , @t{open-right?}}.
@item Writers
@i{This slot is read-only.}
@end table
@end defvr
@end table
@end deftp
@deftp {Class} {interval/infinite-left}
@anchor{❨182❩}@c
@classsubindex{interval/infinite-left}@c
Left endpoint is -∞.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨171❩, , @t{minusinf-interval}}.
@item
@ref{❨148❩, , @t{real-line}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨156❩, , @t{left}}.
@item
@ref{❨136❩, , @t{open-left?}}.
@item
@ref{❨185❩, , @t{print-left-endpoint}}.
@end itemize
@end table
@end deftp
@deftp {Class} {interval/infinite-right}
@anchor{❨196❩}@c
@classsubindex{interval/infinite-right}@c
Right endpoint is ∞.
@table @strong
@item Package
@ref{❨23❩, , @t{num-utils.interval}}.
@item Source
@ref{❨9❩, , @t{interval.lisp}}.
@item Direct subclasses
@itemize @bullet
@item
@ref{❨150❩, , @t{plusinf-interval}}.
@item
@ref{❨148❩, , @t{real-line}}.
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{❨174❩, , @t{open-right?}}.
@item
@ref{❨181❩, , @t{print-right-endpoint}}.
@item
@ref{❨165❩, , @t{right}}.
@end itemize
@end table
@end deftp

@node Private types, , Private classes, Internals
@subsection Types
@deftp {Type} {infinite} ()
@anchor{❨283❩}@c
@typesubindex{infinite}@c
Representing infinity (extending the real line).
@table @strong
@item Package
@ref{❨27❩, , @t{num-utils.extended-real}}.
@item Source
@ref{❨8❩, , @t{extended-real.lisp}}.
@end table
@end deftp



@c ====================================================================
@c Indexes
@c ====================================================================
@node Indexes, , Definitions, Top
@appendix Indexes
@menu
* Concept index::
* Function index::
* Variable index::
* Data type index::
@end menu


@c -------------
@c Concept index
@c -------------
@node Concept index, Function index, Indexes, Indexes
@appendixsec Concepts
@printindex cp

@page


@c --------------
@c Function index
@c --------------
@node Function index, Variable index, Concept index, Indexes
@appendixsec Functions
@printindex fn

@page


@c --------------
@c Variable index
@c --------------
@node Variable index, Data type index, Function index, Indexes
@appendixsec Variables
@printindex vr

@page


@c ---------------
@c Data type index
@c ---------------
@node Data type index, , Variable index, Indexes
@appendixsec Data types
@printindex tp

@bye

@c num-utils.texi ends here
